package com.volaticloud.keycloak.tenant.services;

import com.volaticloud.keycloak.tenant.NotFoundException;
import com.volaticloud.keycloak.tenant.representations.*;
import lombok.extern.jbosslog.JBossLog;
import org.keycloak.authorization.AuthorizationProvider;
import org.keycloak.authorization.model.Resource;
import org.keycloak.authorization.model.ResourceServer;
import org.keycloak.authorization.model.Scope;
import org.keycloak.authorization.store.ResourceStore;
import org.keycloak.authorization.store.ScopeStore;
import org.keycloak.models.*;
import org.keycloak.organization.OrganizationProvider;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Service for unified resource management (UMA resource + Keycloak group).
 *
 * <p>Provides operations that manage both UMA resources (for authorization)
 * and Keycloak groups (for organizational hierarchy) together. Operations attempt
 * to keep both entities synchronized, but <strong>true ACID transactions are not
 * guaranteed</strong> across Keycloak API calls.
 *
 * <p><strong>Consistency Model:</strong> Best-effort synchronization with cleanup on failures.
 *
 * <p><strong>Organization Creation Order:</strong>
 * <ol>
 *   <li>Native Keycloak Organization (source of truth, generates ID)</li>
 *   <li>Keycloak Group with role subgroups (uses org ID as name)</li>
 *   <li>UMA Resource (uses org ID as name)</li>
 * </ol>
 *
 * <p><strong>Other Resource Types Creation Order:</strong>
 * <ol>
 *   <li>Keycloak Group (uses provided ID)</li>
 *   <li>UMA Resource</li>
 * </ol>
 */
@JBossLog
public class ResourceManagementService {

    private static final String VOLATICLOUD_CLIENT = "volaticloud";
    private static final String RESOURCE_TYPE_TENANT = "urn:volaticloud:resources:tenant";
    private static final String GROUP_TYPE_ATTRIBUTE = "GROUP_TYPE";
    private static final String GROUP_TITLE_ATTRIBUTE = "GROUP_TITLE";
    private static final String ROLE_ADMIN = "role:admin";
    private static final String ROLE_VIEWER = "role:viewer";
    private static final String RESOURCE_TYPE_ORGANIZATION = "organization";

    private final KeycloakSession session;

    public ResourceManagementService(KeycloakSession session) {
        this.session = session;
    }

    /**
     * Creates a unified resource (UMA resource + Keycloak group) atomically.
     *
     * <p><strong>Transaction Boundaries:</strong> This method executes multiple Keycloak API calls
     * within the same Keycloak session. If any step fails, subsequent steps are skipped and an
     * exception is thrown. The caller should handle transaction rollback in the database layer.
     *
     * <p><strong>For Organizations:</strong> Native Organization is created FIRST as the source of truth.
     * The organization ID generated by Keycloak is then used for all subsequent entities.
     * ID in request is optional for organizations.
     *
     * <p><strong>For Other Resources:</strong> ID must be provided in the request.
     *
     * @param request Resource creation request
     * @return ResourceResponse with created resource details
     * @throws Exception if creation fails
     */
    public ResourceResponse createResource(ResourceCreateRequest request) throws Exception {
        RealmModel realm = session.getContext().getRealm();
        if (realm == null) {
            throw new Exception("Could not get realm from session context");
        }

        // Validate common inputs
        if (request.getTitle() == null || request.getTitle().isEmpty()) {
            throw new IllegalArgumentException("Resource title is required");
        }
        if (request.getTitle().length() > 255) {
            throw new IllegalArgumentException("Resource title must not exceed 255 characters");
        }
        if (request.getType() == null || request.getType().isEmpty()) {
            throw new IllegalArgumentException("Resource type is required");
        }

        // Route to appropriate creation method based on resource type
        if (RESOURCE_TYPE_ORGANIZATION.equals(request.getType())) {
            return createOrganizationResource(realm, request);
        } else {
            return createNonOrganizationResource(realm, request);
        }
    }

    /**
     * Creates an organization resource with Native Organization as the source of truth.
     *
     * <p><strong>Creation Order:</strong>
     * <ol>
     *   <li>Native Keycloak Organization (with generated alias as our identifier)</li>
     *   <li>Keycloak Group with role subgroups (using alias as name)</li>
     *   <li>UMA Resource (uses alias as name)</li>
     * </ol>
     *
     * <p><strong>Note:</strong> We use the organization's ALIAS (not ID) as our resource identifier.
     * This avoids conflicts with Keycloak's internal organization groups which use the org ID.
     * The alias is immutable and unique, making it ideal as our stable identifier.
     *
     * @param realm The realm
     * @param request Resource creation request (ID is optional)
     * @return ResourceResponse with created resource details
     * @throws Exception if creation fails
     */
    private ResourceResponse createOrganizationResource(RealmModel realm, ResourceCreateRequest request) throws Exception {
        log.infof("Creating organization resource with title: %s", request.getTitle());

        // Use alias from request if provided, otherwise generate a UUID
        // The alias is the human-readable, URL-friendly identifier (e.g., "my-organization")
        // It's immutable after creation and used as the unique identifier for all resources
        String resourceId = (request.getId() != null && !request.getId().isEmpty())
            ? request.getId()
            : UUID.randomUUID().toString();

        // Validate alias format if provided by frontend
        if (request.getId() != null && !request.getId().isEmpty()) {
            validateOrganizationAlias(resourceId);
        }

        // Step 1: Create Native Organization with the alias
        // The alias becomes our stable identifier for the organization resource
        OrganizationModel nativeOrg = createNativeOrganizationWithAlias(request.getTitle(), resourceId);
        log.infof("Created native organization: id=%s, alias=%s (alias is our resource ID)", nativeOrg.getId(), resourceId);

        // Step 2: Create our group hierarchy using the ALIAS as the group name
        // This avoids conflict with Keycloak's internal org group (which uses org.getId())
        GroupModel group;
        try {
            group = createGroupWithRoles(realm, resourceId, null, request.getType(), request.getTitle());
            log.infof("Created organization group: %s with type=%s, title=%s", resourceId, request.getType(), request.getTitle());
        } catch (Exception e) {
            log.errorf("Group creation failed, cleaning up native organization: alias=%s", resourceId);
            deleteNativeOrganizationByAlias(resourceId);
            throw e;
        }

        // Step 3: Create UMA resource using the ALIAS as the resource name
        Resource resource;
        try {
            resource = createUMAResourceWithId(realm, resourceId, request, null);
        } catch (Exception e) {
            log.errorf("UMA resource creation failed, cleaning up group and native organization: alias=%s", resourceId);
            try {
                session.groups().removeGroup(realm, group);
            } catch (Exception cleanupError) {
                log.errorf(cleanupError, "Failed to cleanup group: %s", resourceId);
            }
            deleteNativeOrganizationByAlias(resourceId);
            throw e;
        }

        log.infof("Successfully created organization resource: alias=%s, title=%s", resourceId, request.getTitle());
        return buildResourceResponse(resource, group, null);
    }

    /**
     * Creates a non-organization resource (strategy, bot, exchange, runner).
     *
     * <p><strong>Creation Order:</strong>
     * <ol>
     *   <li>Keycloak Group with role subgroups</li>
     *   <li>UMA Resource</li>
     * </ol>
     *
     * @param realm The realm
     * @param request Resource creation request (ID is required)
     * @return ResourceResponse with created resource details
     * @throws Exception if creation fails
     */
    private ResourceResponse createNonOrganizationResource(RealmModel realm, ResourceCreateRequest request) throws Exception {
        // Validate ID for non-organization resources
        if (request.getId() == null || request.getId().isEmpty()) {
            throw new IllegalArgumentException("Resource ID is required for non-organization resources");
        }
        try {
            java.util.UUID.fromString(request.getId());
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Resource ID must be a valid UUID: " + request.getId());
        }

        // Check if resource already exists
        Resource existingResource = findResourceByName(realm, request.getId());
        if (existingResource != null) {
            throw new IllegalStateException("Resource already exists: " + request.getId());
        }

        // Get parent group if ownerId is provided
        GroupModel parentGroup = null;
        if (request.getOwnerId() != null && !request.getOwnerId().isEmpty()) {
            parentGroup = session.groups()
                .searchForGroupByNameStream(realm, request.getOwnerId(), true, 0, 1)
                .findFirst()
                .orElse(null);
            if (parentGroup == null) {
                throw new NotFoundException("Parent resource not found: " + request.getOwnerId());
            }
        }

        // Step 1: Create Keycloak group with role subgroups
        GroupModel group = createGroupWithRoles(realm, request.getId(), parentGroup, request.getType(), request.getTitle());

        // Step 2: Create UMA resource (with cleanup on failure)
        Resource resource;
        try {
            resource = createUMAResource(realm, request, parentGroup);
        } catch (Exception e) {
            log.errorf("UMA resource creation failed, cleaning up group: %s", request.getId());
            try {
                session.groups().removeGroup(realm, group);
                log.infof("Successfully cleaned up orphaned group: %s", request.getId());
            } catch (Exception cleanupError) {
                log.errorf(cleanupError, "Failed to cleanup group after UMA resource creation failure: %s", request.getId());
            }
            throw e;
        }

        return buildResourceResponse(resource, group, parentGroup);
    }

    /**
     * Updates a unified resource (UMA resource + Keycloak group) atomically.
     *
     * <p><strong>Transaction Boundaries:</strong> Updates are applied to both UMA resource and group
     * within the same Keycloak session. Partial updates are possible (either title or attributes can
     * be omitted). If updates fail, an exception is thrown and the caller should handle rollback.
     *
     * @param resourceId Resource ID to update
     * @param request Update request with fields to change
     * @return ResourceResponse with updated resource details
     * @throws Exception if update fails
     */
    public ResourceResponse updateResource(String resourceId, ResourceUpdateRequest request) throws Exception {
        RealmModel realm = session.getContext().getRealm();
        if (realm == null) {
            throw new Exception("Could not get realm from session context");
        }

        // Validate title if provided
        if (request.getTitle() != null && !request.getTitle().isEmpty()) {
            if (request.getTitle().length() > 255) {
                throw new IllegalArgumentException("Resource title must not exceed 255 characters");
            }
        }

        // Step 1: Find UMA resource
        Resource resource = findResourceByName(realm, resourceId);
        if (resource == null) {
            throw new NotFoundException("Resource not found: " + resourceId);
        }

        // Step 2: Find Keycloak group
        // IMPORTANT: Use searchForGroupByNameStream() instead of getGroupByName()
        // to search globally across all nested group hierarchies (see createResource() for details).
        GroupModel group = session.groups()
            .searchForGroupByNameStream(realm, resourceId, true, 0, 1)
            .findFirst()
            .orElse(null);
        if (group == null) {
            throw new NotFoundException("Group not found: " + resourceId);
        }

        // Step 3: Update group attributes if title changed
        if (request.getTitle() != null && !request.getTitle().isEmpty()) {
            group.setSingleAttribute(GROUP_TITLE_ATTRIBUTE, request.getTitle());
            log.infof("Updated GROUP_TITLE for resource %s to: %s", resourceId, request.getTitle());
        }

        // Step 4: Update UMA resource attributes AND sync to group if provided
        if (request.getAttributes() != null && !request.getAttributes().isEmpty()) {
            for (Map.Entry<String, List<String>> entry : request.getAttributes().entrySet()) {
                String attrKey = entry.getKey();
                List<String> attrValue = entry.getValue();

                // Update UMA resource attribute
                resource.setAttribute(attrKey, attrValue);

                // Sync specific attributes to group
                // "type" attribute in UMA should sync to GROUP_TYPE in group
                if (attrKey.equals("type") && attrValue != null && !attrValue.isEmpty()) {
                    group.setSingleAttribute(GROUP_TYPE_ATTRIBUTE, attrValue.get(0));
                    log.infof("Updated GROUP_TYPE for resource %s to: %s", resourceId, attrValue.get(0));
                }
                // Other custom attributes (like "public", "exchangeType", etc.) are also synced to group
                else {
                    group.setAttribute(attrKey, attrValue);
                    log.infof("Synced attribute %s to group for resource %s", attrKey, resourceId);
                }
            }
            log.infof("Updated UMA resource and synced attributes to group for: %s", resourceId);
        }

        // If title was updated, also update it in UMA resource attributes and displayName
        if (request.getTitle() != null && !request.getTitle().isEmpty()) {
            resource.setAttribute("title", Collections.singletonList(request.getTitle()));
            resource.setDisplayName(request.getTitle());
            log.infof("Updated UMA resource displayName for: %s to: %s", resourceId, request.getTitle());

            // Step 4.5: Update native organization name if type is "organization"
            String groupType = group.getFirstAttribute(GROUP_TYPE_ATTRIBUTE);
            if (RESOURCE_TYPE_ORGANIZATION.equals(groupType)) {
                updateNativeOrganizationName(resourceId, request.getTitle());
            }
        }

        // Step 5: Determine parent group for response
        GroupModel parentGroup = group.getParent();

        // Step 6: Build response
        return buildResourceResponse(resource, group, parentGroup);
    }

    /**
     * Deletes a unified resource (UMA resource + Keycloak group).
     *
     * <p><strong>Organization Resources:</strong> Soft delete (disable) instead of permanent deletion.
     * This preserves all data and prevents alias reuse issues. The organization can be re-enabled later.
     *
     * <p><strong>Other Resources:</strong> Permanent deletion of both UMA resource and Keycloak group.
     *
     * @param resourceId Resource ID to delete
     * @throws Exception if deletion fails
     */
    public void deleteResource(String resourceId) throws Exception {
        RealmModel realm = session.getContext().getRealm();
        if (realm == null) {
            throw new Exception("Could not get realm from session context");
        }

        // Step 0: Check resource type
        GroupModel group = session.groups()
            .searchForGroupByNameStream(realm, resourceId, true, 0, 1)
            .findFirst()
            .orElse(null);

        if (group != null) {
            String groupType = group.getFirstAttribute(GROUP_TYPE_ATTRIBUTE);

            // For organizations: soft delete (disable) instead of permanent deletion
            if (RESOURCE_TYPE_ORGANIZATION.equals(groupType)) {
                disableOrganization(resourceId);
                log.infof("Organization soft-deleted (disabled): %s", resourceId);
                return;
            }
        }

        // For non-organization resources: permanent deletion
        // Step 1: Find and delete UMA resource
        Resource resource = findResourceByName(realm, resourceId);
        if (resource != null) {
            AuthorizationProvider authz = session.getProvider(AuthorizationProvider.class);
            ResourceStore resourceStore = authz.getStoreFactory().getResourceStore();
            resourceStore.delete(resource.getId());
            log.infof("Deleted UMA resource: %s", resourceId);
        } else {
            log.warnf("UMA resource not found: %s", resourceId);
        }

        // Step 2: Delete Keycloak group (already looked up above)
        if (group != null) {
            boolean removed = session.groups().removeGroup(realm, group);
            if (removed) {
                log.infof("Deleted Keycloak group and subgroups: %s", resourceId);
            } else {
                throw new Exception("Failed to delete group: " + resourceId);
            }
        } else {
            log.warnf("Keycloak group not found: %s", resourceId);
        }
    }

    /**
     * Gets resource details.
     *
     * @param resourceId Resource ID
     * @return ResourceResponse with resource details
     * @throws Exception if resource not found
     */
    public ResourceResponse getResource(String resourceId) throws Exception {
        RealmModel realm = session.getContext().getRealm();
        if (realm == null) {
            throw new Exception("Could not get realm from session context");
        }

        // Find UMA resource
        Resource resource = findResourceByName(realm, resourceId);
        if (resource == null) {
            throw new NotFoundException("Resource not found: " + resourceId);
        }

        // Find Keycloak group (search globally with exact match)
        GroupModel group = session.groups()
            .searchForGroupByNameStream(realm, resourceId, true, 0, 1)
            .findFirst()
            .orElse(null);
        if (group == null) {
            throw new NotFoundException("Group not found: " + resourceId);
        }

        // Get parent group
        GroupModel parentGroup = group.getParent();

        // Build response
        return buildResourceResponse(resource, group, parentGroup);
    }

    /**
     * Creates a Keycloak group with role subgroups.
     */
    private GroupModel createGroupWithRoles(RealmModel realm, String groupName, GroupModel parentGroup, String groupType, String groupTitle) {
        // Create main group
        GroupModel group = session.groups().createGroup(realm, groupName, parentGroup);

        // Set GROUP_TYPE attribute
        group.setSingleAttribute(GROUP_TYPE_ATTRIBUTE, groupType);

        // Set GROUP_TITLE attribute
        group.setSingleAttribute(GROUP_TITLE_ATTRIBUTE, groupTitle);

        log.infof("Created group: %s under parent: %s with GROUP_TYPE=%s, GROUP_TITLE=%s",
                 groupName, parentGroup != null ? parentGroup.getName() : "root", groupType, groupTitle);

        // Create role subgroups
        session.groups().createGroup(realm, ROLE_ADMIN, group);
        log.infof("Created subgroup: %s under %s", ROLE_ADMIN, groupName);

        session.groups().createGroup(realm, ROLE_VIEWER, group);
        log.infof("Created subgroup: %s under %s", ROLE_VIEWER, groupName);

        return group;
    }

    /**
     * Creates a UMA resource for the given request.
     */
    private Resource createUMAResource(RealmModel realm, ResourceCreateRequest request, GroupModel parentGroup) throws Exception {
        ClientModel client = realm.getClientByClientId(VOLATICLOUD_CLIENT);
        if (client == null) {
            throw new Exception("Client '" + VOLATICLOUD_CLIENT + "' not found");
        }

        AuthorizationProvider authz = session.getProvider(AuthorizationProvider.class);
        ResourceServer resourceServer = authz.getStoreFactory().getResourceServerStore().findByClient(client);
        if (resourceServer == null) {
            throw new Exception("Resource server not found for client '" + VOLATICLOUD_CLIENT + "'");
        }

        ResourceStore resourceStore = authz.getStoreFactory().getResourceStore();
        ScopeStore scopeStore = authz.getStoreFactory().getScopeStore();

        // Get or create scopes
        Set<Scope> scopes = new HashSet<>();
        if (request.getScopes() != null) {
            for (String scopeName : request.getScopes()) {
                Scope scope = scopeStore.findByName(resourceServer, scopeName);
                if (scope == null) {
                    scope = scopeStore.create(resourceServer, scopeName);
                    log.infof("Created scope: %s", scopeName);
                }
                scopes.add(scope);
            }
        }

        // Create resource
        Resource resource = resourceStore.create(resourceServer, request.getId(), resourceServer.getClientId());

        // Set resource type
        resource.setType(RESOURCE_TYPE_TENANT);

        // Set scopes
        resource.updateScopes(scopes);

        // Set attributes
        if (request.getAttributes() != null) {
            for (Map.Entry<String, List<String>> entry : request.getAttributes().entrySet()) {
                resource.setAttribute(entry.getKey(), entry.getValue());
            }
        }

        // Set ownerId if parent exists
        if (parentGroup != null) {
            resource.setAttribute("ownerId", Collections.singletonList(parentGroup.getName()));
        }

        // Set type attribute
        resource.setAttribute("type", Collections.singletonList(request.getType()));

        // Set title attribute
        resource.setAttribute("title", Collections.singletonList(request.getTitle()));

        // Set display name (this is what shows in Keycloak UI)
        resource.setDisplayName(request.getTitle());

        log.infof("Created UMA resource: %s with type=%s, title=%s", request.getId(), request.getType(), request.getTitle());

        return resource;
    }

    /**
     * Finds a UMA resource by name.
     */
    private Resource findResourceByName(RealmModel realm, String resourceName) {
        try {
            ClientModel client = realm.getClientByClientId(VOLATICLOUD_CLIENT);
            if (client == null) {
                return null;
            }

            AuthorizationProvider authz = session.getProvider(AuthorizationProvider.class);
            ResourceServer resourceServer = authz.getStoreFactory().getResourceServerStore().findByClient(client);
            if (resourceServer == null) {
                return null;
            }

            ResourceStore resourceStore = authz.getStoreFactory().getResourceStore();
            return resourceStore.findByName(resourceServer, resourceName);
        } catch (Exception e) {
            log.errorf(e, "Error finding resource by name: %s", resourceName);
            return null;
        }
    }

    /**
     * Builds a ResourceResponse from UMA resource and Keycloak group.
     */
    private ResourceResponse buildResourceResponse(Resource resource, GroupModel group, GroupModel parentGroup) {
        // Extract attributes from resource
        Map<String, List<String>> attributes = resource.getAttributes();

        // Extract type from GROUP_TYPE attribute
        String type = group.getFirstAttribute(GROUP_TYPE_ATTRIBUTE);

        // Extract title from GROUP_TITLE attribute
        String title = group.getFirstAttribute(GROUP_TITLE_ATTRIBUTE);

        // Extract ownerId
        String ownerId = null;
        if (parentGroup != null) {
            ownerId = parentGroup.getName();
        }

        // Extract scopes
        List<String> scopes = resource.getScopes().stream()
            .map(Scope::getName)
            .collect(Collectors.toList());

        return new ResourceResponse(
            resource.getName(),           // id
            title,                        // title
            type,                         // type
            ownerId,                      // ownerId
            group.getId(),                // groupId
            resource.getId(),             // umaResourceId
            scopes,                       // scopes
            attributes                    // attributes
        );
    }

    // ============================================================================
    // Organization Enable/Disable Methods
    // ============================================================================

    /**
     * Disables an organization (soft delete).
     * Instead of deleting the organization, this disables it which:
     * - Prevents users from accessing the organization
     * - Preserves all data for potential re-activation
     * - Prevents alias reuse issues
     *
     * @param resourceId Organization alias (resource identifier)
     * @throws Exception if disabling fails
     */
    public void disableOrganization(String resourceId) throws Exception {
        RealmModel realm = session.getContext().getRealm();
        if (realm == null) {
            throw new Exception("Could not get realm from session context");
        }

        // Step 1: Find the group to verify it's an organization
        GroupModel group = session.groups()
            .searchForGroupByNameStream(realm, resourceId, true, 0, 1)
            .findFirst()
            .orElse(null);

        if (group == null) {
            throw new NotFoundException("Organization not found: " + resourceId);
        }

        String groupType = group.getFirstAttribute(GROUP_TYPE_ATTRIBUTE);
        if (!RESOURCE_TYPE_ORGANIZATION.equals(groupType)) {
            throw new IllegalArgumentException("Resource is not an organization: " + resourceId);
        }

        // Step 2: Disable the native Keycloak organization
        OrganizationProvider orgProvider = session.getProvider(OrganizationProvider.class);
        if (orgProvider == null) {
            throw new Exception("OrganizationProvider not available");
        }

        OrganizationModel org = orgProvider.getByAlias(resourceId);
        if (org == null) {
            throw new NotFoundException("Native organization not found: " + resourceId);
        }

        // Disable the organization
        org.setEnabled(false);

        // Step 3: Mark the group as disabled (add attribute)
        group.setSingleAttribute("disabled", "true");

        // Step 4: Update UMA resource with disabled attribute
        Resource resource = findResourceByName(realm, resourceId);
        if (resource != null) {
            resource.setAttribute("disabled", Collections.singletonList("true"));
        }

        log.infof("Disabled organization: alias=%s", resourceId);
    }

    /**
     * Enables a previously disabled organization.
     *
     * @param resourceId Organization alias (resource identifier)
     * @throws Exception if enabling fails
     */
    public void enableOrganization(String resourceId) throws Exception {
        RealmModel realm = session.getContext().getRealm();
        if (realm == null) {
            throw new Exception("Could not get realm from session context");
        }

        // Step 1: Find the group to verify it's an organization
        GroupModel group = session.groups()
            .searchForGroupByNameStream(realm, resourceId, true, 0, 1)
            .findFirst()
            .orElse(null);

        if (group == null) {
            throw new NotFoundException("Organization not found: " + resourceId);
        }

        String groupType = group.getFirstAttribute(GROUP_TYPE_ATTRIBUTE);
        if (!RESOURCE_TYPE_ORGANIZATION.equals(groupType)) {
            throw new IllegalArgumentException("Resource is not an organization: " + resourceId);
        }

        // Step 2: Enable the native Keycloak organization
        OrganizationProvider orgProvider = session.getProvider(OrganizationProvider.class);
        if (orgProvider == null) {
            throw new Exception("OrganizationProvider not available");
        }

        OrganizationModel org = orgProvider.getByAlias(resourceId);
        if (org == null) {
            throw new NotFoundException("Native organization not found: " + resourceId);
        }

        // Enable the organization
        org.setEnabled(true);

        // Step 3: Remove disabled attribute from group
        group.removeAttribute("disabled");

        // Step 4: Remove disabled attribute from UMA resource
        Resource resource = findResourceByName(realm, resourceId);
        if (resource != null) {
            resource.removeAttribute("disabled");
        }

        log.infof("Enabled organization: alias=%s", resourceId);
    }

    // ============================================================================
    // Validation Methods
    // ============================================================================

    /**
     * Validates organization alias format.
     * - Must be 3-50 characters long
     * - Lowercase alphanumeric with hyphens
     * - Cannot start or end with hyphen
     * - Cannot have consecutive hyphens
     *
     * @param alias The alias to validate
     * @throws IllegalArgumentException if the alias is invalid
     */
    private void validateOrganizationAlias(String alias) {
        if (alias == null || alias.isEmpty()) {
            throw new IllegalArgumentException("Organization alias cannot be empty");
        }

        int length = alias.length();
        if (length < 3) {
            throw new IllegalArgumentException("Organization alias must be at least 3 characters");
        }
        if (length > 50) {
            throw new IllegalArgumentException("Organization alias must be 50 characters or less");
        }

        // Check first character (must be alphanumeric)
        char first = alias.charAt(0);
        if (!((first >= 'a' && first <= 'z') || (first >= '0' && first <= '9'))) {
            throw new IllegalArgumentException("Organization alias must start with a lowercase letter or number");
        }

        // Check last character (must be alphanumeric)
        char last = alias.charAt(length - 1);
        if (!((last >= 'a' && last <= 'z') || (last >= '0' && last <= '9'))) {
            throw new IllegalArgumentException("Organization alias must end with a lowercase letter or number");
        }

        // Check all characters and consecutive hyphens
        boolean prevHyphen = false;
        for (int i = 0; i < length; i++) {
            char c = alias.charAt(i);
            boolean isAlphanumeric = (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');
            boolean isHyphen = c == '-';

            if (!isAlphanumeric && !isHyphen) {
                throw new IllegalArgumentException("Organization alias must be lowercase alphanumeric with hyphens only");
            }

            if (isHyphen && prevHyphen) {
                throw new IllegalArgumentException("Organization alias cannot contain consecutive hyphens");
            }

            prevHyphen = isHyphen;
        }

        log.debugf("Organization alias validated: %s", alias);
    }

    // ============================================================================
    // Native Keycloak Organization Methods
    // ============================================================================

    /**
     * Creates a native Keycloak organization with a specific alias.
     * The alias is immutable and becomes our stable identifier for the organization resource.
     *
     * @param name Organization display name
     * @param alias Organization alias (human-readable URL-friendly identifier)
     * @return The created OrganizationModel
     * @throws Exception if OrganizationProvider is not available or creation fails
     */
    private OrganizationModel createNativeOrganizationWithAlias(String name, String alias) throws Exception {
        OrganizationProvider orgProvider = session.getProvider(OrganizationProvider.class);
        if (orgProvider == null) {
            throw new Exception("OrganizationProvider not available - Organizations feature may not be enabled");
        }

        OrganizationModel org = orgProvider.create(name, alias);
        if (org == null) {
            throw new Exception("Failed to create native organization with alias: " + alias);
        }

        // Set organization_title attribute for JWT token mappers
        Map<String, List<String>> attrs = new HashMap<>();
        attrs.put("organization_title", Collections.singletonList(name));
        org.setAttributes(attrs);

        log.infof("Created native Keycloak organization: name=%s, alias=%s, id=%s", name, alias, org.getId());
        return org;
    }

    /**
     * Updates a native Keycloak organization name.
     * Best-effort operation - logs warnings on failure but doesn't throw exceptions.
     *
     * @param alias Organization alias (unique identifier)
     * @param newName New organization display name
     */
    private void updateNativeOrganizationName(String alias, String newName) {
        OrganizationProvider orgProvider = session.getProvider(OrganizationProvider.class);
        if (orgProvider == null) {
            log.warnf("OrganizationProvider not available, skipping organization name update for: %s", alias);
            return;
        }

        OrganizationModel org = orgProvider.getByAlias(alias);
        if (org == null) {
            log.warnf("Native organization not found by alias: %s", alias);
            return;
        }

        org.setName(newName);
        // Also update the organization_title attribute
        Map<String, List<String>> attrs = org.getAttributes();
        if (attrs == null) {
            attrs = new HashMap<>();
        } else {
            attrs = new HashMap<>(attrs); // Make mutable copy
        }
        attrs.put("organization_title", Collections.singletonList(newName));
        org.setAttributes(attrs);
        log.infof("Updated native organization name: alias=%s, newName=%s", alias, newName);
    }

    /**
     * Deletes a native Keycloak organization by its alias.
     * Best-effort operation - logs warnings on failure but doesn't throw exceptions.
     *
     * @param alias Organization alias (unique identifier)
     */
    private void deleteNativeOrganizationByAlias(String alias) {
        OrganizationProvider orgProvider = session.getProvider(OrganizationProvider.class);
        if (orgProvider == null) {
            log.warnf("OrganizationProvider not available, skipping organization deletion for alias: %s", alias);
            return;
        }

        OrganizationModel org = orgProvider.getByAlias(alias);
        if (org == null) {
            log.warnf("Native organization not found by alias: %s", alias);
            return;
        }

        boolean removed = orgProvider.remove(org);
        if (removed) {
            log.infof("Deleted native organization by alias: %s", alias);
        } else {
            log.warnf("Failed to delete native organization by alias: %s", alias);
        }
    }

    /**
     * Creates a UMA resource with a specific ID (used for organization resources).
     *
     * @param realm The realm
     * @param resourceId The resource ID to use
     * @param request The resource creation request (for scopes, attributes, etc.)
     * @param parentGroup Parent group if nested (null for organizations)
     * @return The created UMA Resource
     * @throws Exception if creation fails
     */
    private Resource createUMAResourceWithId(RealmModel realm, String resourceId, ResourceCreateRequest request, GroupModel parentGroup) throws Exception {
        ClientModel client = realm.getClientByClientId(VOLATICLOUD_CLIENT);
        if (client == null) {
            throw new Exception("Client '" + VOLATICLOUD_CLIENT + "' not found");
        }

        AuthorizationProvider authz = session.getProvider(AuthorizationProvider.class);
        ResourceServer resourceServer = authz.getStoreFactory().getResourceServerStore().findByClient(client);
        if (resourceServer == null) {
            throw new Exception("Resource server not found for client '" + VOLATICLOUD_CLIENT + "'");
        }

        ResourceStore resourceStore = authz.getStoreFactory().getResourceStore();
        ScopeStore scopeStore = authz.getStoreFactory().getScopeStore();

        // Get or create scopes
        Set<Scope> scopes = new HashSet<>();
        if (request.getScopes() != null) {
            for (String scopeName : request.getScopes()) {
                Scope scope = scopeStore.findByName(resourceServer, scopeName);
                if (scope == null) {
                    scope = scopeStore.create(resourceServer, scopeName);
                    log.infof("Created scope: %s", scopeName);
                }
                scopes.add(scope);
            }
        }

        // Create resource with the specified ID
        Resource resource = resourceStore.create(resourceServer, resourceId, resourceServer.getClientId());

        // Set resource type
        resource.setType(RESOURCE_TYPE_TENANT);

        // Set scopes
        resource.updateScopes(scopes);

        // Set attributes from request
        if (request.getAttributes() != null) {
            for (Map.Entry<String, List<String>> entry : request.getAttributes().entrySet()) {
                resource.setAttribute(entry.getKey(), entry.getValue());
            }
        }

        // Set ownerId if parent exists
        if (parentGroup != null) {
            resource.setAttribute("ownerId", Collections.singletonList(parentGroup.getName()));
        }

        // Set type attribute
        resource.setAttribute("type", Collections.singletonList(request.getType()));

        // Set title attribute
        resource.setAttribute("title", Collections.singletonList(request.getTitle()));

        // Set display name (this is what shows in Keycloak UI)
        resource.setDisplayName(request.getTitle());

        log.infof("Created UMA resource with ID: %s, type=%s, title=%s", resourceId, request.getType(), request.getTitle());

        return resource;
    }

    /**
     * Cleanup helper for failed resource creation.
     * Deletes both UMA resource and Keycloak group.
     *
     * @param realm The realm
     * @param resource The UMA resource to delete
     * @param group The Keycloak group to delete
     */
    private void cleanupOnFailure(RealmModel realm, Resource resource, GroupModel group) {
        // Delete UMA resource
        try {
            AuthorizationProvider authz = session.getProvider(AuthorizationProvider.class);
            ResourceStore resourceStore = authz.getStoreFactory().getResourceStore();
            resourceStore.delete(resource.getId());
            log.infof("Cleanup: deleted UMA resource %s", resource.getName());
        } catch (Exception e) {
            log.errorf(e, "Failed to cleanup UMA resource: %s", resource.getName());
        }

        // Delete group
        try {
            session.groups().removeGroup(realm, group);
            log.infof("Cleanup: deleted group %s", group.getName());
        } catch (Exception e) {
            log.errorf(e, "Failed to cleanup group: %s", group.getName());
        }
    }
}