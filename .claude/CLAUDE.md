# AnyTrade Project Notes

## Project Structure

Project follows Go best practices with `internal` directory pattern:
- `internal/ent/` - ENT ORM schemas and generated code
- `internal/graph/` - GraphQL schemas and resolvers
- `cmd/server/` - Server entrypoint
- `internal/enum/` - Custom enum types with GraphQL marshalers

All imports use `anytrade/internal/ent` and `anytrade/internal/graph`.

## GraphQL Implementation

Successfully integrated ENT ORM with GraphQL using gqlgen.

### Key Configuration

1. **ENT GraphQL Extension** (`internal/ent/entc.go`):
   - Uses `entgql.NewExtension()` with schema generator
   - Generates schema to `../graph/ent.graphql`
   - Integrates with gqlgen via `../../gqlgen.yml`

2. **gqlgen Configuration** (`gqlgen.yml`):
   - Schema files: `internal/graph/schema.graphqls` (custom scalars) and `internal/graph/ent.graphql` (generated)
   - Time scalar mapped to `github.com/99designs/gqlgen/graphql.Time` (NOT `time.Time`)
   - Autobind all ENT packages for automatic type mapping
   - Node interface mapped to `anytrade/internal/ent.Noder`

3. **Build Process**:
   ```bash
   make generate  # Runs ENT generation + gqlgen generation
   make build     # Builds the binary
   ```

### GraphQL API Endpoints

Server runs on port 8080 by default:
- GraphQL Playground: `http://localhost:8080/`
- GraphQL API: `http://localhost:8080/query`
- Health Check: `http://localhost:8080/health`

### Available Queries

- `exchanges` - List all exchanges
- `bots` - List all trading bots
- `strategies` - List all strategies
- `backtests` - List all backtests
- `trades` - List all trades
- `node(id: ID!)` - Fetch single node by ID
- `nodes(ids: [ID!]!)` - Fetch multiple nodes by IDs

All list queries support Relay-style pagination with `first`, `last`, `after`, `before` arguments.

### Available Mutations

All entities support full CRUD operations:

**Exchange:**
- `createExchange(input: CreateExchangeInput!)` - Create new exchange with typed config
- `updateExchange(id: ID!, input: UpdateExchangeInput!)` - Update exchange
- `deleteExchange(id: ID!)` - Delete exchange

Exchange configs are stored directly in the Exchange entity using typed configs via gqlgen autobind (see internal/exchange/config.go)

**Strategy:**
- `createStrategy(input: CreateStrategyInput!)` - Create trading strategy
- `updateStrategy(id: ID!, input: UpdateStrategyInput!)` - Update strategy
- `deleteStrategy(id: ID!)` - Delete strategy

**Bot:**
- `createBot(input: CreateBotInput!)` - Create trading bot
- `updateBot(id: ID!, input: UpdateBotInput!)` - Update bot
- `deleteBot(id: ID!)` - Delete bot

**Backtest:**
- `createBacktest(input: CreateBacktestInput!)` - Create backtest task
- `updateBacktest(id: ID!, input: UpdateBacktestInput!)` - Update backtest
- `deleteBacktest(id: ID!)` - Delete backtest

**Trade:**
- `createTrade(input: CreateTradeInput!)` - Create trade record
- `updateTrade(id: ID!, input: UpdateTradeInput!)` - Update trade
- `deleteTrade(id: ID!)` - Delete trade

### Typed Config Pattern (Exchange & Runner)

For entities that need dynamic, type-safe configuration (like Exchange and BotRunner), we use the gqlgen autobind pattern:

1. **Define Go structs** in a dedicated package (e.g., `internal/exchange/config.go`):
   ```go
   type BinanceConfigInput struct {
       APIKey    string `json:"api_key"`
       APISecret string `json:"api_secret"`
   }

   type ExchangeConfigInput struct {
       Binance   *BinanceConfigInput `json:"binance,omitempty"`
       Coinbase  *PassphraseExchangeConfigInput `json:"coinbase,omitempty"`
       // ... other exchanges
   }
   ```

2. **Add to gqlgen autobind** in `gqlgen.yml`:
   ```yaml
   autobind:
     - anytrade/internal/exchange
   ```

3. **Define matching GraphQL types** in `schema.graphqls`:
   ```graphql
   input BinanceConfigInput {
     apiKey: String!
     apiSecret: String!
   }

   input ExchangeConfigInput {
     binance: BinanceConfigInput
     coinbase: PassphraseExchangeConfigInput
     # ... other exchanges
   }
   ```

4. **Use in ENT schema** with custom type annotation:
   ```go
   field.JSON("config", map[string]interface{}{}).
       Optional().
       Annotations(
           entgql.Type("ExchangeConfigInput"),
           entgql.Skip(entgql.SkipType),
       )
   ```

5. **Create conversion helper** (e.g., `internal/graph/exchange_config.go`) to convert typed input to map for storage

6. **Implement config resolvers** in `ent.resolvers.go` to handle CreateInput and UpdateInput config fields

This pattern provides:
- Type-safe configs in both backend and frontend
- Dynamic forms in the UI based on selected type
- Validation at compile time
- No manual GraphQL type writing needed

### Important Notes

- JSON fields in ENT schemas require `entgql.Skip()` annotations with custom type
- All ENT enum types need GraphQL marshaling methods (`MarshalGQL`/`UnmarshalGQL`)
- GraphQL resolvers are mostly auto-generated by ENT - minimal manual implementation needed
- Config resolvers must be manually implemented to convert typed inputs to maps
- Database defaults to SQLite at `./data/anytrade.db`

## Testing

The project has comprehensive test coverage for GraphQL resolvers.

### Running Tests

```bash
make test         # Run all tests with coverage report
make coverage     # Run tests and open HTML coverage report in browser
```

### Test Structure

- `internal/graph/*_test.go` - GraphQL resolver tests for each entity
- `internal/graph/resolver_test.go` - Test infrastructure setup
- `internal/graph/test_helpers.go` - Helper functions for tests

### Test Coverage

**Real Test Coverage: 91.9%** (excluding all generated code and schema definitions)

Current GraphQL resolver coverage:
- Query resolvers: 100% (6/8 tested - Node/Nodes intentionally excluded)
- Mutation resolvers: 97% (17/18 at 100% - CreateBacktest uses ENT client directly)

Coverage reports are generated automatically:
- `coverage.out` - Raw coverage data (includes all code)
- `coverage.filtered.out` - Filtered coverage (excludes generated code)
- `coverage.html` - Interactive HTML report (based on filtered data)

The test command automatically filters out:
- All ENT-generated entity files
- All CRUD operation files (*_create.go, *_update.go, *_delete.go, *_query.go)
- GraphQL generated code (generated.go)
- ENT schema definitions (schema/*.go)
- Enum marshaling code
- Server main.go

This gives you accurate coverage metrics for your actual business logic and resolvers.

### Writing Tests

Use the test infrastructure in `resolver_test.go`:
```go
func TestMyEntity(t *testing.T) {
    resolver := setupTestResolver(t)
    mutationResolver := resolver.Mutation()
    queryResolver := resolver.Query()

    // Use ptr() helper for pointer fields
    // Use ctx() helper for context
}
```

### Troubleshooting

If generation fails:
1. Ensure all JSON fields have `entgql.Skip()` annotations
2. Check that enum types implement GraphQL marshalers
3. Verify `graph/model/models.go` placeholder exists
4. Confirm Time scalar uses `github.com/99designs/gqlgen/graphql.Time`

## React Dashboard

A modern React dashboard is available in the `dashboard/` directory.

### Tech Stack
- React 19 + TypeScript
- Vite for fast development
- Material-UI (MUI) v7 for UI components
- Apollo Client for GraphQL integration
- GraphQL Code Generator for type-safe queries
- React Router v7 for navigation

### Getting Started

```bash
cd dashboard
npm install
npm run codegen  # Generate GraphQL types
npm run dev      # Start development server
```

Dashboard runs on http://localhost:5173

### Architecture

**Centralized Code Generation:**
All GraphQL operations are generated into a single centralized file:
- GraphQL files: `src/components/*/[feature].graphql` (e.g., `bots.graphql`, `backtests.graphql`)
- Generated hooks: `src/generated/graphql.ts` (centralized)
- Codegen config: `codegen.ts` uses **schema introspection** from `http://localhost:8080/query`

**Important**: The codegen fetches the schema from the running GraphQL server via introspection, NOT from the `internal/graph/ent.graphql` file. This means:
1. The backend server MUST be running on port 8080 before running `npm run codegen`
2. After regenerating backend schema with `make generate`, you MUST rebuild and restart the server
3. Then run `npm run codegen` to fetch the updated schema via introspection

**Workflow after schema changes:**
```bash
# Backend changes
make generate  # Regenerate ENT schema
make build     # Rebuild binary
./bin/anytrade server &  # Restart server

# Frontend codegen (requires server running)
cd dashboard
npm run codegen  # Fetches schema from http://localhost:8080/query
```

**Usage Example:**
```typescript
// Import from centralized generated file
import { useGetBotsQuery, useStartBotMutation } from '../../generated/graphql';

const { data, loading } = useGetBotsQuery({ variables: { first: 10 } });
const [startBot] = useStartBotMutation();
```

All GraphQL operation files use the `.graphql` extension. The generated file `src/generated/graphql.ts` is git-ignored.

### Key Features
- Dark/Light mode toggle
- Responsive Material-UI layout
- Type-safe GraphQL queries with generated React hooks
- Sidebar navigation
- Component-based architecture

See `dashboard/README.md` for detailed documentation.

## Bot Runtime and Freqtrade Configuration

### Bot Lifecycle

Bots run in Docker containers with Freqtrade. The lifecycle is:

1. **Create Bot** - Creates container and generates config files in `/tmp/anytrade-configs/{botID}/`
2. **Start Bot** - Starts the container (reuses existing config files)
3. **Stop Bot** - Stops the container (keeps config files)
4. **Delete Bot** - Removes container and cleans up config files

**Important**: Config files are generated during bot creation, not on start. To apply config changes, you must delete and recreate the bot.

### Config File Generation

The system generates three layered config files for each bot:

1. `config.exchange.json` - Exchange credentials and pair whitelist
2. `config.strategy.json` - Strategy-specific settings (optional)
3. `config.bot.json` - Bot-specific overrides (with dry_run field auto-injected)

Config files are automatically mounted as read-only volumes into the Freqtrade container.

### Automatic dry_run Field Injection

**Fixed in helpers.go** - The `buildBotSpec` function automatically adds the `dry_run` field based on bot mode:

```go
// Prepare bot config and ensure dry_run field is set
botConfig := b.Config
if botConfig == nil {
    botConfig = make(map[string]interface{})
}

// Add dry_run field based on bot mode
botConfig["dry_run"] = (b.Mode == enum.BotModeDryRun)
```

This ensures Freqtrade always receives the required `dry_run` field.

### Bot Config Validation

**Implemented in helpers.go** - The `validateFreqtradeConfig` function validates bot configurations before creation or update:

```go
// Required fields:
- stake_currency (string)
- stake_amount (number)
- exit_pricing (object with price_side, use_order_book, order_book_top)
- entry_pricing (object with price_side, use_order_book, order_book_top)
```

Validation runs on:
- `createBot` mutation - Validates before database save
- `updateBot` mutation - Validates config changes

**Error Handling:**
- GraphQL errors are returned with descriptive messages
- Apollo Client automatically provides errors to dashboard via `error.message`
- No additional dashboard code needed for error display

**Example Complete Bot Config:**
```json
{
  "stake_currency": "USDT",
  "stake_amount": 10,
  "dry_run_wallet": 1000,
  "timeframe": "5m",
  "max_open_trades": 3,
  "unfilledtimeout": { "entry": 10, "exit": 30 },
  "exit_pricing": {
    "price_side": "other",
    "use_order_book": true,
    "order_book_top": 1,
    "price_last_balance": 0.0
  },
  "entry_pricing": {
    "price_side": "other",
    "use_order_book": true,
    "order_book_top": 1,
    "price_last_balance": 0.0,
    "check_depth_of_market": { "enabled": false, "bids_to_ask_delta": 1 }
  },
  "order_types": {
    "entry": "limit",
    "exit": "limit",
    "stoploss": "market",
    "stoploss_on_exchange": false,
    "stoploss_on_exchange_interval": 60
  },
  "order_time_in_force": { "entry": "GTC", "exit": "GTC" },
  "pairlists": [{ "method": "StaticPairList" }],
  "exchange": {
    "pair_whitelist": ["BTC/USDT", "ETH/USDT", "BNB/USDT"]
  }
}
```

### Testing Bot Flow

Test commands saved in /tmp/:
- `create_simple_strategy.graphql` - Creates SimpleTestStrategy
- `create_valid_bot.graphql` - Creates bot with required fields only
- `create_complete_bot.graphql` - Creates bot with all Freqtrade fields
- `start_working_bot.graphql` - Starts bot by ID

Always ensure:
1. Exchange has valid credentials in config
2. Strategy name matches the Python class name
3. Bot mode is set correctly (dry_run or live)
4. Bot config includes all required Freqtrade fields (validated automatically)

---

## Testing & Code Quality

### Running Tests

```bash
# Run all tests with coverage
make test

# Run specific test file
go test -v ./internal/graph -run TestValidateFreqtradeConfig

# Run with coverage for specific package
go test -v ./internal/graph -cover -coverprofile=coverage.out

# View coverage details
go tool cover -func=coverage.out

# Generate HTML coverage report
go tool cover -html=coverage.out -o coverage.html
```

### Test Coverage

**Validation Functions (`internal/graph/helpers.go`):** 100%
- ✅ `validateFreqtradeConfig` - 17 test cases
- ✅ `extractExchangeCredentials` - 12 test cases
- ✅ `buildBotSpec` - 6 test cases

**Test File:** `internal/graph/helpers_test.go`

**Key Test Categories:**
1. **Missing Required Fields** - Validates all required field checks
2. **Invalid Types** - Ensures type validation works (string/number/object)
3. **Nested Object Validation** - Validates exit_pricing and entry_pricing structures
4. **Config Mutation** - Regression test for map mutation bug
5. **Edge Cases** - Nil configs, empty strings, invalid credentials

### Known Issues (See TODO.md for complete list)

**Critical (Fixed):**
- ✅ Config mutation bug in `buildBotSpec` - FIXED (2025-10-23)

**Pending:**
- ⏳ Range validation for numeric fields (stake_amount > 0)
- ⏳ Enhanced credential validation (detect placeholders)
- ⏳ Container cleanup on DB failures
- ⏳ Prevent config updates on running bots

See `/TODO.md` for complete issue tracking and sprint planning.

### Code Analysis

**Full Analysis Report:** `/tmp/code_analysis_report.md`

**Summary of Issues:**
- Total Issues: 19
- Critical: 3 (1 fixed, 2 pending)
- High: 2
- Medium: 7
- Low: 7

**Running Code Analysis:**
```bash
# View comprehensive analysis
cat /tmp/code_analysis_report.md

# View TODO list
cat TODO.md
```

### Writing New Tests

When adding new validation or helper functions, follow the test pattern in `helpers_test.go`:

```go
func TestYourFunction(t *testing.T) {
    tests := []struct {
        name    string
        input   YourInputType
        wantErr bool
        errMsg  string
    }{
        {
            name:    "descriptive test case name",
            input:   ...,
            wantErr: true,
            errMsg:  "expected error substring",
        },
        // More test cases...
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := YourFunction(tt.input)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
            } else {
                assert.NoError(t, err)
                // Assert on result...
            }
        })
    }
}
```

### Continuous Integration

Before committing:
1. Run `make test` - Ensure all tests pass
2. Run `make coverage` - Check coverage hasn't decreased
3. Review TODO.md - Update any completed tasks
4. Run linters if configured

### Best Practices

1. **100% Coverage Goal** - Aim for 100% coverage on business logic
2. **Table-Driven Tests** - Use test tables for multiple scenarios
3. **Regression Tests** - Add tests for every bug fix
4. **Error Path Testing** - Test all error conditions
5. **Edge Case Coverage** - Test nil, empty, boundary values
## JSON Schema Validation

**Updated: 2025-10-24** - Implemented automatic JSON schema validation using the official Freqtrade schema.

### Implementation

All bot and backtest configs are now validated against the official Freqtrade JSON schema from `https://schema.freqtrade.io/schema.json`.

**Files:**
- `internal/graph/schema_validator.go` - Schema validation helper
- Uses `github.com/xeipuuv/gojsonschema` library

**Validation happens:**
- `createBot` mutation - Validates before database save
- `updateBot` mutation - Validates config changes

**Benefits:**
1. Automatic validation against official Freqtrade requirements
2. Schema is fetched once and cached
3. Clear, descriptive error messages from the schema
4. No manual validation code to maintain

**Note:** The schema validates the complete Freqtrade config. Since we store configs separately (Exchange, Strategy, Bot), you may need to include required fields or adjust validation logic for partial configs.

### Next Steps

Consider implementing:
1. Partial schema validation (only validate bot-specific fields)
2. Schema merging (merge Exchange/Strategy/Bot configs before validation)
3. Custom schema for our architecture

