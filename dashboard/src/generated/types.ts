export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: { input: string; output: string; }
  Map: { input: Record<string, any>; output: Record<string, any>; }
  Time: { input: string; output: string; }
};

export type Backtest = Node & {
  __typename?: 'Backtest';
  /** Completion timestamp */
  completedAt?: Maybe<Scalars['Time']['output']>;
  /** Docker container ID for running backtest */
  containerID?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Backtest end date (end of time range) */
  endDate?: Maybe<Scalars['Time']['output']>;
  /** Error message if backtest failed */
  errorMessage?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Container logs from backtest execution */
  logs?: Maybe<Scalars['String']['output']>;
  /** Backtest result data (metrics, logs, trades, etc.) */
  result?: Maybe<Scalars['Map']['output']>;
  runner: BotRunner;
  /** Foreign key to runner */
  runnerID: Scalars['ID']['output'];
  /** Backtest start date (beginning of time range) */
  startDate?: Maybe<Scalars['Time']['output']>;
  /** Task status */
  status: BacktestTaskStatus;
  strategy: Strategy;
  /** Foreign key to strategy */
  strategyID: Scalars['ID']['output'];
  /** Typed summary of key backtest metrics extracted from result */
  summary?: Maybe<BacktestSummary>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type BacktestConnection = {
  __typename?: 'BacktestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BacktestEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BacktestEdge = {
  __typename?: 'BacktestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Backtest>;
};

export type BacktestSummary = {
  __typename?: 'BacktestSummary';
  avgStakeAmount?: Maybe<Scalars['Float']['output']>;
  backtestDays?: Maybe<Scalars['Int']['output']>;
  backtestEnd?: Maybe<Scalars['Time']['output']>;
  backtestStart?: Maybe<Scalars['Time']['output']>;
  calmar?: Maybe<Scalars['Float']['output']>;
  expectancy?: Maybe<Scalars['Float']['output']>;
  losses: Scalars['Int']['output'];
  maxDrawdown?: Maybe<Scalars['Float']['output']>;
  profitFactor?: Maybe<Scalars['Float']['output']>;
  profitMean?: Maybe<Scalars['Float']['output']>;
  profitTotal: Scalars['Float']['output'];
  profitTotalAbs: Scalars['Float']['output'];
  sharpe?: Maybe<Scalars['Float']['output']>;
  sortino?: Maybe<Scalars['Float']['output']>;
  stakeCurrency: Scalars['String']['output'];
  strategyName: Scalars['String']['output'];
  totalTrades: Scalars['Int']['output'];
  winRate?: Maybe<Scalars['Float']['output']>;
  wins: Scalars['Int']['output'];
};

/** BacktestTaskStatus is enum for the field status */
export enum BacktestTaskStatus {
  Completed = 'completed',
  Failed = 'failed',
  Pending = 'pending',
  Running = 'running'
}

/**
 * BacktestWhereInput is used for filtering Backtest objects.
 * Input was generated by ent.
 */
export type BacktestWhereInput = {
  and?: InputMaybe<Array<BacktestWhereInput>>;
  /** completed_at field predicates */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  completedAtGT?: InputMaybe<Scalars['Time']['input']>;
  completedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  completedAtLT?: InputMaybe<Scalars['Time']['input']>;
  completedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  completedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** container_id field predicates */
  containerID?: InputMaybe<Scalars['String']['input']>;
  containerIDContains?: InputMaybe<Scalars['String']['input']>;
  containerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  containerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  containerIDGT?: InputMaybe<Scalars['String']['input']>;
  containerIDGTE?: InputMaybe<Scalars['String']['input']>;
  containerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  containerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  containerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  containerIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  containerIDLT?: InputMaybe<Scalars['String']['input']>;
  containerIDLTE?: InputMaybe<Scalars['String']['input']>;
  containerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  containerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  containerIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** end_date field predicates */
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endDateGT?: InputMaybe<Scalars['Time']['input']>;
  endDateGTE?: InputMaybe<Scalars['Time']['input']>;
  endDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  endDateLT?: InputMaybe<Scalars['Time']['input']>;
  endDateLTE?: InputMaybe<Scalars['Time']['input']>;
  endDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  endDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** error_message field predicates */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  errorMessageContains?: InputMaybe<Scalars['String']['input']>;
  errorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageGT?: InputMaybe<Scalars['String']['input']>;
  errorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  errorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  errorMessageLT?: InputMaybe<Scalars['String']['input']>;
  errorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  errorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** runner edge predicates */
  hasRunner?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunnerWith?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** strategy edge predicates */
  hasStrategy?: InputMaybe<Scalars['Boolean']['input']>;
  hasStrategyWith?: InputMaybe<Array<StrategyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** logs field predicates */
  logs?: InputMaybe<Scalars['String']['input']>;
  logsContains?: InputMaybe<Scalars['String']['input']>;
  logsContainsFold?: InputMaybe<Scalars['String']['input']>;
  logsEqualFold?: InputMaybe<Scalars['String']['input']>;
  logsGT?: InputMaybe<Scalars['String']['input']>;
  logsGTE?: InputMaybe<Scalars['String']['input']>;
  logsHasPrefix?: InputMaybe<Scalars['String']['input']>;
  logsHasSuffix?: InputMaybe<Scalars['String']['input']>;
  logsIn?: InputMaybe<Array<Scalars['String']['input']>>;
  logsIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  logsLT?: InputMaybe<Scalars['String']['input']>;
  logsLTE?: InputMaybe<Scalars['String']['input']>;
  logsNEQ?: InputMaybe<Scalars['String']['input']>;
  logsNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  logsNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<BacktestWhereInput>;
  or?: InputMaybe<Array<BacktestWhereInput>>;
  /** runner_id field predicates */
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  runnerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  runnerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** start_date field predicates */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startDateGT?: InputMaybe<Scalars['Time']['input']>;
  startDateGTE?: InputMaybe<Scalars['Time']['input']>;
  startDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  startDateLT?: InputMaybe<Scalars['Time']['input']>;
  startDateLTE?: InputMaybe<Scalars['Time']['input']>;
  startDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  startDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<BacktestTaskStatus>;
  statusIn?: InputMaybe<Array<BacktestTaskStatus>>;
  statusNEQ?: InputMaybe<BacktestTaskStatus>;
  statusNotIn?: InputMaybe<Array<BacktestTaskStatus>>;
  /** strategy_id field predicates */
  strategyID?: InputMaybe<Scalars['ID']['input']>;
  strategyIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  strategyIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  strategyIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type BinanceConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

export type BitfinexConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

export type Bot = Node & {
  __typename?: 'Bot';
  /** Complete freqtrade bot configuration (stake, pairlists, pricing, api_server, etc.) */
  config?: Maybe<Scalars['Map']['output']>;
  /** Runner-specific identifier (container ID, pod name, etc.) */
  containerID?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Last error message if status is error */
  errorMessage?: Maybe<Scalars['String']['output']>;
  exchange: Exchange;
  /** Foreign key to exchange (provides credentials) */
  exchangeID: Scalars['ID']['output'];
  /** Freqtrade Docker image version tag */
  freqtradeVersion: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Last successful health check */
  lastSeenAt?: Maybe<Scalars['Time']['output']>;
  metrics?: Maybe<BotMetrics>;
  /** Trading mode (dry-run or live) */
  mode: BotBotMode;
  /** Bot display name */
  name: Scalars['String']['output'];
  runner: BotRunner;
  /** Foreign key to runner (provides execution environment) */
  runnerID: Scalars['ID']['output'];
  /** Bot lifecycle status */
  status: BotBotStatus;
  strategy: Strategy;
  /** Foreign key to strategy (provides code) */
  strategyID: Scalars['ID']['output'];
  trades: TradeConnection;
  updatedAt: Scalars['Time']['output'];
};


export type BotTradesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TradeWhereInput>;
};

/** BotBotMode is enum for the field mode */
export enum BotBotMode {
  DryRun = 'dry_run',
  Live = 'live'
}

/** BotBotStatus is enum for the field status */
export enum BotBotStatus {
  Backtesting = 'backtesting',
  Creating = 'creating',
  Error = 'error',
  Hyperopt = 'hyperopt',
  Running = 'running',
  Stopped = 'stopped',
  Unhealthy = 'unhealthy'
}

/** A connection to a list of items. */
export type BotConnection = {
  __typename?: 'BotConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BotEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BotEdge = {
  __typename?: 'BotEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Bot>;
};

export type BotMetrics = Node & {
  __typename?: 'BotMetrics';
  /** Best performing trading pair */
  bestPair?: Maybe<Scalars['String']['output']>;
  /** Best trade profit rate */
  bestRate?: Maybe<Scalars['Float']['output']>;
  bot: Bot;
  /** Foreign key to bot (one-to-one) */
  botID: Scalars['ID']['output'];
  /** Number of closed trades */
  closedTradeCount?: Maybe<Scalars['Int']['output']>;
  /** Average profit per trade */
  expectancy?: Maybe<Scalars['Float']['output']>;
  /** When these metrics were fetched from Freqtrade API */
  fetchedAt: Scalars['Time']['output'];
  /** Timestamp of first trade */
  firstTradeTimestamp?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** Timestamp of latest trade */
  latestTradeTimestamp?: Maybe<Scalars['Time']['output']>;
  /** Number of losing trades */
  losingTrades?: Maybe<Scalars['Int']['output']>;
  /** Maximum drawdown percentage */
  maxDrawdown?: Maybe<Scalars['Float']['output']>;
  /** Maximum drawdown absolute value */
  maxDrawdownAbs?: Maybe<Scalars['Float']['output']>;
  /** Current number of open trades */
  openTradeCount?: Maybe<Scalars['Int']['output']>;
  /** Total profit (closed + open) in coin */
  profitAllCoin?: Maybe<Scalars['Float']['output']>;
  /** Total profit (closed + open) percentage */
  profitAllPercent?: Maybe<Scalars['Float']['output']>;
  /** Total closed profit in coin */
  profitClosedCoin?: Maybe<Scalars['Float']['output']>;
  /** Total closed profit percentage */
  profitClosedPercent?: Maybe<Scalars['Float']['output']>;
  /** Ratio of gross profit to gross loss */
  profitFactor?: Maybe<Scalars['Float']['output']>;
  /** Total number of trades */
  tradeCount?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['Time']['output'];
  /** Number of winning trades */
  winningTrades?: Maybe<Scalars['Int']['output']>;
  /** Win rate percentage (0-100) */
  winrate?: Maybe<Scalars['Float']['output']>;
};

/**
 * BotMetricsWhereInput is used for filtering BotMetrics objects.
 * Input was generated by ent.
 */
export type BotMetricsWhereInput = {
  and?: InputMaybe<Array<BotMetricsWhereInput>>;
  /** best_pair field predicates */
  bestPair?: InputMaybe<Scalars['String']['input']>;
  bestPairContains?: InputMaybe<Scalars['String']['input']>;
  bestPairContainsFold?: InputMaybe<Scalars['String']['input']>;
  bestPairEqualFold?: InputMaybe<Scalars['String']['input']>;
  bestPairGT?: InputMaybe<Scalars['String']['input']>;
  bestPairGTE?: InputMaybe<Scalars['String']['input']>;
  bestPairHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bestPairHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bestPairIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bestPairIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bestPairLT?: InputMaybe<Scalars['String']['input']>;
  bestPairLTE?: InputMaybe<Scalars['String']['input']>;
  bestPairNEQ?: InputMaybe<Scalars['String']['input']>;
  bestPairNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bestPairNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** best_rate field predicates */
  bestRate?: InputMaybe<Scalars['Float']['input']>;
  bestRateGT?: InputMaybe<Scalars['Float']['input']>;
  bestRateGTE?: InputMaybe<Scalars['Float']['input']>;
  bestRateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestRateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bestRateLT?: InputMaybe<Scalars['Float']['input']>;
  bestRateLTE?: InputMaybe<Scalars['Float']['input']>;
  bestRateNEQ?: InputMaybe<Scalars['Float']['input']>;
  bestRateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestRateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** bot_id field predicates */
  botID?: InputMaybe<Scalars['ID']['input']>;
  botIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  botIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  botIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** closed_trade_count field predicates */
  closedTradeCount?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountGT?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountGTE?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  closedTradeCountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  closedTradeCountLT?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountLTE?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  closedTradeCountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** expectancy field predicates */
  expectancy?: InputMaybe<Scalars['Float']['input']>;
  expectancyGT?: InputMaybe<Scalars['Float']['input']>;
  expectancyGTE?: InputMaybe<Scalars['Float']['input']>;
  expectancyIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  expectancyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  expectancyLT?: InputMaybe<Scalars['Float']['input']>;
  expectancyLTE?: InputMaybe<Scalars['Float']['input']>;
  expectancyNEQ?: InputMaybe<Scalars['Float']['input']>;
  expectancyNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  expectancyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** fetched_at field predicates */
  fetchedAt?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtGT?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  fetchedAtLT?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** first_trade_timestamp field predicates */
  firstTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampGT?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampGTE?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  firstTradeTimestampIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  firstTradeTimestampLT?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampLTE?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampNEQ?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  firstTradeTimestampNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** bot edge predicates */
  hasBot?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** latest_trade_timestamp field predicates */
  latestTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampGT?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampGTE?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  latestTradeTimestampIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  latestTradeTimestampLT?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampLTE?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampNEQ?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  latestTradeTimestampNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** losing_trades field predicates */
  losingTrades?: InputMaybe<Scalars['Int']['input']>;
  losingTradesGT?: InputMaybe<Scalars['Int']['input']>;
  losingTradesGTE?: InputMaybe<Scalars['Int']['input']>;
  losingTradesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  losingTradesIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  losingTradesLT?: InputMaybe<Scalars['Int']['input']>;
  losingTradesLTE?: InputMaybe<Scalars['Int']['input']>;
  losingTradesNEQ?: InputMaybe<Scalars['Int']['input']>;
  losingTradesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  losingTradesNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** max_drawdown field predicates */
  maxDrawdown?: InputMaybe<Scalars['Float']['input']>;
  /** max_drawdown_abs field predicates */
  maxDrawdownAbs?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsGT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsGTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownAbsIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  maxDrawdownAbsLT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsLTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsNEQ?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownAbsNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  maxDrawdownGT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownGTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  maxDrawdownLT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownLTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownNEQ?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<BotMetricsWhereInput>;
  /** open_trade_count field predicates */
  openTradeCount?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountGT?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountGTE?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  openTradeCountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  openTradeCountLT?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountLTE?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  openTradeCountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<BotMetricsWhereInput>>;
  /** profit_all_coin field predicates */
  profitAllCoin?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinGT?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinGTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllCoinIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitAllCoinLT?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinLTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllCoinNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_all_percent field predicates */
  profitAllPercent?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentGT?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentGTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllPercentIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitAllPercentLT?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentLTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllPercentNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_closed_coin field predicates */
  profitClosedCoin?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinGT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinGTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedCoinIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitClosedCoinLT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinLTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedCoinNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_closed_percent field predicates */
  profitClosedPercent?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentGT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentGTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedPercentIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitClosedPercentLT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentLTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedPercentNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_factor field predicates */
  profitFactor?: InputMaybe<Scalars['Float']['input']>;
  profitFactorGT?: InputMaybe<Scalars['Float']['input']>;
  profitFactorGTE?: InputMaybe<Scalars['Float']['input']>;
  profitFactorIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitFactorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitFactorLT?: InputMaybe<Scalars['Float']['input']>;
  profitFactorLTE?: InputMaybe<Scalars['Float']['input']>;
  profitFactorNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitFactorNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitFactorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** trade_count field predicates */
  tradeCount?: InputMaybe<Scalars['Int']['input']>;
  tradeCountGT?: InputMaybe<Scalars['Int']['input']>;
  tradeCountGTE?: InputMaybe<Scalars['Int']['input']>;
  tradeCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  tradeCountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  tradeCountLT?: InputMaybe<Scalars['Int']['input']>;
  tradeCountLTE?: InputMaybe<Scalars['Int']['input']>;
  tradeCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  tradeCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  tradeCountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** winning_trades field predicates */
  winningTrades?: InputMaybe<Scalars['Int']['input']>;
  winningTradesGT?: InputMaybe<Scalars['Int']['input']>;
  winningTradesGTE?: InputMaybe<Scalars['Int']['input']>;
  winningTradesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  winningTradesIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  winningTradesLT?: InputMaybe<Scalars['Int']['input']>;
  winningTradesLTE?: InputMaybe<Scalars['Int']['input']>;
  winningTradesNEQ?: InputMaybe<Scalars['Int']['input']>;
  winningTradesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  winningTradesNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** winrate field predicates */
  winrate?: InputMaybe<Scalars['Float']['input']>;
  winrateGT?: InputMaybe<Scalars['Float']['input']>;
  winrateGTE?: InputMaybe<Scalars['Float']['input']>;
  winrateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  winrateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  winrateLT?: InputMaybe<Scalars['Float']['input']>;
  winrateLTE?: InputMaybe<Scalars['Float']['input']>;
  winrateNEQ?: InputMaybe<Scalars['Float']['input']>;
  winrateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  winrateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BotRunner = Node & {
  __typename?: 'BotRunner';
  backtests: BacktestConnection;
  bots: BotConnection;
  /** Runner connection configuration (host, port, credentials, etc.) */
  config?: Maybe<Scalars['Map']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Data download configuration: {exchanges: [{name, enabled, timeframes, pairs_pattern, days, trading_mode}]} */
  dataDownloadConfig?: Maybe<Scalars['Map']['output']>;
  /** Progress details: {pairs_completed, pairs_total, current_pair, percent_complete} */
  dataDownloadProgress?: Maybe<Scalars['Map']['output']>;
  /** Current data download status (idle, downloading, completed, failed) */
  dataDownloadStatus: BotRunnerDataDownloadStatus;
  /** Error message if data download failed */
  dataErrorMessage?: Maybe<Scalars['String']['output']>;
  /** Whether runner has downloaded historical data for backtesting */
  dataIsReady: Scalars['Boolean']['output'];
  /** When data was last refreshed */
  dataLastUpdated?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** Runner display name */
  name: Scalars['String']['output'];
  /** Runner environment type (docker, kubernetes, local) */
  type: BotRunnerRunnerType;
  updatedAt: Scalars['Time']['output'];
};


export type BotRunnerBacktestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BacktestWhereInput>;
};


export type BotRunnerBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};

/** A connection to a list of items. */
export type BotRunnerConnection = {
  __typename?: 'BotRunnerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BotRunnerEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** BotRunnerDataDownloadStatus is enum for the field data_download_status */
export enum BotRunnerDataDownloadStatus {
  Completed = 'completed',
  Downloading = 'downloading',
  Failed = 'failed',
  Idle = 'idle'
}

/** An edge in a connection. */
export type BotRunnerEdge = {
  __typename?: 'BotRunnerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BotRunner>;
};

/** BotRunnerRunnerType is enum for the field type */
export enum BotRunnerRunnerType {
  Docker = 'docker',
  Kubernetes = 'kubernetes',
  Local = 'local'
}

/**
 * BotRunnerWhereInput is used for filtering BotRunner objects.
 * Input was generated by ent.
 */
export type BotRunnerWhereInput = {
  and?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** data_download_status field predicates */
  dataDownloadStatus?: InputMaybe<BotRunnerDataDownloadStatus>;
  dataDownloadStatusIn?: InputMaybe<Array<BotRunnerDataDownloadStatus>>;
  dataDownloadStatusNEQ?: InputMaybe<BotRunnerDataDownloadStatus>;
  dataDownloadStatusNotIn?: InputMaybe<Array<BotRunnerDataDownloadStatus>>;
  /** data_error_message field predicates */
  dataErrorMessage?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageContains?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageGT?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dataErrorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dataErrorMessageLT?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dataErrorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** data_is_ready field predicates */
  dataIsReady?: InputMaybe<Scalars['Boolean']['input']>;
  dataIsReadyNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** data_last_updated field predicates */
  dataLastUpdated?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedGT?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedGTE?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dataLastUpdatedIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dataLastUpdatedLT?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedLTE?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedNEQ?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dataLastUpdatedNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** backtests edge predicates */
  hasBacktests?: InputMaybe<Scalars['Boolean']['input']>;
  hasBacktestsWith?: InputMaybe<Array<BacktestWhereInput>>;
  /** bots edge predicates */
  hasBots?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotsWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<BotRunnerWhereInput>;
  or?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<BotRunnerRunnerType>;
  typeIn?: InputMaybe<Array<BotRunnerRunnerType>>;
  typeNEQ?: InputMaybe<BotRunnerRunnerType>;
  typeNotIn?: InputMaybe<Array<BotRunnerRunnerType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type BotStatus = {
  __typename?: 'BotStatus';
  botID: Scalars['String']['output'];
  containerID: Scalars['String']['output'];
  cpuUsage: Scalars['Float']['output'];
  createdAt: Scalars['Time']['output'];
  errorMessage: Scalars['String']['output'];
  healthy: Scalars['Boolean']['output'];
  hostPort: Scalars['Int']['output'];
  ipAddress: Scalars['String']['output'];
  lastSeenAt?: Maybe<Scalars['Time']['output']>;
  memoryUsage: Scalars['Int']['output'];
  startedAt?: Maybe<Scalars['Time']['output']>;
  status: BotBotStatus;
  stoppedAt?: Maybe<Scalars['Time']['output']>;
};

/**
 * BotWhereInput is used for filtering Bot objects.
 * Input was generated by ent.
 */
export type BotWhereInput = {
  and?: InputMaybe<Array<BotWhereInput>>;
  /** container_id field predicates */
  containerID?: InputMaybe<Scalars['String']['input']>;
  containerIDContains?: InputMaybe<Scalars['String']['input']>;
  containerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  containerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  containerIDGT?: InputMaybe<Scalars['String']['input']>;
  containerIDGTE?: InputMaybe<Scalars['String']['input']>;
  containerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  containerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  containerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  containerIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  containerIDLT?: InputMaybe<Scalars['String']['input']>;
  containerIDLTE?: InputMaybe<Scalars['String']['input']>;
  containerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  containerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  containerIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** error_message field predicates */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  errorMessageContains?: InputMaybe<Scalars['String']['input']>;
  errorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageGT?: InputMaybe<Scalars['String']['input']>;
  errorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  errorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  errorMessageLT?: InputMaybe<Scalars['String']['input']>;
  errorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  errorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** exchange_id field predicates */
  exchangeID?: InputMaybe<Scalars['ID']['input']>;
  exchangeIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  exchangeIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  exchangeIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** freqtrade_version field predicates */
  freqtradeVersion?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionContains?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionContainsFold?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionEqualFold?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionGT?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionGTE?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  freqtradeVersionLT?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionLTE?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionNEQ?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** exchange edge predicates */
  hasExchange?: InputMaybe<Scalars['Boolean']['input']>;
  hasExchangeWith?: InputMaybe<Array<ExchangeWhereInput>>;
  /** metrics edge predicates */
  hasMetrics?: InputMaybe<Scalars['Boolean']['input']>;
  hasMetricsWith?: InputMaybe<Array<BotMetricsWhereInput>>;
  /** runner edge predicates */
  hasRunner?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunnerWith?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** strategy edge predicates */
  hasStrategy?: InputMaybe<Scalars['Boolean']['input']>;
  hasStrategyWith?: InputMaybe<Array<StrategyWhereInput>>;
  /** trades edge predicates */
  hasTrades?: InputMaybe<Scalars['Boolean']['input']>;
  hasTradesWith?: InputMaybe<Array<TradeWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_seen_at field predicates */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtGT?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtGTE?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSeenAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastSeenAtLT?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtLTE?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSeenAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** mode field predicates */
  mode?: InputMaybe<BotBotMode>;
  modeIn?: InputMaybe<Array<BotBotMode>>;
  modeNEQ?: InputMaybe<BotBotMode>;
  modeNotIn?: InputMaybe<Array<BotBotMode>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<BotWhereInput>;
  or?: InputMaybe<Array<BotWhereInput>>;
  /** runner_id field predicates */
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  runnerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  runnerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** status field predicates */
  status?: InputMaybe<BotBotStatus>;
  statusIn?: InputMaybe<Array<BotBotStatus>>;
  statusNEQ?: InputMaybe<BotBotStatus>;
  statusNotIn?: InputMaybe<Array<BotBotStatus>>;
  /** strategy_id field predicates */
  strategyID?: InputMaybe<Scalars['ID']['input']>;
  strategyIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  strategyIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  strategyIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type BybitConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

export type ConnectionTestResult = {
  __typename?: 'ConnectionTestResult';
  message: Scalars['String']['output'];
  success: Scalars['Boolean']['output'];
  version?: Maybe<Scalars['String']['output']>;
};

/**
 * CreateBacktestInput is used for create Backtest object.
 * Input was generated by ent.
 */
export type CreateBacktestInput = {
  /** Completion timestamp */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Docker container ID for running backtest */
  containerID?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Backtest end date (end of time range) */
  endDate?: InputMaybe<Scalars['Time']['input']>;
  /** Error message if backtest failed */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Container logs from backtest execution */
  logs?: InputMaybe<Scalars['String']['input']>;
  /** Backtest result data (metrics, logs, trades, etc.) */
  result?: InputMaybe<Scalars['Map']['input']>;
  runnerID: Scalars['ID']['input'];
  /** Backtest start date (beginning of time range) */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  /** Task status */
  status?: InputMaybe<BacktestTaskStatus>;
  strategyID: Scalars['ID']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBotInput is used for create Bot object.
 * Input was generated by ent.
 */
export type CreateBotInput = {
  /** Complete freqtrade bot configuration (stake, pairlists, pricing, api_server, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Runner-specific identifier (container ID, pod name, etc.) */
  containerID?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Last error message if status is error */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  exchangeID: Scalars['ID']['input'];
  /** Freqtrade Docker image version tag */
  freqtradeVersion?: InputMaybe<Scalars['String']['input']>;
  /** Last successful health check */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>;
  metricsID?: InputMaybe<Scalars['ID']['input']>;
  /** Trading mode (dry-run or live) */
  mode?: InputMaybe<BotBotMode>;
  /** Bot display name */
  name: Scalars['String']['input'];
  runnerID: Scalars['ID']['input'];
  /** Bot lifecycle status */
  status?: InputMaybe<BotBotStatus>;
  strategyID: Scalars['ID']['input'];
  tradeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBotMetricsInput is used for create BotMetrics object.
 * Input was generated by ent.
 */
export type CreateBotMetricsInput = {
  /** Best performing trading pair */
  bestPair?: InputMaybe<Scalars['String']['input']>;
  /** Best trade profit rate */
  bestRate?: InputMaybe<Scalars['Float']['input']>;
  botID: Scalars['ID']['input'];
  /** Number of closed trades */
  closedTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Average profit per trade */
  expectancy?: InputMaybe<Scalars['Float']['input']>;
  /** When these metrics were fetched from Freqtrade API */
  fetchedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of first trade */
  firstTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of latest trade */
  latestTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Number of losing trades */
  losingTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum drawdown percentage */
  maxDrawdown?: InputMaybe<Scalars['Float']['input']>;
  /** Maximum drawdown absolute value */
  maxDrawdownAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Current number of open trades */
  openTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Total profit (closed + open) in coin */
  profitAllCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total profit (closed + open) percentage */
  profitAllPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit in coin */
  profitClosedCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit percentage */
  profitClosedPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Ratio of gross profit to gross loss */
  profitFactor?: InputMaybe<Scalars['Float']['input']>;
  /** Total number of trades */
  tradeCount?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Number of winning trades */
  winningTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Win rate percentage (0-100) */
  winrate?: InputMaybe<Scalars['Float']['input']>;
};

/**
 * CreateBotRunnerInput is used for create BotRunner object.
 * Input was generated by ent.
 */
export type CreateBotRunnerInput = {
  backtestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  botIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Runner connection configuration (host, port, credentials, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Data download configuration: {exchanges: [{name, enabled, timeframes, pairs_pattern, days, trading_mode}]} */
  dataDownloadConfig?: InputMaybe<Scalars['Map']['input']>;
  /** Progress details: {pairs_completed, pairs_total, current_pair, percent_complete} */
  dataDownloadProgress?: InputMaybe<Scalars['Map']['input']>;
  /** Current data download status (idle, downloading, completed, failed) */
  dataDownloadStatus?: InputMaybe<BotRunnerDataDownloadStatus>;
  /** Error message if data download failed */
  dataErrorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Whether runner has downloaded historical data for backtesting */
  dataIsReady?: InputMaybe<Scalars['Boolean']['input']>;
  /** When data was last refreshed */
  dataLastUpdated?: InputMaybe<Scalars['Time']['input']>;
  /** Runner display name */
  name: Scalars['String']['input'];
  /** Runner environment type (docker, kubernetes, local) */
  type?: InputMaybe<BotRunnerRunnerType>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateExchangeInput is used for create Exchange object.
 * Input was generated by ent.
 */
export type CreateExchangeInput = {
  botIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Complete freqtrade exchange configuration (name, key, secret, pair_whitelist, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Exchange display name (e.g., 'Binance Production', 'Coinbase Testnet') */
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateStrategyInput is used for create Strategy object.
 * Input was generated by ent.
 */
export type CreateStrategyInput = {
  backtestID?: InputMaybe<Scalars['ID']['input']>;
  botIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  childIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Python strategy code */
  code: Scalars['String']['input'];
  /** Strategy-specific configuration (config.json) - REQUIRED */
  config: Scalars['Map']['input'];
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Strategy description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if this is the latest version of the strategy */
  isLatest?: InputMaybe<Scalars['Boolean']['input']>;
  /** Strategy name (not unique, allows versions) */
  name: Scalars['String']['input'];
  /** Group ID (organization) that owns this strategy */
  ownerID: Scalars['String']['input'];
  parentID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Auto-incremented version number */
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * CreateTradeInput is used for create Trade object.
 * Input was generated by ent.
 */
export type CreateTradeInput = {
  /** Amount of coins */
  amount: Scalars['Float']['input'];
  botID: Scalars['ID']['input'];
  /** Trade close time */
  closeDate?: InputMaybe<Scalars['Time']['input']>;
  /** Exit price */
  closeRate?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Original trade ID from freqtrade */
  freqtradeTradeID: Scalars['Int']['input'];
  /** Trade open status */
  isOpen?: InputMaybe<Scalars['Boolean']['input']>;
  /** Trade open time */
  openDate: Scalars['Time']['input'];
  /** Entry price */
  openRate: Scalars['Float']['input'];
  /** Trading pair (BTC/USDT) */
  pair: Scalars['String']['input'];
  /** Absolute profit */
  profitAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Profit percentage (0.05 = 5%) */
  profitRatio?: InputMaybe<Scalars['Float']['input']>;
  /** Reason for selling (roi, stoploss, etc.) */
  sellReason?: InputMaybe<Scalars['String']['input']>;
  /** Stake in base currency */
  stakeAmount: Scalars['Float']['input'];
  /** Strategy used */
  strategyName?: InputMaybe<Scalars['String']['input']>;
  /** Timeframe used */
  timeframe?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

export type DataDownloadConfigInput = {
  exchanges: Array<DataDownloadExchangeConfigInput>;
};

export type DataDownloadExchangeConfigInput = {
  days?: InputMaybe<Scalars['Int']['input']>;
  enabled: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  pairsPattern?: InputMaybe<Scalars['String']['input']>;
  timeframes?: InputMaybe<Array<Scalars['String']['input']>>;
  tradingMode?: InputMaybe<Scalars['String']['input']>;
};

export type DockerConfigInput = {
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  caPEM?: InputMaybe<Scalars['String']['input']>;
  certPEM?: InputMaybe<Scalars['String']['input']>;
  host: Scalars['String']['input'];
  keyPEM?: InputMaybe<Scalars['String']['input']>;
  network?: InputMaybe<Scalars['String']['input']>;
  registryAuth?: InputMaybe<RegistryAuthInput>;
  tlsVerify?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Exchange = Node & {
  __typename?: 'Exchange';
  bots: BotConnection;
  /** Complete freqtrade exchange configuration (name, key, secret, pair_whitelist, etc.) */
  config?: Maybe<Scalars['Map']['output']>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  /** Exchange display name (e.g., 'Binance Production', 'Coinbase Testnet') */
  name: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};


export type ExchangeBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};

export type ExchangeConfigInput = {
  binance?: InputMaybe<BinanceConfigInput>;
  binanceus?: InputMaybe<BinanceConfigInput>;
  bitfinex?: InputMaybe<BitfinexConfigInput>;
  bybit?: InputMaybe<BybitConfigInput>;
  coinbase?: InputMaybe<PassphraseExchangeConfigInput>;
  kraken?: InputMaybe<KrakenConfigInput>;
  kucoin?: InputMaybe<PassphraseExchangeConfigInput>;
  okx?: InputMaybe<PassphraseExchangeConfigInput>;
};

/**
 * ExchangeWhereInput is used for filtering Exchange objects.
 * Input was generated by ent.
 */
export type ExchangeWhereInput = {
  and?: InputMaybe<Array<ExchangeWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** bots edge predicates */
  hasBots?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotsWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ExchangeWhereInput>;
  or?: InputMaybe<Array<ExchangeWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type KrakenConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

export type KubernetesConfigInput = {
  context?: InputMaybe<Scalars['String']['input']>;
  kubeconfigPath?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
};

export type LocalConfigInput = {
  basePath?: InputMaybe<Scalars['String']['input']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createBacktest: Backtest;
  createBot: Bot;
  createBotRunner: BotRunner;
  createExchange: Exchange;
  createStrategy: Strategy;
  createTrade: Trade;
  deleteBacktest: Scalars['Boolean']['output'];
  deleteBot: Scalars['Boolean']['output'];
  deleteBotRunner: Scalars['Boolean']['output'];
  deleteExchange: Scalars['Boolean']['output'];
  deleteStrategy: Scalars['Boolean']['output'];
  deleteTrade: Scalars['Boolean']['output'];
  refreshRunnerData: BotRunner;
  restartBot: Bot;
  runBacktest: Backtest;
  startBot: Bot;
  stopBacktest: Backtest;
  stopBot: Bot;
  testRunnerConnection: ConnectionTestResult;
  updateBot: Bot;
  updateBotRunner: BotRunner;
  updateExchange: Exchange;
  updateStrategy: Strategy;
  updateTrade: Trade;
};


export type MutationCreateBacktestArgs = {
  input: CreateBacktestInput;
};


export type MutationCreateBotArgs = {
  input: CreateBotInput;
};


export type MutationCreateBotRunnerArgs = {
  input: CreateBotRunnerInput;
};


export type MutationCreateExchangeArgs = {
  input: CreateExchangeInput;
};


export type MutationCreateStrategyArgs = {
  input: CreateStrategyInput;
};


export type MutationCreateTradeArgs = {
  input: CreateTradeInput;
};


export type MutationDeleteBacktestArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteBotRunnerArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteExchangeArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteStrategyArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteTradeArgs = {
  id: Scalars['ID']['input'];
};


export type MutationRefreshRunnerDataArgs = {
  id: Scalars['ID']['input'];
};


export type MutationRestartBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationRunBacktestArgs = {
  id: Scalars['ID']['input'];
};


export type MutationStartBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationStopBacktestArgs = {
  id: Scalars['ID']['input'];
};


export type MutationStopBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationTestRunnerConnectionArgs = {
  config: RunnerConfigInput;
  type: BotRunnerRunnerType;
};


export type MutationUpdateBotArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBotInput;
};


export type MutationUpdateBotRunnerArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBotRunnerInput;
};


export type MutationUpdateExchangeArgs = {
  id: Scalars['ID']['input'];
  input: UpdateExchangeInput;
};


export type MutationUpdateStrategyArgs = {
  id: Scalars['ID']['input'];
  input: UpdateStrategyInput;
};


export type MutationUpdateTradeArgs = {
  id: Scalars['ID']['input'];
  input: UpdateTradeInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type PassphraseExchangeConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
  passphrase: Scalars['String']['input'];
};

export type Query = {
  __typename?: 'Query';
  backtests: BacktestConnection;
  botMetricsSlice: Array<BotMetrics>;
  botRunners: BotRunnerConnection;
  bots: BotConnection;
  exchanges: Array<Exchange>;
  getBotRunnerStatus?: Maybe<BotStatus>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  strategies: StrategyConnection;
  /** Get all versions of a strategy by name (for version history view) */
  strategyVersions: Array<Strategy>;
  trades: TradeConnection;
};


export type QueryBacktestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BacktestWhereInput>;
};


export type QueryBotRunnersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotRunnerWhereInput>;
};


export type QueryBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};


export type QueryGetBotRunnerStatusArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryStrategiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<StrategyWhereInput>;
};


export type QueryStrategyVersionsArgs = {
  name: Scalars['String']['input'];
};


export type QueryTradesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TradeWhereInput>;
};

export type RegistryAuthInput = {
  password: Scalars['String']['input'];
  serverAddress?: InputMaybe<Scalars['String']['input']>;
  username: Scalars['String']['input'];
};

export type RunnerConfigInput = {
  docker?: InputMaybe<DockerConfigInput>;
  kubernetes?: InputMaybe<KubernetesConfigInput>;
  local?: InputMaybe<LocalConfigInput>;
};

export type Strategy = Node & {
  __typename?: 'Strategy';
  /** Strategy can have at most one backtest (one-to-one) */
  backtest?: Maybe<Backtest>;
  bots: BotConnection;
  /** Parent strategy for versioning (self-referential) */
  children?: Maybe<Array<Strategy>>;
  /** Python strategy code */
  code: Scalars['String']['output'];
  /** Strategy-specific configuration (config.json) - REQUIRED */
  config: Scalars['Map']['output'];
  createdAt: Scalars['Time']['output'];
  /** Strategy description */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Indicates if this is the latest version of the strategy */
  isLatest: Scalars['Boolean']['output'];
  /** Strategy name (not unique, allows versions) */
  name: Scalars['String']['output'];
  /** Group ID (organization) that owns this strategy */
  ownerID: Scalars['String']['output'];
  parent?: Maybe<Strategy>;
  /** Parent strategy ID for versioning (null for root v1) */
  parentID?: Maybe<Scalars['ID']['output']>;
  updatedAt: Scalars['Time']['output'];
  /** Auto-incremented version number */
  versionNumber: Scalars['Int']['output'];
};


export type StrategyBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};

/** A connection to a list of items. */
export type StrategyConnection = {
  __typename?: 'StrategyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StrategyEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type StrategyEdge = {
  __typename?: 'StrategyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Strategy>;
};

/**
 * StrategyWhereInput is used for filtering Strategy objects.
 * Input was generated by ent.
 */
export type StrategyWhereInput = {
  and?: InputMaybe<Array<StrategyWhereInput>>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']['input']>;
  codeContains?: InputMaybe<Scalars['String']['input']>;
  codeContainsFold?: InputMaybe<Scalars['String']['input']>;
  codeEqualFold?: InputMaybe<Scalars['String']['input']>;
  codeGT?: InputMaybe<Scalars['String']['input']>;
  codeGTE?: InputMaybe<Scalars['String']['input']>;
  codeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  codeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  codeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  codeLT?: InputMaybe<Scalars['String']['input']>;
  codeLTE?: InputMaybe<Scalars['String']['input']>;
  codeNEQ?: InputMaybe<Scalars['String']['input']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** backtest edge predicates */
  hasBacktest?: InputMaybe<Scalars['Boolean']['input']>;
  hasBacktestWith?: InputMaybe<Array<BacktestWhereInput>>;
  /** bots edge predicates */
  hasBots?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotsWith?: InputMaybe<Array<BotWhereInput>>;
  /** children edge predicates */
  hasChildren?: InputMaybe<Scalars['Boolean']['input']>;
  hasChildrenWith?: InputMaybe<Array<StrategyWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']['input']>;
  hasParentWith?: InputMaybe<Array<StrategyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_latest field predicates */
  isLatest?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<StrategyWhereInput>;
  or?: InputMaybe<Array<StrategyWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  ownerIDContains?: InputMaybe<Scalars['String']['input']>;
  ownerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDGT?: InputMaybe<Scalars['String']['input']>;
  ownerIDGTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ownerIDLT?: InputMaybe<Scalars['String']['input']>;
  ownerIDLTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** parent_id field predicates */
  parentID?: InputMaybe<Scalars['ID']['input']>;
  parentIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  parentIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  parentIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  parentIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  parentIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** version_number field predicates */
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
  versionNumberGT?: InputMaybe<Scalars['Int']['input']>;
  versionNumberGTE?: InputMaybe<Scalars['Int']['input']>;
  versionNumberIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  versionNumberLT?: InputMaybe<Scalars['Int']['input']>;
  versionNumberLTE?: InputMaybe<Scalars['Int']['input']>;
  versionNumberNEQ?: InputMaybe<Scalars['Int']['input']>;
  versionNumberNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type Trade = Node & {
  __typename?: 'Trade';
  /** Amount of coins */
  amount: Scalars['Float']['output'];
  bot: Bot;
  /** Foreign key to bot */
  botID: Scalars['ID']['output'];
  /** Trade close time */
  closeDate?: Maybe<Scalars['Time']['output']>;
  /** Exit price */
  closeRate?: Maybe<Scalars['Float']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Original trade ID from freqtrade */
  freqtradeTradeID: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** Trade open status */
  isOpen: Scalars['Boolean']['output'];
  /** Trade open time */
  openDate: Scalars['Time']['output'];
  /** Entry price */
  openRate: Scalars['Float']['output'];
  /** Trading pair (BTC/USDT) */
  pair: Scalars['String']['output'];
  /** Absolute profit */
  profitAbs: Scalars['Float']['output'];
  /** Profit percentage (0.05 = 5%) */
  profitRatio: Scalars['Float']['output'];
  /** Reason for selling (roi, stoploss, etc.) */
  sellReason?: Maybe<Scalars['String']['output']>;
  /** Stake in base currency */
  stakeAmount: Scalars['Float']['output'];
  /** Strategy used */
  strategyName?: Maybe<Scalars['String']['output']>;
  /** Timeframe used */
  timeframe?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type TradeConnection = {
  __typename?: 'TradeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TradeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TradeEdge = {
  __typename?: 'TradeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Trade>;
};

/**
 * TradeWhereInput is used for filtering Trade objects.
 * Input was generated by ent.
 */
export type TradeWhereInput = {
  /** amount field predicates */
  amount?: InputMaybe<Scalars['Float']['input']>;
  amountGT?: InputMaybe<Scalars['Float']['input']>;
  amountGTE?: InputMaybe<Scalars['Float']['input']>;
  amountIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  amountLT?: InputMaybe<Scalars['Float']['input']>;
  amountLTE?: InputMaybe<Scalars['Float']['input']>;
  amountNEQ?: InputMaybe<Scalars['Float']['input']>;
  amountNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  and?: InputMaybe<Array<TradeWhereInput>>;
  /** bot_id field predicates */
  botID?: InputMaybe<Scalars['ID']['input']>;
  botIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  botIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  botIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** close_date field predicates */
  closeDate?: InputMaybe<Scalars['Time']['input']>;
  closeDateGT?: InputMaybe<Scalars['Time']['input']>;
  closeDateGTE?: InputMaybe<Scalars['Time']['input']>;
  closeDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  closeDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  closeDateLT?: InputMaybe<Scalars['Time']['input']>;
  closeDateLTE?: InputMaybe<Scalars['Time']['input']>;
  closeDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  closeDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  closeDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** close_rate field predicates */
  closeRate?: InputMaybe<Scalars['Float']['input']>;
  closeRateGT?: InputMaybe<Scalars['Float']['input']>;
  closeRateGTE?: InputMaybe<Scalars['Float']['input']>;
  closeRateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  closeRateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  closeRateLT?: InputMaybe<Scalars['Float']['input']>;
  closeRateLTE?: InputMaybe<Scalars['Float']['input']>;
  closeRateNEQ?: InputMaybe<Scalars['Float']['input']>;
  closeRateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  closeRateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** freqtrade_trade_id field predicates */
  freqtradeTradeID?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDGT?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDGTE?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  freqtradeTradeIDLT?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDLTE?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** bot edge predicates */
  hasBot?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_open field predicates */
  isOpen?: InputMaybe<Scalars['Boolean']['input']>;
  isOpenNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<TradeWhereInput>;
  /** open_date field predicates */
  openDate?: InputMaybe<Scalars['Time']['input']>;
  openDateGT?: InputMaybe<Scalars['Time']['input']>;
  openDateGTE?: InputMaybe<Scalars['Time']['input']>;
  openDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  openDateLT?: InputMaybe<Scalars['Time']['input']>;
  openDateLTE?: InputMaybe<Scalars['Time']['input']>;
  openDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  openDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** open_rate field predicates */
  openRate?: InputMaybe<Scalars['Float']['input']>;
  openRateGT?: InputMaybe<Scalars['Float']['input']>;
  openRateGTE?: InputMaybe<Scalars['Float']['input']>;
  openRateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  openRateLT?: InputMaybe<Scalars['Float']['input']>;
  openRateLTE?: InputMaybe<Scalars['Float']['input']>;
  openRateNEQ?: InputMaybe<Scalars['Float']['input']>;
  openRateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  or?: InputMaybe<Array<TradeWhereInput>>;
  /** pair field predicates */
  pair?: InputMaybe<Scalars['String']['input']>;
  pairContains?: InputMaybe<Scalars['String']['input']>;
  pairContainsFold?: InputMaybe<Scalars['String']['input']>;
  pairEqualFold?: InputMaybe<Scalars['String']['input']>;
  pairGT?: InputMaybe<Scalars['String']['input']>;
  pairGTE?: InputMaybe<Scalars['String']['input']>;
  pairHasPrefix?: InputMaybe<Scalars['String']['input']>;
  pairHasSuffix?: InputMaybe<Scalars['String']['input']>;
  pairIn?: InputMaybe<Array<Scalars['String']['input']>>;
  pairLT?: InputMaybe<Scalars['String']['input']>;
  pairLTE?: InputMaybe<Scalars['String']['input']>;
  pairNEQ?: InputMaybe<Scalars['String']['input']>;
  pairNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** profit_abs field predicates */
  profitAbs?: InputMaybe<Scalars['Float']['input']>;
  profitAbsGT?: InputMaybe<Scalars['Float']['input']>;
  profitAbsGTE?: InputMaybe<Scalars['Float']['input']>;
  profitAbsIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAbsLT?: InputMaybe<Scalars['Float']['input']>;
  profitAbsLTE?: InputMaybe<Scalars['Float']['input']>;
  profitAbsNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitAbsNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** profit_ratio field predicates */
  profitRatio?: InputMaybe<Scalars['Float']['input']>;
  profitRatioGT?: InputMaybe<Scalars['Float']['input']>;
  profitRatioGTE?: InputMaybe<Scalars['Float']['input']>;
  profitRatioIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitRatioLT?: InputMaybe<Scalars['Float']['input']>;
  profitRatioLTE?: InputMaybe<Scalars['Float']['input']>;
  profitRatioNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitRatioNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** sell_reason field predicates */
  sellReason?: InputMaybe<Scalars['String']['input']>;
  sellReasonContains?: InputMaybe<Scalars['String']['input']>;
  sellReasonContainsFold?: InputMaybe<Scalars['String']['input']>;
  sellReasonEqualFold?: InputMaybe<Scalars['String']['input']>;
  sellReasonGT?: InputMaybe<Scalars['String']['input']>;
  sellReasonGTE?: InputMaybe<Scalars['String']['input']>;
  sellReasonHasPrefix?: InputMaybe<Scalars['String']['input']>;
  sellReasonHasSuffix?: InputMaybe<Scalars['String']['input']>;
  sellReasonIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sellReasonIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sellReasonLT?: InputMaybe<Scalars['String']['input']>;
  sellReasonLTE?: InputMaybe<Scalars['String']['input']>;
  sellReasonNEQ?: InputMaybe<Scalars['String']['input']>;
  sellReasonNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sellReasonNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** stake_amount field predicates */
  stakeAmount?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountGT?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountGTE?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  stakeAmountLT?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountLTE?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountNEQ?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** strategy_name field predicates */
  strategyName?: InputMaybe<Scalars['String']['input']>;
  strategyNameContains?: InputMaybe<Scalars['String']['input']>;
  strategyNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  strategyNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  strategyNameGT?: InputMaybe<Scalars['String']['input']>;
  strategyNameGTE?: InputMaybe<Scalars['String']['input']>;
  strategyNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  strategyNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  strategyNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  strategyNameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  strategyNameLT?: InputMaybe<Scalars['String']['input']>;
  strategyNameLTE?: InputMaybe<Scalars['String']['input']>;
  strategyNameNEQ?: InputMaybe<Scalars['String']['input']>;
  strategyNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  strategyNameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** timeframe field predicates */
  timeframe?: InputMaybe<Scalars['String']['input']>;
  timeframeContains?: InputMaybe<Scalars['String']['input']>;
  timeframeContainsFold?: InputMaybe<Scalars['String']['input']>;
  timeframeEqualFold?: InputMaybe<Scalars['String']['input']>;
  timeframeGT?: InputMaybe<Scalars['String']['input']>;
  timeframeGTE?: InputMaybe<Scalars['String']['input']>;
  timeframeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  timeframeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  timeframeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  timeframeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  timeframeLT?: InputMaybe<Scalars['String']['input']>;
  timeframeLTE?: InputMaybe<Scalars['String']['input']>;
  timeframeNEQ?: InputMaybe<Scalars['String']['input']>;
  timeframeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  timeframeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * UpdateBotInput is used for update Bot object.
 * Input was generated by ent.
 */
export type UpdateBotInput = {
  addTradeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearContainerID?: InputMaybe<Scalars['Boolean']['input']>;
  clearErrorMessage?: InputMaybe<Scalars['Boolean']['input']>;
  clearLastSeenAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearMetrics?: InputMaybe<Scalars['Boolean']['input']>;
  clearTrades?: InputMaybe<Scalars['Boolean']['input']>;
  /** Complete freqtrade bot configuration (stake, pairlists, pricing, api_server, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Runner-specific identifier (container ID, pod name, etc.) */
  containerID?: InputMaybe<Scalars['String']['input']>;
  /** Last error message if status is error */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  exchangeID?: InputMaybe<Scalars['ID']['input']>;
  /** Freqtrade Docker image version tag */
  freqtradeVersion?: InputMaybe<Scalars['String']['input']>;
  /** Last successful health check */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>;
  metricsID?: InputMaybe<Scalars['ID']['input']>;
  /** Trading mode (dry-run or live) */
  mode?: InputMaybe<BotBotMode>;
  /** Bot display name */
  name?: InputMaybe<Scalars['String']['input']>;
  removeTradeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  /** Bot lifecycle status */
  status?: InputMaybe<BotBotStatus>;
  strategyID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateBotMetricsInput is used for update BotMetrics object.
 * Input was generated by ent.
 */
export type UpdateBotMetricsInput = {
  /** Best performing trading pair */
  bestPair?: InputMaybe<Scalars['String']['input']>;
  /** Best trade profit rate */
  bestRate?: InputMaybe<Scalars['Float']['input']>;
  botID?: InputMaybe<Scalars['ID']['input']>;
  clearBestPair?: InputMaybe<Scalars['Boolean']['input']>;
  clearBestRate?: InputMaybe<Scalars['Boolean']['input']>;
  clearClosedTradeCount?: InputMaybe<Scalars['Boolean']['input']>;
  clearExpectancy?: InputMaybe<Scalars['Boolean']['input']>;
  clearFirstTradeTimestamp?: InputMaybe<Scalars['Boolean']['input']>;
  clearLatestTradeTimestamp?: InputMaybe<Scalars['Boolean']['input']>;
  clearLosingTrades?: InputMaybe<Scalars['Boolean']['input']>;
  clearMaxDrawdown?: InputMaybe<Scalars['Boolean']['input']>;
  clearMaxDrawdownAbs?: InputMaybe<Scalars['Boolean']['input']>;
  clearOpenTradeCount?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitAllCoin?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitAllPercent?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitClosedCoin?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitClosedPercent?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitFactor?: InputMaybe<Scalars['Boolean']['input']>;
  clearTradeCount?: InputMaybe<Scalars['Boolean']['input']>;
  clearWinningTrades?: InputMaybe<Scalars['Boolean']['input']>;
  clearWinrate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of closed trades */
  closedTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Average profit per trade */
  expectancy?: InputMaybe<Scalars['Float']['input']>;
  /** When these metrics were fetched from Freqtrade API */
  fetchedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of first trade */
  firstTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of latest trade */
  latestTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Number of losing trades */
  losingTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum drawdown percentage */
  maxDrawdown?: InputMaybe<Scalars['Float']['input']>;
  /** Maximum drawdown absolute value */
  maxDrawdownAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Current number of open trades */
  openTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Total profit (closed + open) in coin */
  profitAllCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total profit (closed + open) percentage */
  profitAllPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit in coin */
  profitClosedCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit percentage */
  profitClosedPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Ratio of gross profit to gross loss */
  profitFactor?: InputMaybe<Scalars['Float']['input']>;
  /** Total number of trades */
  tradeCount?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Number of winning trades */
  winningTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Win rate percentage (0-100) */
  winrate?: InputMaybe<Scalars['Float']['input']>;
};

/**
 * UpdateBotRunnerInput is used for update BotRunner object.
 * Input was generated by ent.
 */
export type UpdateBotRunnerInput = {
  addBacktestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearBacktests?: InputMaybe<Scalars['Boolean']['input']>;
  clearBots?: InputMaybe<Scalars['Boolean']['input']>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataDownloadConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataDownloadProgress?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataErrorMessage?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataLastUpdated?: InputMaybe<Scalars['Boolean']['input']>;
  /** Runner connection configuration (host, port, credentials, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Data download configuration: {exchanges: [{name, enabled, timeframes, pairs_pattern, days, trading_mode}]} */
  dataDownloadConfig?: InputMaybe<Scalars['Map']['input']>;
  /** Progress details: {pairs_completed, pairs_total, current_pair, percent_complete} */
  dataDownloadProgress?: InputMaybe<Scalars['Map']['input']>;
  /** Current data download status (idle, downloading, completed, failed) */
  dataDownloadStatus?: InputMaybe<BotRunnerDataDownloadStatus>;
  /** Error message if data download failed */
  dataErrorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Whether runner has downloaded historical data for backtesting */
  dataIsReady?: InputMaybe<Scalars['Boolean']['input']>;
  /** When data was last refreshed */
  dataLastUpdated?: InputMaybe<Scalars['Time']['input']>;
  /** Runner display name */
  name?: InputMaybe<Scalars['String']['input']>;
  removeBacktestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Runner environment type (docker, kubernetes, local) */
  type?: InputMaybe<BotRunnerRunnerType>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateExchangeInput is used for update Exchange object.
 * Input was generated by ent.
 */
export type UpdateExchangeInput = {
  addBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearBots?: InputMaybe<Scalars['Boolean']['input']>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  /** Complete freqtrade exchange configuration (name, key, secret, pair_whitelist, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Exchange display name (e.g., 'Binance Production', 'Coinbase Testnet') */
  name?: InputMaybe<Scalars['String']['input']>;
  removeBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateStrategyInput is used for update Strategy object.
 * Input was generated by ent.
 */
export type UpdateStrategyInput = {
  addBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addChildIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  backtestID?: InputMaybe<Scalars['ID']['input']>;
  clearBacktest?: InputMaybe<Scalars['Boolean']['input']>;
  clearBots?: InputMaybe<Scalars['Boolean']['input']>;
  clearChildren?: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  clearParent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Python strategy code */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Strategy-specific configuration (config.json) - REQUIRED */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Strategy description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if this is the latest version of the strategy */
  isLatest?: InputMaybe<Scalars['Boolean']['input']>;
  /** Strategy name (not unique, allows versions) */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Group ID (organization) that owns this strategy */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  parentID?: InputMaybe<Scalars['ID']['input']>;
  removeBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeChildIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Auto-incremented version number */
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * UpdateTradeInput is used for update Trade object.
 * Input was generated by ent.
 */
export type UpdateTradeInput = {
  /** Amount of coins */
  amount?: InputMaybe<Scalars['Float']['input']>;
  botID?: InputMaybe<Scalars['ID']['input']>;
  clearCloseDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearCloseRate?: InputMaybe<Scalars['Boolean']['input']>;
  clearSellReason?: InputMaybe<Scalars['Boolean']['input']>;
  clearStrategyName?: InputMaybe<Scalars['Boolean']['input']>;
  clearTimeframe?: InputMaybe<Scalars['Boolean']['input']>;
  /** Trade close time */
  closeDate?: InputMaybe<Scalars['Time']['input']>;
  /** Exit price */
  closeRate?: InputMaybe<Scalars['Float']['input']>;
  /** Original trade ID from freqtrade */
  freqtradeTradeID?: InputMaybe<Scalars['Int']['input']>;
  /** Trade open status */
  isOpen?: InputMaybe<Scalars['Boolean']['input']>;
  /** Trade open time */
  openDate?: InputMaybe<Scalars['Time']['input']>;
  /** Entry price */
  openRate?: InputMaybe<Scalars['Float']['input']>;
  /** Trading pair (BTC/USDT) */
  pair?: InputMaybe<Scalars['String']['input']>;
  /** Absolute profit */
  profitAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Profit percentage (0.05 = 5%) */
  profitRatio?: InputMaybe<Scalars['Float']['input']>;
  /** Reason for selling (roi, stoploss, etc.) */
  sellReason?: InputMaybe<Scalars['String']['input']>;
  /** Stake in base currency */
  stakeAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Strategy used */
  strategyName?: InputMaybe<Scalars['String']['input']>;
  /** Timeframe used */
  timeframe?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};
