export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: { input: string; output: string; }
  /** The builtin Map type represents a JSON object. */
  Map: { input: Record<string, any>; output: Record<string, any>; }
  /** The builtin Time type represents a timestamp in RFC 3339 format. */
  Time: { input: string; output: string; }
};

export type AlertEvent = Node & {
  __typename?: 'AlertEvent';
  /** Alert type (denormalized from rule) */
  alertType: AlertEventAlertType;
  /** Alert body content (plain text) */
  body: Scalars['String']['output'];
  /** Delivery channel type: email (webhook, push reserved for future) */
  channelType: Scalars['String']['output'];
  /** Event context data (bot ID, trade details, metrics, etc.) */
  context?: Maybe<Scalars['Map']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Error message if delivery failed */
  errorMessage?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Organization ID */
  ownerID: Scalars['String']['output'];
  /** When the alert was read by the user */
  readAt?: Maybe<Scalars['Time']['output']>;
  /** Actual recipients at time of send */
  recipients: Array<Scalars['String']['output']>;
  /** ID of resource that triggered alert */
  resourceID?: Maybe<Scalars['ID']['output']>;
  /** Type of resource that triggered alert */
  resourceType: AlertEventAlertResourceType;
  rule: AlertRule;
  /** Foreign key to the rule that triggered this event */
  ruleID: Scalars['ID']['output'];
  /** When the alert was actually delivered */
  sentAt?: Maybe<Scalars['Time']['output']>;
  /** Severity (denormalized from rule) */
  severity: AlertEventAlertSeverity;
  /** Delivery status: pending, sent, failed, suppressed */
  status: AlertEventAlertEventStatus;
  /** Alert subject/title */
  subject: Scalars['String']['output'];
};

/** AlertEventAlertEventStatus is enum for the field status */
export enum AlertEventAlertEventStatus {
  Failed = 'failed',
  Pending = 'pending',
  Sent = 'sent',
  Suppressed = 'suppressed'
}

/** AlertEventAlertResourceType is enum for the field resource_type */
export enum AlertEventAlertResourceType {
  Bot = 'bot',
  Organization = 'organization',
  Runner = 'runner',
  Strategy = 'strategy'
}

/** AlertEventAlertSeverity is enum for the field severity */
export enum AlertEventAlertSeverity {
  Critical = 'critical',
  Info = 'info',
  Warning = 'warning'
}

/** AlertEventAlertType is enum for the field alert_type */
export enum AlertEventAlertType {
  BacktestCompleted = 'backtest_completed',
  BacktestFailed = 'backtest_failed',
  ConnectionIssue = 'connection_issue',
  DailyLossLimit = 'daily_loss_limit',
  DrawdownThreshold = 'drawdown_threshold',
  LargeProfitLoss = 'large_profit_loss',
  ProfitTarget = 'profit_target',
  StatusChange = 'status_change',
  TradeClosed = 'trade_closed',
  TradeOpened = 'trade_opened'
}

/** A connection to a list of items. */
export type AlertEventConnection = {
  __typename?: 'AlertEventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertEventEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AlertEventEdge = {
  __typename?: 'AlertEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertEvent>;
};

/** Ordering options for AlertEvent connections */
export type AlertEventOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order AlertEvents. */
  field: AlertEventOrderField;
};

/** Properties by which AlertEvent connections can be ordered. */
export enum AlertEventOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * AlertEventWhereInput is used for filtering AlertEvent objects.
 * Input was generated by ent.
 */
export type AlertEventWhereInput = {
  /** alert_type field predicates */
  alertType?: InputMaybe<AlertEventAlertType>;
  alertTypeIn?: InputMaybe<Array<AlertEventAlertType>>;
  alertTypeNEQ?: InputMaybe<AlertEventAlertType>;
  alertTypeNotIn?: InputMaybe<Array<AlertEventAlertType>>;
  and?: InputMaybe<Array<AlertEventWhereInput>>;
  /** body field predicates */
  body?: InputMaybe<Scalars['String']['input']>;
  bodyContains?: InputMaybe<Scalars['String']['input']>;
  bodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  bodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  bodyGT?: InputMaybe<Scalars['String']['input']>;
  bodyGTE?: InputMaybe<Scalars['String']['input']>;
  bodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bodyLT?: InputMaybe<Scalars['String']['input']>;
  bodyLTE?: InputMaybe<Scalars['String']['input']>;
  bodyNEQ?: InputMaybe<Scalars['String']['input']>;
  bodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** channel_type field predicates */
  channelType?: InputMaybe<Scalars['String']['input']>;
  channelTypeContains?: InputMaybe<Scalars['String']['input']>;
  channelTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  channelTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  channelTypeGT?: InputMaybe<Scalars['String']['input']>;
  channelTypeGTE?: InputMaybe<Scalars['String']['input']>;
  channelTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  channelTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  channelTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  channelTypeLT?: InputMaybe<Scalars['String']['input']>;
  channelTypeLTE?: InputMaybe<Scalars['String']['input']>;
  channelTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  channelTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** error_message field predicates */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  errorMessageContains?: InputMaybe<Scalars['String']['input']>;
  errorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageGT?: InputMaybe<Scalars['String']['input']>;
  errorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  errorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  errorMessageLT?: InputMaybe<Scalars['String']['input']>;
  errorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  errorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** rule edge predicates */
  hasRule?: InputMaybe<Scalars['Boolean']['input']>;
  hasRuleWith?: InputMaybe<Array<AlertRuleWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<AlertEventWhereInput>;
  or?: InputMaybe<Array<AlertEventWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  ownerIDContains?: InputMaybe<Scalars['String']['input']>;
  ownerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDGT?: InputMaybe<Scalars['String']['input']>;
  ownerIDGTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ownerIDLT?: InputMaybe<Scalars['String']['input']>;
  ownerIDLTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** read_at field predicates */
  readAt?: InputMaybe<Scalars['Time']['input']>;
  readAtGT?: InputMaybe<Scalars['Time']['input']>;
  readAtGTE?: InputMaybe<Scalars['Time']['input']>;
  readAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  readAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  readAtLT?: InputMaybe<Scalars['Time']['input']>;
  readAtLTE?: InputMaybe<Scalars['Time']['input']>;
  readAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  readAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  readAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** resource_id field predicates */
  resourceID?: InputMaybe<Scalars['ID']['input']>;
  resourceIDGT?: InputMaybe<Scalars['ID']['input']>;
  resourceIDGTE?: InputMaybe<Scalars['ID']['input']>;
  resourceIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  resourceIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  resourceIDLT?: InputMaybe<Scalars['ID']['input']>;
  resourceIDLTE?: InputMaybe<Scalars['ID']['input']>;
  resourceIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  resourceIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  resourceIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** resource_type field predicates */
  resourceType?: InputMaybe<AlertEventAlertResourceType>;
  resourceTypeIn?: InputMaybe<Array<AlertEventAlertResourceType>>;
  resourceTypeNEQ?: InputMaybe<AlertEventAlertResourceType>;
  resourceTypeNotIn?: InputMaybe<Array<AlertEventAlertResourceType>>;
  /** rule_id field predicates */
  ruleID?: InputMaybe<Scalars['ID']['input']>;
  ruleIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  ruleIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  ruleIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** sent_at field predicates */
  sentAt?: InputMaybe<Scalars['Time']['input']>;
  sentAtGT?: InputMaybe<Scalars['Time']['input']>;
  sentAtGTE?: InputMaybe<Scalars['Time']['input']>;
  sentAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  sentAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sentAtLT?: InputMaybe<Scalars['Time']['input']>;
  sentAtLTE?: InputMaybe<Scalars['Time']['input']>;
  sentAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  sentAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  sentAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** severity field predicates */
  severity?: InputMaybe<AlertEventAlertSeverity>;
  severityIn?: InputMaybe<Array<AlertEventAlertSeverity>>;
  severityNEQ?: InputMaybe<AlertEventAlertSeverity>;
  severityNotIn?: InputMaybe<Array<AlertEventAlertSeverity>>;
  /** status field predicates */
  status?: InputMaybe<AlertEventAlertEventStatus>;
  statusIn?: InputMaybe<Array<AlertEventAlertEventStatus>>;
  statusNEQ?: InputMaybe<AlertEventAlertEventStatus>;
  statusNotIn?: InputMaybe<Array<AlertEventAlertEventStatus>>;
  /** subject field predicates */
  subject?: InputMaybe<Scalars['String']['input']>;
  subjectContains?: InputMaybe<Scalars['String']['input']>;
  subjectContainsFold?: InputMaybe<Scalars['String']['input']>;
  subjectEqualFold?: InputMaybe<Scalars['String']['input']>;
  subjectGT?: InputMaybe<Scalars['String']['input']>;
  subjectGTE?: InputMaybe<Scalars['String']['input']>;
  subjectHasPrefix?: InputMaybe<Scalars['String']['input']>;
  subjectHasSuffix?: InputMaybe<Scalars['String']['input']>;
  subjectIn?: InputMaybe<Array<Scalars['String']['input']>>;
  subjectLT?: InputMaybe<Scalars['String']['input']>;
  subjectLTE?: InputMaybe<Scalars['String']['input']>;
  subjectNEQ?: InputMaybe<Scalars['String']['input']>;
  subjectNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type AlertRule = Node & {
  __typename?: 'AlertRule';
  /** Type of alert: status_change, trade_opened, trade_closed, etc. */
  alertType: AlertRuleAlertType;
  /** Batch window in minutes (only used if delivery_mode=batched) */
  batchIntervalMinutes: Scalars['Int']['output'];
  /** Filter by bot trading mode: all, live, dry_run */
  botModeFilter: AlertRuleAlertBotModeFilter;
  /** Condition parameters: thresholds, status values, etc. */
  conditions?: Maybe<Scalars['Map']['output']>;
  /** Minimum minutes between alerts of same type for same resource */
  cooldownMinutes: Scalars['Int']['output'];
  createdAt: Scalars['Time']['output'];
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** Delivery mode: immediate or batched */
  deliveryMode: AlertRuleAlertDeliveryMode;
  /** Whether this rule is active */
  enabled: Scalars['Boolean']['output'];
  events: AlertEventConnection;
  id: Scalars['ID']['output'];
  /** When this rule last triggered (for cooldown calculation) */
  lastTriggeredAt?: Maybe<Scalars['Time']['output']>;
  /** Human-readable rule name (e.g., 'Bot Error Alert') */
  name: Scalars['String']['output'];
  /** Organization ID that owns this rule */
  ownerID: Scalars['String']['output'];
  /** List of recipient email addresses */
  recipients: Array<Scalars['String']['output']>;
  /** Specific resource ID (null for org-level rules that apply to all resources) */
  resourceID?: Maybe<Scalars['ID']['output']>;
  /** Type of resource: organization, bot, strategy, runner */
  resourceType: AlertRuleAlertResourceType;
  /** Alert severity: critical, warning, info */
  severity: AlertRuleAlertSeverity;
  updatedAt: Scalars['Time']['output'];
};


export type AlertRuleEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AlertEventOrder>;
  where?: InputMaybe<AlertEventWhereInput>;
};

/** AlertRuleAlertBotModeFilter is enum for the field bot_mode_filter */
export enum AlertRuleAlertBotModeFilter {
  All = 'all',
  DryRun = 'dry_run',
  Live = 'live'
}

/** AlertRuleAlertDeliveryMode is enum for the field delivery_mode */
export enum AlertRuleAlertDeliveryMode {
  Batched = 'batched',
  Immediate = 'immediate'
}

/** AlertRuleAlertResourceType is enum for the field resource_type */
export enum AlertRuleAlertResourceType {
  Bot = 'bot',
  Organization = 'organization',
  Runner = 'runner',
  Strategy = 'strategy'
}

/** AlertRuleAlertSeverity is enum for the field severity */
export enum AlertRuleAlertSeverity {
  Critical = 'critical',
  Info = 'info',
  Warning = 'warning'
}

/** AlertRuleAlertType is enum for the field alert_type */
export enum AlertRuleAlertType {
  BacktestCompleted = 'backtest_completed',
  BacktestFailed = 'backtest_failed',
  ConnectionIssue = 'connection_issue',
  DailyLossLimit = 'daily_loss_limit',
  DrawdownThreshold = 'drawdown_threshold',
  LargeProfitLoss = 'large_profit_loss',
  ProfitTarget = 'profit_target',
  StatusChange = 'status_change',
  TradeClosed = 'trade_closed',
  TradeOpened = 'trade_opened'
}

/** A connection to a list of items. */
export type AlertRuleConnection = {
  __typename?: 'AlertRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertRuleEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AlertRuleEdge = {
  __typename?: 'AlertRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertRule>;
};

/**
 * AlertRuleWhereInput is used for filtering AlertRule objects.
 * Input was generated by ent.
 */
export type AlertRuleWhereInput = {
  /** alert_type field predicates */
  alertType?: InputMaybe<AlertRuleAlertType>;
  alertTypeIn?: InputMaybe<Array<AlertRuleAlertType>>;
  alertTypeNEQ?: InputMaybe<AlertRuleAlertType>;
  alertTypeNotIn?: InputMaybe<Array<AlertRuleAlertType>>;
  and?: InputMaybe<Array<AlertRuleWhereInput>>;
  /** batch_interval_minutes field predicates */
  batchIntervalMinutes?: InputMaybe<Scalars['Int']['input']>;
  batchIntervalMinutesGT?: InputMaybe<Scalars['Int']['input']>;
  batchIntervalMinutesGTE?: InputMaybe<Scalars['Int']['input']>;
  batchIntervalMinutesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  batchIntervalMinutesLT?: InputMaybe<Scalars['Int']['input']>;
  batchIntervalMinutesLTE?: InputMaybe<Scalars['Int']['input']>;
  batchIntervalMinutesNEQ?: InputMaybe<Scalars['Int']['input']>;
  batchIntervalMinutesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** bot_mode_filter field predicates */
  botModeFilter?: InputMaybe<AlertRuleAlertBotModeFilter>;
  botModeFilterIn?: InputMaybe<Array<AlertRuleAlertBotModeFilter>>;
  botModeFilterNEQ?: InputMaybe<AlertRuleAlertBotModeFilter>;
  botModeFilterNotIn?: InputMaybe<Array<AlertRuleAlertBotModeFilter>>;
  /** cooldown_minutes field predicates */
  cooldownMinutes?: InputMaybe<Scalars['Int']['input']>;
  cooldownMinutesGT?: InputMaybe<Scalars['Int']['input']>;
  cooldownMinutesGTE?: InputMaybe<Scalars['Int']['input']>;
  cooldownMinutesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  cooldownMinutesLT?: InputMaybe<Scalars['Int']['input']>;
  cooldownMinutesLTE?: InputMaybe<Scalars['Int']['input']>;
  cooldownMinutesNEQ?: InputMaybe<Scalars['Int']['input']>;
  cooldownMinutesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** delivery_mode field predicates */
  deliveryMode?: InputMaybe<AlertRuleAlertDeliveryMode>;
  deliveryModeIn?: InputMaybe<Array<AlertRuleAlertDeliveryMode>>;
  deliveryModeNEQ?: InputMaybe<AlertRuleAlertDeliveryMode>;
  deliveryModeNotIn?: InputMaybe<Array<AlertRuleAlertDeliveryMode>>;
  /** enabled field predicates */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  enabledNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** events edge predicates */
  hasEvents?: InputMaybe<Scalars['Boolean']['input']>;
  hasEventsWith?: InputMaybe<Array<AlertEventWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_triggered_at field predicates */
  lastTriggeredAt?: InputMaybe<Scalars['Time']['input']>;
  lastTriggeredAtGT?: InputMaybe<Scalars['Time']['input']>;
  lastTriggeredAtGTE?: InputMaybe<Scalars['Time']['input']>;
  lastTriggeredAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastTriggeredAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastTriggeredAtLT?: InputMaybe<Scalars['Time']['input']>;
  lastTriggeredAtLTE?: InputMaybe<Scalars['Time']['input']>;
  lastTriggeredAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastTriggeredAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastTriggeredAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<AlertRuleWhereInput>;
  or?: InputMaybe<Array<AlertRuleWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  ownerIDContains?: InputMaybe<Scalars['String']['input']>;
  ownerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDGT?: InputMaybe<Scalars['String']['input']>;
  ownerIDGTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ownerIDLT?: InputMaybe<Scalars['String']['input']>;
  ownerIDLTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** resource_id field predicates */
  resourceID?: InputMaybe<Scalars['ID']['input']>;
  resourceIDGT?: InputMaybe<Scalars['ID']['input']>;
  resourceIDGTE?: InputMaybe<Scalars['ID']['input']>;
  resourceIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  resourceIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  resourceIDLT?: InputMaybe<Scalars['ID']['input']>;
  resourceIDLTE?: InputMaybe<Scalars['ID']['input']>;
  resourceIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  resourceIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  resourceIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** resource_type field predicates */
  resourceType?: InputMaybe<AlertRuleAlertResourceType>;
  resourceTypeIn?: InputMaybe<Array<AlertRuleAlertResourceType>>;
  resourceTypeNEQ?: InputMaybe<AlertRuleAlertResourceType>;
  resourceTypeNotIn?: InputMaybe<Array<AlertRuleAlertResourceType>>;
  /** severity field predicates */
  severity?: InputMaybe<AlertRuleAlertSeverity>;
  severityIn?: InputMaybe<Array<AlertRuleAlertSeverity>>;
  severityNEQ?: InputMaybe<AlertRuleAlertSeverity>;
  severityNotIn?: InputMaybe<Array<AlertRuleAlertSeverity>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/** Metadata about an alert type including available condition fields */
export type AlertTypeInfo = {
  __typename?: 'AlertTypeInfo';
  conditionFields: Array<ConditionField>;
  defaultSeverity: AlertRuleAlertSeverity;
  description: Scalars['String']['output'];
  label: Scalars['String']['output'];
  type: AlertRuleAlertType;
};

export type Backtest = Node & {
  __typename?: 'Backtest';
  /** Completion timestamp */
  completedAt?: Maybe<Scalars['Time']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** Backtest end date (end of time range) */
  endDate?: Maybe<Scalars['Time']['output']>;
  /** Error message if backtest failed */
  errorMessage?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Container logs from backtest execution */
  logs?: Maybe<Scalars['String']['output']>;
  /**
   * Total resource usage for this backtest execution
   * Only populated if the backtest ran on a runner with billing enabled
   */
  resourceUsage?: Maybe<ResourceUsageAggregation>;
  /** Backtest result data (metrics, logs, trades, etc.) */
  result?: Maybe<Scalars['Map']['output']>;
  runner: BotRunner;
  /** Foreign key to runner */
  runnerID: Scalars['ID']['output'];
  /** Backtest start date (beginning of time range) */
  startDate?: Maybe<Scalars['Time']['output']>;
  /** Task status */
  status: BacktestTaskStatus;
  strategy: Strategy;
  /** Foreign key to strategy */
  strategyID: Scalars['ID']['output'];
  /** Typed summary of key backtest metrics extracted from result */
  summary?: Maybe<BacktestSummary>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type BacktestConnection = {
  __typename?: 'BacktestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BacktestEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BacktestEdge = {
  __typename?: 'BacktestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Backtest>;
};

export type BacktestSummary = {
  __typename?: 'BacktestSummary';
  avgStakeAmount?: Maybe<Scalars['Float']['output']>;
  backtestDays?: Maybe<Scalars['Int']['output']>;
  backtestEnd?: Maybe<Scalars['Time']['output']>;
  backtestStart?: Maybe<Scalars['Time']['output']>;
  calmar?: Maybe<Scalars['Float']['output']>;
  expectancy?: Maybe<Scalars['Float']['output']>;
  losses: Scalars['Int']['output'];
  maxDrawdown?: Maybe<Scalars['Float']['output']>;
  profitFactor?: Maybe<Scalars['Float']['output']>;
  profitMean?: Maybe<Scalars['Float']['output']>;
  profitTotal: Scalars['Float']['output'];
  profitTotalAbs: Scalars['Float']['output'];
  sharpe?: Maybe<Scalars['Float']['output']>;
  sortino?: Maybe<Scalars['Float']['output']>;
  stakeCurrency: Scalars['String']['output'];
  strategyName: Scalars['String']['output'];
  totalTrades: Scalars['Int']['output'];
  winRate?: Maybe<Scalars['Float']['output']>;
  wins: Scalars['Int']['output'];
};

/** BacktestTaskStatus is enum for the field status */
export enum BacktestTaskStatus {
  Cancelled = 'cancelled',
  Completed = 'completed',
  Failed = 'failed',
  Pending = 'pending',
  Running = 'running'
}

/**
 * BacktestWhereInput is used for filtering Backtest objects.
 * Input was generated by ent.
 */
export type BacktestWhereInput = {
  and?: InputMaybe<Array<BacktestWhereInput>>;
  /** completed_at field predicates */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  completedAtGT?: InputMaybe<Scalars['Time']['input']>;
  completedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  completedAtLT?: InputMaybe<Scalars['Time']['input']>;
  completedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  completedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** end_date field predicates */
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endDateGT?: InputMaybe<Scalars['Time']['input']>;
  endDateGTE?: InputMaybe<Scalars['Time']['input']>;
  endDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  endDateLT?: InputMaybe<Scalars['Time']['input']>;
  endDateLTE?: InputMaybe<Scalars['Time']['input']>;
  endDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  endDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** error_message field predicates */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  errorMessageContains?: InputMaybe<Scalars['String']['input']>;
  errorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageGT?: InputMaybe<Scalars['String']['input']>;
  errorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  errorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  errorMessageLT?: InputMaybe<Scalars['String']['input']>;
  errorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  errorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** runner edge predicates */
  hasRunner?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunnerWith?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** strategy edge predicates */
  hasStrategy?: InputMaybe<Scalars['Boolean']['input']>;
  hasStrategyWith?: InputMaybe<Array<StrategyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** logs field predicates */
  logs?: InputMaybe<Scalars['String']['input']>;
  logsContains?: InputMaybe<Scalars['String']['input']>;
  logsContainsFold?: InputMaybe<Scalars['String']['input']>;
  logsEqualFold?: InputMaybe<Scalars['String']['input']>;
  logsGT?: InputMaybe<Scalars['String']['input']>;
  logsGTE?: InputMaybe<Scalars['String']['input']>;
  logsHasPrefix?: InputMaybe<Scalars['String']['input']>;
  logsHasSuffix?: InputMaybe<Scalars['String']['input']>;
  logsIn?: InputMaybe<Array<Scalars['String']['input']>>;
  logsIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  logsLT?: InputMaybe<Scalars['String']['input']>;
  logsLTE?: InputMaybe<Scalars['String']['input']>;
  logsNEQ?: InputMaybe<Scalars['String']['input']>;
  logsNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  logsNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<BacktestWhereInput>;
  or?: InputMaybe<Array<BacktestWhereInput>>;
  /** runner_id field predicates */
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  runnerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  runnerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** start_date field predicates */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startDateGT?: InputMaybe<Scalars['Time']['input']>;
  startDateGTE?: InputMaybe<Scalars['Time']['input']>;
  startDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  startDateLT?: InputMaybe<Scalars['Time']['input']>;
  startDateLTE?: InputMaybe<Scalars['Time']['input']>;
  startDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  startDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<BacktestTaskStatus>;
  statusIn?: InputMaybe<Array<BacktestTaskStatus>>;
  statusNEQ?: InputMaybe<BacktestTaskStatus>;
  statusNotIn?: InputMaybe<Array<BacktestTaskStatus>>;
  /** strategy_id field predicates */
  strategyID?: InputMaybe<Scalars['ID']['input']>;
  strategyIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  strategyIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  strategyIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type BinanceConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

export type BitfinexConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

export type Bot = Node & {
  __typename?: 'Bot';
  /** Complete freqtrade bot configuration (stake, pairlists, pricing, api_server, etc.) */
  config?: Maybe<Scalars['Map']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** Last error message if status is error */
  errorMessage?: Maybe<Scalars['String']['output']>;
  exchange: Exchange;
  /** Foreign key to exchange (provides credentials) */
  exchangeID: Scalars['ID']['output'];
  /** Freqtrade Docker image version tag */
  freqtradeVersion: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Last successful health check */
  lastSeenAt?: Maybe<Scalars['Time']['output']>;
  metrics?: Maybe<BotMetrics>;
  /** Trading mode (dry-run or live) */
  mode: BotBotMode;
  /** Bot display name */
  name: Scalars['String']['output'];
  /** Group ID (organization) that owns this bot */
  ownerID: Scalars['String']['output'];
  /** Whether this resource is publicly visible to all authenticated users */
  public: Scalars['Boolean']['output'];
  /**
   * Usage summary for the last 24 hours
   * Aggregated from ResourceUsageAggregation if available, or calculated from samples
   * Only populated if the bot runs on a runner with billing enabled
   */
  recentUsage?: Maybe<ResourceUsageAggregation>;
  runner: BotRunner;
  /** Foreign key to runner (provides execution environment) */
  runnerID: Scalars['ID']['output'];
  /** Bot lifecycle status */
  status: BotBotStatus;
  strategy: Strategy;
  /** Foreign key to strategy (provides code) */
  strategyID: Scalars['ID']['output'];
  trades: TradeConnection;
  updatedAt: Scalars['Time']['output'];
};


export type BotTradesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TradeOrder>;
  where?: InputMaybe<TradeWhereInput>;
};

/** BotBotMode is enum for the field mode */
export enum BotBotMode {
  DryRun = 'dry_run',
  Live = 'live'
}

/** BotBotStatus is enum for the field status */
export enum BotBotStatus {
  Backtesting = 'backtesting',
  Creating = 'creating',
  Error = 'error',
  Hyperopt = 'hyperopt',
  Running = 'running',
  Stopped = 'stopped',
  Unhealthy = 'unhealthy'
}

/** A connection to a list of items. */
export type BotConnection = {
  __typename?: 'BotConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BotEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BotEdge = {
  __typename?: 'BotEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Bot>;
};

export type BotMetrics = Node & {
  __typename?: 'BotMetrics';
  /** Best performing trading pair */
  bestPair?: Maybe<Scalars['String']['output']>;
  /** Best trade profit rate */
  bestRate?: Maybe<Scalars['Float']['output']>;
  bot: Bot;
  /** Foreign key to bot (one-to-one) */
  botID: Scalars['ID']['output'];
  /** Number of closed trades */
  closedTradeCount?: Maybe<Scalars['Int']['output']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** Average profit per trade */
  expectancy?: Maybe<Scalars['Float']['output']>;
  /** When these metrics were fetched from Freqtrade API */
  fetchedAt: Scalars['Time']['output'];
  /** Timestamp of first trade */
  firstTradeTimestamp?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** Highest trade ID ever seen - used to detect bot reset (when current max < this) */
  lastKnownMaxTradeID: Scalars['Int']['output'];
  /** Last freqtrade_trade_id synced for incremental fetch */
  lastSyncedTradeID: Scalars['Int']['output'];
  /** Last successful trade sync timestamp */
  lastTradeSyncAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of latest trade */
  latestTradeTimestamp?: Maybe<Scalars['Time']['output']>;
  /** Number of losing trades */
  losingTrades?: Maybe<Scalars['Int']['output']>;
  /** Maximum drawdown percentage */
  maxDrawdown?: Maybe<Scalars['Float']['output']>;
  /** Maximum drawdown absolute value */
  maxDrawdownAbs?: Maybe<Scalars['Float']['output']>;
  /** Current number of open trades */
  openTradeCount?: Maybe<Scalars['Int']['output']>;
  /** Total profit (closed + open) in coin */
  profitAllCoin?: Maybe<Scalars['Float']['output']>;
  /** Total profit (closed + open) percentage */
  profitAllPercent?: Maybe<Scalars['Float']['output']>;
  /** Total closed profit in coin */
  profitClosedCoin?: Maybe<Scalars['Float']['output']>;
  /** Total closed profit percentage */
  profitClosedPercent?: Maybe<Scalars['Float']['output']>;
  /** Ratio of gross profit to gross loss */
  profitFactor?: Maybe<Scalars['Float']['output']>;
  /** Total number of trades */
  tradeCount?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['Time']['output'];
  /** Number of winning trades */
  winningTrades?: Maybe<Scalars['Int']['output']>;
  /** Win rate percentage (0-100) */
  winrate?: Maybe<Scalars['Float']['output']>;
};

/**
 * BotMetricsWhereInput is used for filtering BotMetrics objects.
 * Input was generated by ent.
 */
export type BotMetricsWhereInput = {
  and?: InputMaybe<Array<BotMetricsWhereInput>>;
  /** best_pair field predicates */
  bestPair?: InputMaybe<Scalars['String']['input']>;
  bestPairContains?: InputMaybe<Scalars['String']['input']>;
  bestPairContainsFold?: InputMaybe<Scalars['String']['input']>;
  bestPairEqualFold?: InputMaybe<Scalars['String']['input']>;
  bestPairGT?: InputMaybe<Scalars['String']['input']>;
  bestPairGTE?: InputMaybe<Scalars['String']['input']>;
  bestPairHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bestPairHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bestPairIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bestPairIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bestPairLT?: InputMaybe<Scalars['String']['input']>;
  bestPairLTE?: InputMaybe<Scalars['String']['input']>;
  bestPairNEQ?: InputMaybe<Scalars['String']['input']>;
  bestPairNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bestPairNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** best_rate field predicates */
  bestRate?: InputMaybe<Scalars['Float']['input']>;
  bestRateGT?: InputMaybe<Scalars['Float']['input']>;
  bestRateGTE?: InputMaybe<Scalars['Float']['input']>;
  bestRateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestRateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bestRateLT?: InputMaybe<Scalars['Float']['input']>;
  bestRateLTE?: InputMaybe<Scalars['Float']['input']>;
  bestRateNEQ?: InputMaybe<Scalars['Float']['input']>;
  bestRateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestRateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** bot_id field predicates */
  botID?: InputMaybe<Scalars['ID']['input']>;
  botIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  botIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  botIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** closed_trade_count field predicates */
  closedTradeCount?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountGT?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountGTE?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  closedTradeCountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  closedTradeCountLT?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountLTE?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  closedTradeCountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** expectancy field predicates */
  expectancy?: InputMaybe<Scalars['Float']['input']>;
  expectancyGT?: InputMaybe<Scalars['Float']['input']>;
  expectancyGTE?: InputMaybe<Scalars['Float']['input']>;
  expectancyIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  expectancyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  expectancyLT?: InputMaybe<Scalars['Float']['input']>;
  expectancyLTE?: InputMaybe<Scalars['Float']['input']>;
  expectancyNEQ?: InputMaybe<Scalars['Float']['input']>;
  expectancyNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  expectancyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** fetched_at field predicates */
  fetchedAt?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtGT?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  fetchedAtLT?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** first_trade_timestamp field predicates */
  firstTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampGT?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampGTE?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  firstTradeTimestampIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  firstTradeTimestampLT?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampLTE?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampNEQ?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  firstTradeTimestampNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** bot edge predicates */
  hasBot?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_known_max_trade_id field predicates */
  lastKnownMaxTradeID?: InputMaybe<Scalars['Int']['input']>;
  lastKnownMaxTradeIDGT?: InputMaybe<Scalars['Int']['input']>;
  lastKnownMaxTradeIDGTE?: InputMaybe<Scalars['Int']['input']>;
  lastKnownMaxTradeIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  lastKnownMaxTradeIDLT?: InputMaybe<Scalars['Int']['input']>;
  lastKnownMaxTradeIDLTE?: InputMaybe<Scalars['Int']['input']>;
  lastKnownMaxTradeIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  lastKnownMaxTradeIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** last_synced_trade_id field predicates */
  lastSyncedTradeID?: InputMaybe<Scalars['Int']['input']>;
  lastSyncedTradeIDGT?: InputMaybe<Scalars['Int']['input']>;
  lastSyncedTradeIDGTE?: InputMaybe<Scalars['Int']['input']>;
  lastSyncedTradeIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  lastSyncedTradeIDLT?: InputMaybe<Scalars['Int']['input']>;
  lastSyncedTradeIDLTE?: InputMaybe<Scalars['Int']['input']>;
  lastSyncedTradeIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  lastSyncedTradeIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** last_trade_sync_at field predicates */
  lastTradeSyncAt?: InputMaybe<Scalars['Time']['input']>;
  lastTradeSyncAtGT?: InputMaybe<Scalars['Time']['input']>;
  lastTradeSyncAtGTE?: InputMaybe<Scalars['Time']['input']>;
  lastTradeSyncAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastTradeSyncAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastTradeSyncAtLT?: InputMaybe<Scalars['Time']['input']>;
  lastTradeSyncAtLTE?: InputMaybe<Scalars['Time']['input']>;
  lastTradeSyncAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastTradeSyncAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastTradeSyncAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** latest_trade_timestamp field predicates */
  latestTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampGT?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampGTE?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  latestTradeTimestampIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  latestTradeTimestampLT?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampLTE?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampNEQ?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  latestTradeTimestampNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** losing_trades field predicates */
  losingTrades?: InputMaybe<Scalars['Int']['input']>;
  losingTradesGT?: InputMaybe<Scalars['Int']['input']>;
  losingTradesGTE?: InputMaybe<Scalars['Int']['input']>;
  losingTradesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  losingTradesIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  losingTradesLT?: InputMaybe<Scalars['Int']['input']>;
  losingTradesLTE?: InputMaybe<Scalars['Int']['input']>;
  losingTradesNEQ?: InputMaybe<Scalars['Int']['input']>;
  losingTradesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  losingTradesNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** max_drawdown field predicates */
  maxDrawdown?: InputMaybe<Scalars['Float']['input']>;
  /** max_drawdown_abs field predicates */
  maxDrawdownAbs?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsGT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsGTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownAbsIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  maxDrawdownAbsLT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsLTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsNEQ?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownAbsNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  maxDrawdownGT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownGTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  maxDrawdownLT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownLTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownNEQ?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<BotMetricsWhereInput>;
  /** open_trade_count field predicates */
  openTradeCount?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountGT?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountGTE?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  openTradeCountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  openTradeCountLT?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountLTE?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  openTradeCountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<BotMetricsWhereInput>>;
  /** profit_all_coin field predicates */
  profitAllCoin?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinGT?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinGTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllCoinIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitAllCoinLT?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinLTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllCoinNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_all_percent field predicates */
  profitAllPercent?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentGT?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentGTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllPercentIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitAllPercentLT?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentLTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllPercentNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_closed_coin field predicates */
  profitClosedCoin?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinGT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinGTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedCoinIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitClosedCoinLT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinLTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedCoinNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_closed_percent field predicates */
  profitClosedPercent?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentGT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentGTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedPercentIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitClosedPercentLT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentLTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedPercentNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_factor field predicates */
  profitFactor?: InputMaybe<Scalars['Float']['input']>;
  profitFactorGT?: InputMaybe<Scalars['Float']['input']>;
  profitFactorGTE?: InputMaybe<Scalars['Float']['input']>;
  profitFactorIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitFactorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitFactorLT?: InputMaybe<Scalars['Float']['input']>;
  profitFactorLTE?: InputMaybe<Scalars['Float']['input']>;
  profitFactorNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitFactorNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitFactorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** trade_count field predicates */
  tradeCount?: InputMaybe<Scalars['Int']['input']>;
  tradeCountGT?: InputMaybe<Scalars['Int']['input']>;
  tradeCountGTE?: InputMaybe<Scalars['Int']['input']>;
  tradeCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  tradeCountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  tradeCountLT?: InputMaybe<Scalars['Int']['input']>;
  tradeCountLTE?: InputMaybe<Scalars['Int']['input']>;
  tradeCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  tradeCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  tradeCountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** winning_trades field predicates */
  winningTrades?: InputMaybe<Scalars['Int']['input']>;
  winningTradesGT?: InputMaybe<Scalars['Int']['input']>;
  winningTradesGTE?: InputMaybe<Scalars['Int']['input']>;
  winningTradesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  winningTradesIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  winningTradesLT?: InputMaybe<Scalars['Int']['input']>;
  winningTradesLTE?: InputMaybe<Scalars['Int']['input']>;
  winningTradesNEQ?: InputMaybe<Scalars['Int']['input']>;
  winningTradesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  winningTradesNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** winrate field predicates */
  winrate?: InputMaybe<Scalars['Float']['input']>;
  winrateGT?: InputMaybe<Scalars['Float']['input']>;
  winrateGTE?: InputMaybe<Scalars['Float']['input']>;
  winrateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  winrateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  winrateLT?: InputMaybe<Scalars['Float']['input']>;
  winrateLTE?: InputMaybe<Scalars['Float']['input']>;
  winrateNEQ?: InputMaybe<Scalars['Float']['input']>;
  winrateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  winrateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BotRunner = Node & {
  __typename?: 'BotRunner';
  backtests: BacktestConnection;
  /** Whether usage tracking and billing is enabled for this runner */
  billingEnabled: Scalars['Boolean']['output'];
  bots: BotConnection;
  /** Runner connection configuration (host, port, credentials, etc.) */
  config?: Maybe<Scalars['Map']['output']>;
  /** Price per core-hour in USD (only used if billing_enabled) */
  cpuPricePerCoreHour?: Maybe<Scalars['Float']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Data download configuration: {exchanges: [{name, enabled, timeframes, pairs_pattern, days, trading_mode}]} */
  dataDownloadConfig?: Maybe<Scalars['Map']['output']>;
  /** Progress details: {pairs_completed, pairs_total, current_pair, percent_complete} */
  dataDownloadProgress?: Maybe<Scalars['Map']['output']>;
  /** When the current data download started (for stuck detection) */
  dataDownloadStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Current data download status (idle, downloading, completed, failed) */
  dataDownloadStatus: BotRunnerDataDownloadStatus;
  /** Error message if data download failed */
  dataErrorMessage?: Maybe<Scalars['String']['output']>;
  /** Whether runner has downloaded historical data for backtesting */
  dataIsReady: Scalars['Boolean']['output'];
  /** When data was last refreshed */
  dataLastUpdated?: Maybe<Scalars['Time']['output']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** Price per GB-hour in USD (only used if billing_enabled) */
  memoryPricePerGBHour?: Maybe<Scalars['Float']['output']>;
  /** Runner display name */
  name: Scalars['String']['output'];
  /** Price per GB of network transfer in USD (only used if billing_enabled) */
  networkPricePerGB?: Maybe<Scalars['Float']['output']>;
  /** Group ID (organization) that owns this bot runner */
  ownerID: Scalars['String']['output'];
  /** Whether this resource is publicly visible to all authenticated users */
  public: Scalars['Boolean']['output'];
  /** S3 config: {endpoint, bucket, accessKeyId, secretAccessKey, region, forcePathStyle, useSSL} */
  s3Config?: Maybe<Scalars['Map']['output']>;
  /** S3 object key: runners/data/{runnerId}.zip */
  s3DataKey?: Maybe<Scalars['String']['output']>;
  /** When data was last uploaded to S3 */
  s3DataUploadedAt?: Maybe<Scalars['Time']['output']>;
  /** Price per GB of disk I/O in USD (only used if billing_enabled) */
  storagePricePerGB?: Maybe<Scalars['Float']['output']>;
  /** Runner environment type (docker, kubernetes, local) */
  type: BotRunnerRunnerType;
  updatedAt: Scalars['Time']['output'];
};


export type BotRunnerBacktestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BacktestWhereInput>;
};


export type BotRunnerBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};

/** A connection to a list of items. */
export type BotRunnerConnection = {
  __typename?: 'BotRunnerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BotRunnerEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** BotRunnerDataDownloadStatus is enum for the field data_download_status */
export enum BotRunnerDataDownloadStatus {
  Completed = 'completed',
  Downloading = 'downloading',
  Failed = 'failed',
  Idle = 'idle',
  Packaging = 'packaging',
  Pending = 'pending',
  Uploading = 'uploading'
}

/** An edge in a connection. */
export type BotRunnerEdge = {
  __typename?: 'BotRunnerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BotRunner>;
};

/** BotRunnerRunnerType is enum for the field type */
export enum BotRunnerRunnerType {
  Docker = 'docker',
  Kubernetes = 'kubernetes',
  Local = 'local'
}

/**
 * BotRunnerWhereInput is used for filtering BotRunner objects.
 * Input was generated by ent.
 */
export type BotRunnerWhereInput = {
  and?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** billing_enabled field predicates */
  billingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  billingEnabledNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** cpu_price_per_core_hour field predicates */
  cpuPricePerCoreHour?: InputMaybe<Scalars['Float']['input']>;
  cpuPricePerCoreHourGT?: InputMaybe<Scalars['Float']['input']>;
  cpuPricePerCoreHourGTE?: InputMaybe<Scalars['Float']['input']>;
  cpuPricePerCoreHourIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  cpuPricePerCoreHourIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cpuPricePerCoreHourLT?: InputMaybe<Scalars['Float']['input']>;
  cpuPricePerCoreHourLTE?: InputMaybe<Scalars['Float']['input']>;
  cpuPricePerCoreHourNEQ?: InputMaybe<Scalars['Float']['input']>;
  cpuPricePerCoreHourNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  cpuPricePerCoreHourNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** data_download_started_at field predicates */
  dataDownloadStartedAt?: InputMaybe<Scalars['Time']['input']>;
  dataDownloadStartedAtGT?: InputMaybe<Scalars['Time']['input']>;
  dataDownloadStartedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  dataDownloadStartedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dataDownloadStartedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dataDownloadStartedAtLT?: InputMaybe<Scalars['Time']['input']>;
  dataDownloadStartedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  dataDownloadStartedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  dataDownloadStartedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dataDownloadStartedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** data_download_status field predicates */
  dataDownloadStatus?: InputMaybe<BotRunnerDataDownloadStatus>;
  dataDownloadStatusIn?: InputMaybe<Array<BotRunnerDataDownloadStatus>>;
  dataDownloadStatusNEQ?: InputMaybe<BotRunnerDataDownloadStatus>;
  dataDownloadStatusNotIn?: InputMaybe<Array<BotRunnerDataDownloadStatus>>;
  /** data_error_message field predicates */
  dataErrorMessage?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageContains?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageGT?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dataErrorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dataErrorMessageLT?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dataErrorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** data_is_ready field predicates */
  dataIsReady?: InputMaybe<Scalars['Boolean']['input']>;
  dataIsReadyNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** data_last_updated field predicates */
  dataLastUpdated?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedGT?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedGTE?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dataLastUpdatedIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dataLastUpdatedLT?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedLTE?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedNEQ?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dataLastUpdatedNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** backtests edge predicates */
  hasBacktests?: InputMaybe<Scalars['Boolean']['input']>;
  hasBacktestsWith?: InputMaybe<Array<BacktestWhereInput>>;
  /** bots edge predicates */
  hasBots?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotsWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** memory_price_per_gb_hour field predicates */
  memoryPricePerGBHour?: InputMaybe<Scalars['Float']['input']>;
  memoryPricePerGBHourGT?: InputMaybe<Scalars['Float']['input']>;
  memoryPricePerGBHourGTE?: InputMaybe<Scalars['Float']['input']>;
  memoryPricePerGBHourIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  memoryPricePerGBHourIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  memoryPricePerGBHourLT?: InputMaybe<Scalars['Float']['input']>;
  memoryPricePerGBHourLTE?: InputMaybe<Scalars['Float']['input']>;
  memoryPricePerGBHourNEQ?: InputMaybe<Scalars['Float']['input']>;
  memoryPricePerGBHourNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  memoryPricePerGBHourNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** network_price_per_gb field predicates */
  networkPricePerGB?: InputMaybe<Scalars['Float']['input']>;
  networkPricePerGBGT?: InputMaybe<Scalars['Float']['input']>;
  networkPricePerGBGTE?: InputMaybe<Scalars['Float']['input']>;
  networkPricePerGBIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  networkPricePerGBIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  networkPricePerGBLT?: InputMaybe<Scalars['Float']['input']>;
  networkPricePerGBLTE?: InputMaybe<Scalars['Float']['input']>;
  networkPricePerGBNEQ?: InputMaybe<Scalars['Float']['input']>;
  networkPricePerGBNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  networkPricePerGBNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<BotRunnerWhereInput>;
  or?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  ownerIDContains?: InputMaybe<Scalars['String']['input']>;
  ownerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDGT?: InputMaybe<Scalars['String']['input']>;
  ownerIDGTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ownerIDLT?: InputMaybe<Scalars['String']['input']>;
  ownerIDLTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** public field predicates */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  publicNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** s3_data_key field predicates */
  s3DataKey?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyContains?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyGT?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyGTE?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  s3DataKeyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  s3DataKeyLT?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyLTE?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  s3DataKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  s3DataKeyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** s3_data_uploaded_at field predicates */
  s3DataUploadedAt?: InputMaybe<Scalars['Time']['input']>;
  s3DataUploadedAtGT?: InputMaybe<Scalars['Time']['input']>;
  s3DataUploadedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  s3DataUploadedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  s3DataUploadedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  s3DataUploadedAtLT?: InputMaybe<Scalars['Time']['input']>;
  s3DataUploadedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  s3DataUploadedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  s3DataUploadedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  s3DataUploadedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** storage_price_per_gb field predicates */
  storagePricePerGB?: InputMaybe<Scalars['Float']['input']>;
  storagePricePerGBGT?: InputMaybe<Scalars['Float']['input']>;
  storagePricePerGBGTE?: InputMaybe<Scalars['Float']['input']>;
  storagePricePerGBIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  storagePricePerGBIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  storagePricePerGBLT?: InputMaybe<Scalars['Float']['input']>;
  storagePricePerGBLTE?: InputMaybe<Scalars['Float']['input']>;
  storagePricePerGBNEQ?: InputMaybe<Scalars['Float']['input']>;
  storagePricePerGBNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  storagePricePerGBNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** type field predicates */
  type?: InputMaybe<BotRunnerRunnerType>;
  typeIn?: InputMaybe<Array<BotRunnerRunnerType>>;
  typeNEQ?: InputMaybe<BotRunnerRunnerType>;
  typeNotIn?: InputMaybe<Array<BotRunnerRunnerType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type BotStatus = {
  __typename?: 'BotStatus';
  botID: Scalars['String']['output'];
  cpuUsage: Scalars['Float']['output'];
  createdAt: Scalars['Time']['output'];
  errorMessage: Scalars['String']['output'];
  healthy: Scalars['Boolean']['output'];
  hostPort: Scalars['Int']['output'];
  ipAddress: Scalars['String']['output'];
  lastSeenAt?: Maybe<Scalars['Time']['output']>;
  memoryUsage: Scalars['Int']['output'];
  startedAt?: Maybe<Scalars['Time']['output']>;
  status: BotBotStatus;
  stoppedAt?: Maybe<Scalars['Time']['output']>;
};

/**
 * BotWhereInput is used for filtering Bot objects.
 * Input was generated by ent.
 */
export type BotWhereInput = {
  and?: InputMaybe<Array<BotWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** error_message field predicates */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  errorMessageContains?: InputMaybe<Scalars['String']['input']>;
  errorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageGT?: InputMaybe<Scalars['String']['input']>;
  errorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  errorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  errorMessageLT?: InputMaybe<Scalars['String']['input']>;
  errorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  errorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** exchange_id field predicates */
  exchangeID?: InputMaybe<Scalars['ID']['input']>;
  exchangeIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  exchangeIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  exchangeIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** freqtrade_version field predicates */
  freqtradeVersion?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionContains?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionContainsFold?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionEqualFold?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionGT?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionGTE?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  freqtradeVersionLT?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionLTE?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionNEQ?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** exchange edge predicates */
  hasExchange?: InputMaybe<Scalars['Boolean']['input']>;
  hasExchangeWith?: InputMaybe<Array<ExchangeWhereInput>>;
  /** metrics edge predicates */
  hasMetrics?: InputMaybe<Scalars['Boolean']['input']>;
  hasMetricsWith?: InputMaybe<Array<BotMetricsWhereInput>>;
  /** runner edge predicates */
  hasRunner?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunnerWith?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** strategy edge predicates */
  hasStrategy?: InputMaybe<Scalars['Boolean']['input']>;
  hasStrategyWith?: InputMaybe<Array<StrategyWhereInput>>;
  /** trades edge predicates */
  hasTrades?: InputMaybe<Scalars['Boolean']['input']>;
  hasTradesWith?: InputMaybe<Array<TradeWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_seen_at field predicates */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtGT?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtGTE?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSeenAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastSeenAtLT?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtLTE?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSeenAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** mode field predicates */
  mode?: InputMaybe<BotBotMode>;
  modeIn?: InputMaybe<Array<BotBotMode>>;
  modeNEQ?: InputMaybe<BotBotMode>;
  modeNotIn?: InputMaybe<Array<BotBotMode>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<BotWhereInput>;
  or?: InputMaybe<Array<BotWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  ownerIDContains?: InputMaybe<Scalars['String']['input']>;
  ownerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDGT?: InputMaybe<Scalars['String']['input']>;
  ownerIDGTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ownerIDLT?: InputMaybe<Scalars['String']['input']>;
  ownerIDLTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** public field predicates */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  publicNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** runner_id field predicates */
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  runnerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  runnerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** status field predicates */
  status?: InputMaybe<BotBotStatus>;
  statusIn?: InputMaybe<Array<BotBotStatus>>;
  statusNEQ?: InputMaybe<BotBotStatus>;
  statusNotIn?: InputMaybe<Array<BotBotStatus>>;
  /** strategy_id field predicates */
  strategyID?: InputMaybe<Scalars['ID']['input']>;
  strategyIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  strategyIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  strategyIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type BybitConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

/** Describes a configurable condition field for an alert type */
export type ConditionField = {
  __typename?: 'ConditionField';
  /** For number fields: default value */
  default?: Maybe<Scalars['Float']['output']>;
  description: Scalars['String']['output'];
  label: Scalars['String']['output'];
  /** For number fields: maximum value */
  max?: Maybe<Scalars['Float']['output']>;
  /** For number fields: minimum value */
  min?: Maybe<Scalars['Float']['output']>;
  name: Scalars['String']['output'];
  /** For select/multi_select fields: available options */
  options?: Maybe<Array<SelectOption>>;
  required: Scalars['Boolean']['output'];
  type: ConditionFieldType;
  /** For number fields: unit label (e.g., "%", "minutes") */
  unit?: Maybe<Scalars['String']['output']>;
};

/** Type of condition field for alert configuration */
export enum ConditionFieldType {
  MultiSelect = 'multi_select',
  Number = 'number',
  Select = 'select'
}

export type ConnectionTestResult = {
  __typename?: 'ConnectionTestResult';
  message: Scalars['String']['output'];
  success: Scalars['Boolean']['output'];
  version?: Maybe<Scalars['String']['output']>;
};

/**
 * CreateAlertRuleInput is used for create AlertRule object.
 * Input was generated by ent.
 */
export type CreateAlertRuleInput = {
  /** Type of alert: status_change, trade_opened, trade_closed, etc. */
  alertType: AlertRuleAlertType;
  /** Batch window in minutes (only used if delivery_mode=batched) */
  batchIntervalMinutes?: InputMaybe<Scalars['Int']['input']>;
  /** Filter by bot trading mode: all, live, dry_run */
  botModeFilter?: InputMaybe<AlertRuleAlertBotModeFilter>;
  /** Condition parameters: thresholds, status values, etc. */
  conditions?: InputMaybe<Scalars['Map']['input']>;
  /** Minimum minutes between alerts of same type for same resource */
  cooldownMinutes?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Delivery mode: immediate or batched */
  deliveryMode?: InputMaybe<AlertRuleAlertDeliveryMode>;
  /** Whether this rule is active */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  eventIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** When this rule last triggered (for cooldown calculation) */
  lastTriggeredAt?: InputMaybe<Scalars['Time']['input']>;
  /** Human-readable rule name (e.g., 'Bot Error Alert') */
  name: Scalars['String']['input'];
  /** Organization ID that owns this rule */
  ownerID: Scalars['String']['input'];
  /** List of recipient email addresses */
  recipients?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Specific resource ID (null for org-level rules that apply to all resources) */
  resourceID?: InputMaybe<Scalars['ID']['input']>;
  /** Type of resource: organization, bot, strategy, runner */
  resourceType: AlertRuleAlertResourceType;
  /** Alert severity: critical, warning, info */
  severity?: InputMaybe<AlertRuleAlertSeverity>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBacktestInput is used for create Backtest object.
 * Input was generated by ent.
 */
export type CreateBacktestInput = {
  /** Completion timestamp */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Backtest end date (end of time range) */
  endDate?: InputMaybe<Scalars['Time']['input']>;
  /** Error message if backtest failed */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Container logs from backtest execution */
  logs?: InputMaybe<Scalars['String']['input']>;
  /** Backtest result data (metrics, logs, trades, etc.) */
  result?: InputMaybe<Scalars['Map']['input']>;
  runnerID: Scalars['ID']['input'];
  /** Backtest start date (beginning of time range) */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  /** Task status */
  status?: InputMaybe<BacktestTaskStatus>;
  strategyID: Scalars['ID']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBotInput is used for create Bot object.
 * Input was generated by ent.
 */
export type CreateBotInput = {
  /** Complete freqtrade bot configuration (stake, pairlists, pricing, api_server, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Last error message if status is error */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  exchangeID: Scalars['ID']['input'];
  /** Freqtrade Docker image version tag */
  freqtradeVersion?: InputMaybe<Scalars['String']['input']>;
  /** Last successful health check */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>;
  metricsID?: InputMaybe<Scalars['ID']['input']>;
  /** Trading mode (dry-run or live) */
  mode?: InputMaybe<BotBotMode>;
  /** Bot display name */
  name: Scalars['String']['input'];
  /** Group ID (organization) that owns this bot */
  ownerID: Scalars['String']['input'];
  /** Whether this resource is publicly visible to all authenticated users */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  runnerID: Scalars['ID']['input'];
  /** Bot lifecycle status */
  status?: InputMaybe<BotBotStatus>;
  strategyID: Scalars['ID']['input'];
  tradeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBotMetricsInput is used for create BotMetrics object.
 * Input was generated by ent.
 */
export type CreateBotMetricsInput = {
  /** Best performing trading pair */
  bestPair?: InputMaybe<Scalars['String']['input']>;
  /** Best trade profit rate */
  bestRate?: InputMaybe<Scalars['Float']['input']>;
  botID: Scalars['ID']['input'];
  /** Number of closed trades */
  closedTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Average profit per trade */
  expectancy?: InputMaybe<Scalars['Float']['input']>;
  /** When these metrics were fetched from Freqtrade API */
  fetchedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of first trade */
  firstTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Highest trade ID ever seen - used to detect bot reset (when current max < this) */
  lastKnownMaxTradeID?: InputMaybe<Scalars['Int']['input']>;
  /** Last freqtrade_trade_id synced for incremental fetch */
  lastSyncedTradeID?: InputMaybe<Scalars['Int']['input']>;
  /** Last successful trade sync timestamp */
  lastTradeSyncAt?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of latest trade */
  latestTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Number of losing trades */
  losingTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum drawdown percentage */
  maxDrawdown?: InputMaybe<Scalars['Float']['input']>;
  /** Maximum drawdown absolute value */
  maxDrawdownAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Current number of open trades */
  openTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Total profit (closed + open) in coin */
  profitAllCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total profit (closed + open) percentage */
  profitAllPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit in coin */
  profitClosedCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit percentage */
  profitClosedPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Ratio of gross profit to gross loss */
  profitFactor?: InputMaybe<Scalars['Float']['input']>;
  /** Total number of trades */
  tradeCount?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Number of winning trades */
  winningTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Win rate percentage (0-100) */
  winrate?: InputMaybe<Scalars['Float']['input']>;
};

/**
 * CreateBotRunnerInput is used for create BotRunner object.
 * Input was generated by ent.
 */
export type CreateBotRunnerInput = {
  backtestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Whether usage tracking and billing is enabled for this runner */
  billingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  botIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Runner connection configuration (host, port, credentials, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Price per core-hour in USD (only used if billing_enabled) */
  cpuPricePerCoreHour?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Data download configuration: {exchanges: [{name, enabled, timeframes, pairs_pattern, days, trading_mode}]} */
  dataDownloadConfig?: InputMaybe<Scalars['Map']['input']>;
  /** Progress details: {pairs_completed, pairs_total, current_pair, percent_complete} */
  dataDownloadProgress?: InputMaybe<Scalars['Map']['input']>;
  /** When the current data download started (for stuck detection) */
  dataDownloadStartedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Current data download status (idle, downloading, completed, failed) */
  dataDownloadStatus?: InputMaybe<BotRunnerDataDownloadStatus>;
  /** Error message if data download failed */
  dataErrorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Whether runner has downloaded historical data for backtesting */
  dataIsReady?: InputMaybe<Scalars['Boolean']['input']>;
  /** When data was last refreshed */
  dataLastUpdated?: InputMaybe<Scalars['Time']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Price per GB-hour in USD (only used if billing_enabled) */
  memoryPricePerGBHour?: InputMaybe<Scalars['Float']['input']>;
  /** Runner display name */
  name: Scalars['String']['input'];
  /** Price per GB of network transfer in USD (only used if billing_enabled) */
  networkPricePerGB?: InputMaybe<Scalars['Float']['input']>;
  /** Group ID (organization) that owns this bot runner */
  ownerID: Scalars['String']['input'];
  /** Whether this resource is publicly visible to all authenticated users */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** S3 config: {endpoint, bucket, accessKeyId, secretAccessKey, region, forcePathStyle, useSSL} */
  s3Config?: InputMaybe<Scalars['Map']['input']>;
  /** S3 object key: runners/data/{runnerId}.zip */
  s3DataKey?: InputMaybe<Scalars['String']['input']>;
  /** When data was last uploaded to S3 */
  s3DataUploadedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Price per GB of disk I/O in USD (only used if billing_enabled) */
  storagePricePerGB?: InputMaybe<Scalars['Float']['input']>;
  /** Runner environment type (docker, kubernetes, local) */
  type?: InputMaybe<BotRunnerRunnerType>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateExchangeInput is used for create Exchange object.
 * Input was generated by ent.
 */
export type CreateExchangeInput = {
  botIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Complete freqtrade exchange configuration (name, key, secret, pair_whitelist, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Exchange display name (e.g., 'Binance Production', 'Coinbase Testnet') */
  name: Scalars['String']['input'];
  /** Group ID (organization) that owns this exchange */
  ownerID: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateStrategyInput is used for create Strategy object.
 * Input was generated by ent.
 */
export type CreateStrategyInput = {
  backtestID?: InputMaybe<Scalars['ID']['input']>;
  botIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  childIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Python strategy code */
  code: Scalars['String']['input'];
  /** Strategy-specific configuration (config.json) - REQUIRED */
  config: Scalars['Map']['input'];
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Strategy description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if this is the latest version of the strategy */
  isLatest?: InputMaybe<Scalars['Boolean']['input']>;
  /** Strategy name (not unique, allows versions) */
  name: Scalars['String']['input'];
  /** Group ID (organization) that owns this strategy */
  ownerID: Scalars['String']['input'];
  parentID?: InputMaybe<Scalars['ID']['input']>;
  /** Whether this resource is publicly visible to all authenticated users */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Auto-incremented version number */
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * CreateTradeInput is used for create Trade object.
 * Input was generated by ent.
 */
export type CreateTradeInput = {
  /** Amount of coins */
  amount: Scalars['Float']['input'];
  botID: Scalars['ID']['input'];
  /** Trade close time */
  closeDate?: InputMaybe<Scalars['Time']['input']>;
  /** Exit price */
  closeRate?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Original trade ID from freqtrade */
  freqtradeTradeID: Scalars['Int']['input'];
  /** Trade open status */
  isOpen?: InputMaybe<Scalars['Boolean']['input']>;
  /** Trade open time */
  openDate: Scalars['Time']['input'];
  /** Entry price */
  openRate: Scalars['Float']['input'];
  /** Trading pair (BTC/USDT) */
  pair: Scalars['String']['input'];
  /** Absolute profit */
  profitAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Profit percentage (0.05 = 5%) */
  profitRatio?: InputMaybe<Scalars['Float']['input']>;
  /** Reason for selling (roi, stoploss, etc.) */
  sellReason?: InputMaybe<Scalars['String']['input']>;
  /** Stake in base currency */
  stakeAmount: Scalars['Float']['input'];
  /** Strategy used */
  strategyName?: InputMaybe<Scalars['String']['input']>;
  /** Timeframe used */
  timeframe?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

export type DataDownloadConfigInput = {
  exchanges: Array<DataDownloadExchangeConfigInput>;
};

export type DataDownloadExchangeConfigInput = {
  days?: InputMaybe<Scalars['Int']['input']>;
  enabled: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  pairsPattern?: InputMaybe<Scalars['String']['input']>;
  timeframes?: InputMaybe<Array<Scalars['String']['input']>>;
  tradingMode?: InputMaybe<Scalars['String']['input']>;
};

export type DockerConfigInput = {
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  caPEM?: InputMaybe<Scalars['String']['input']>;
  certPEM?: InputMaybe<Scalars['String']['input']>;
  host: Scalars['String']['input'];
  keyPEM?: InputMaybe<Scalars['String']['input']>;
  network?: InputMaybe<Scalars['String']['input']>;
  registryAuth?: InputMaybe<RegistryAuthInput>;
  tlsVerify?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Exchange = Node & {
  __typename?: 'Exchange';
  bots: BotConnection;
  /** Complete freqtrade exchange configuration (name, key, secret, pair_whitelist, etc.) */
  config?: Maybe<Scalars['Map']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** Exchange display name (e.g., 'Binance Production', 'Coinbase Testnet') */
  name: Scalars['String']['output'];
  /** Group ID (organization) that owns this exchange */
  ownerID: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};


export type ExchangeBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};

export type ExchangeConfigInput = {
  binance?: InputMaybe<BinanceConfigInput>;
  binanceus?: InputMaybe<BinanceConfigInput>;
  bitfinex?: InputMaybe<BitfinexConfigInput>;
  bybit?: InputMaybe<BybitConfigInput>;
  coinbase?: InputMaybe<PassphraseExchangeConfigInput>;
  kraken?: InputMaybe<KrakenConfigInput>;
  kucoin?: InputMaybe<PassphraseExchangeConfigInput>;
  okx?: InputMaybe<PassphraseExchangeConfigInput>;
};

/** A connection to a list of items. */
export type ExchangeConnection = {
  __typename?: 'ExchangeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExchangeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ExchangeEdge = {
  __typename?: 'ExchangeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Exchange>;
};

/**
 * ExchangeWhereInput is used for filtering Exchange objects.
 * Input was generated by ent.
 */
export type ExchangeWhereInput = {
  and?: InputMaybe<Array<ExchangeWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** bots edge predicates */
  hasBots?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotsWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ExchangeWhereInput>;
  or?: InputMaybe<Array<ExchangeWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  ownerIDContains?: InputMaybe<Scalars['String']['input']>;
  ownerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDGT?: InputMaybe<Scalars['String']['input']>;
  ownerIDGTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ownerIDLT?: InputMaybe<Scalars['String']['input']>;
  ownerIDLTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type FreqtradeToken = {
  __typename?: 'FreqtradeToken';
  /** JWT access token for bot API authentication */
  accessToken: Scalars['String']['output'];
  /** The bot API URL to connect to */
  apiUrl: Scalars['String']['output'];
  /** JWT refresh token for renewing access */
  refreshToken: Scalars['String']['output'];
  /** Username for the bot API */
  username: Scalars['String']['output'];
};

export type KrakenConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

export type KubernetesConfigInput = {
  context?: InputMaybe<Scalars['String']['input']>;
  freqtradeImage?: InputMaybe<Scalars['String']['input']>;
  ingressClass?: InputMaybe<Scalars['String']['input']>;
  ingressHost?: InputMaybe<Scalars['String']['input']>;
  ingressTls?: InputMaybe<Scalars['Boolean']['input']>;
  kubeconfig?: InputMaybe<Scalars['String']['input']>;
  namespace: Scalars['String']['input'];
  prometheusUrl?: InputMaybe<Scalars['String']['input']>;
  sharedDataPVC?: InputMaybe<Scalars['String']['input']>;
  storageClassName?: InputMaybe<Scalars['String']['input']>;
};

export type LocalConfigInput = {
  basePath?: InputMaybe<Scalars['String']['input']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Create a new alert rule */
  createAlertRule: AlertRule;
  createBot: Bot;
  createBotRunner: BotRunner;
  createExchange: Exchange;
  createStrategy: Strategy;
  createTrade: Trade;
  /**
   * Delete an alert rule (soft delete)
   * Associated events are preserved for audit
   */
  deleteAlertRule: Scalars['Boolean']['output'];
  deleteBacktest: Scalars['Boolean']['output'];
  deleteBot: Scalars['Boolean']['output'];
  deleteBotRunner: Scalars['Boolean']['output'];
  deleteExchange: Scalars['Boolean']['output'];
  deleteStrategy: Scalars['Boolean']['output'];
  deleteTrade: Scalars['Boolean']['output'];
  /**
   * Get Freqtrade API token for a bot (for FreqUI authentication)
   * Backend authenticates with bot API and returns JWT tokens
   * This avoids exposing bot credentials to the frontend
   */
  getFreqtradeToken: FreqtradeToken;
  /**
   * Mark a single alert event as read
   * Sets readAt to current timestamp
   * Only marks alert if it belongs to the specified organization
   */
  markAlertEventAsRead: AlertEvent;
  /**
   * Mark all unread alert events as read for an organization
   * Returns the count of events marked as read
   */
  markAllAlertEventsAsRead: Scalars['Int']['output'];
  refreshRunnerData: BotRunner;
  restartBot: Bot;
  runBacktest: Backtest;
  /**
   * Toggle bot visibility (public/private)
   * Only the owner can change visibility
   */
  setBotVisibility: Bot;
  /**
   * Toggle runner visibility (public/private)
   * Only the owner can change visibility
   */
  setRunnerVisibility: BotRunner;
  /**
   * Toggle strategy visibility (public/private)
   * Only the owner can change visibility
   */
  setStrategyVisibility: Strategy;
  startBot: Bot;
  stopBacktest: Backtest;
  stopBot: Bot;
  /**
   * Test an alert rule by simulating an event
   * Sends a test alert to configured recipients
   */
  testAlertRule: Scalars['Boolean']['output'];
  testRunnerConnection: ConnectionTestResult;
  /**
   * Test S3 storage connection
   * Verifies endpoint accessibility and bucket existence
   */
  testS3Connection: ConnectionTestResult;
  /**
   * Toggle alert rule enabled/disabled state
   * Quick toggle without full update
   */
  toggleAlertRule: AlertRule;
  /** Update an existing alert rule */
  updateAlertRule: AlertRule;
  updateBot: Bot;
  updateBotRunner: BotRunner;
  updateExchange: Exchange;
  updateStrategy: Strategy;
  updateTrade: Trade;
};


export type MutationCreateAlertRuleArgs = {
  input: CreateAlertRuleInput;
};


export type MutationCreateBotArgs = {
  input: CreateBotInput;
};


export type MutationCreateBotRunnerArgs = {
  input: CreateBotRunnerInput;
};


export type MutationCreateExchangeArgs = {
  input: CreateExchangeInput;
};


export type MutationCreateStrategyArgs = {
  input: CreateStrategyInput;
};


export type MutationCreateTradeArgs = {
  input: CreateTradeInput;
};


export type MutationDeleteAlertRuleArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteBacktestArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteBotRunnerArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteExchangeArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteStrategyArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteTradeArgs = {
  id: Scalars['ID']['input'];
};


export type MutationGetFreqtradeTokenArgs = {
  botId: Scalars['ID']['input'];
};


export type MutationMarkAlertEventAsReadArgs = {
  id: Scalars['ID']['input'];
  ownerID: Scalars['String']['input'];
};


export type MutationMarkAllAlertEventsAsReadArgs = {
  ownerID: Scalars['String']['input'];
};


export type MutationRefreshRunnerDataArgs = {
  id: Scalars['ID']['input'];
};


export type MutationRestartBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationRunBacktestArgs = {
  input: CreateBacktestInput;
};


export type MutationSetBotVisibilityArgs = {
  id: Scalars['ID']['input'];
  public: Scalars['Boolean']['input'];
};


export type MutationSetRunnerVisibilityArgs = {
  id: Scalars['ID']['input'];
  public: Scalars['Boolean']['input'];
};


export type MutationSetStrategyVisibilityArgs = {
  id: Scalars['ID']['input'];
  public: Scalars['Boolean']['input'];
};


export type MutationStartBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationStopBacktestArgs = {
  id: Scalars['ID']['input'];
};


export type MutationStopBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationTestAlertRuleArgs = {
  id: Scalars['ID']['input'];
};


export type MutationTestRunnerConnectionArgs = {
  config: RunnerConfigInput;
  type: BotRunnerRunnerType;
};


export type MutationTestS3ConnectionArgs = {
  config: S3ConfigInput;
};


export type MutationToggleAlertRuleArgs = {
  enabled: Scalars['Boolean']['input'];
  id: Scalars['ID']['input'];
};


export type MutationUpdateAlertRuleArgs = {
  id: Scalars['ID']['input'];
  input: UpdateAlertRuleInput;
};


export type MutationUpdateBotArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBotInput;
};


export type MutationUpdateBotRunnerArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBotRunnerInput;
};


export type MutationUpdateExchangeArgs = {
  id: Scalars['ID']['input'];
  input: UpdateExchangeInput;
};


export type MutationUpdateStrategyArgs = {
  id: Scalars['ID']['input'];
  input: UpdateStrategyInput;
};


export type MutationUpdateTradeArgs = {
  id: Scalars['ID']['input'];
  input: UpdateTradeInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type PassphraseExchangeConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
  passphrase: Scalars['String']['input'];
};

/** Input for checking a single permission */
export type PermissionCheckInput = {
  /** The resource ID (UUID) to check permission for */
  resourceId: Scalars['ID']['input'];
  /** The scope to check (e.g., "edit", "delete", "run") */
  scope: Scalars['String']['input'];
};

/** Result of a permission check */
export type PermissionCheckResult = {
  __typename?: 'PermissionCheckResult';
  /** Whether the permission is granted */
  granted: Scalars['Boolean']['output'];
  /** The resource ID that was checked */
  resourceId: Scalars['ID']['output'];
  /** The scope that was checked */
  scope: Scalars['String']['output'];
};

export type Query = {
  __typename?: 'Query';
  alertEvents: AlertEventConnection;
  alertRules: AlertRuleConnection;
  /**
   * Get available alert types for a resource
   * Returns alert types that can be configured for the given resource type
   * The resourceID is optional and reserved for future smart filtering
   */
  alertTypesForResource: Array<AlertTypeInfo>;
  backtests: BacktestConnection;
  botMetricsSlice: Array<BotMetrics>;
  botRunners: BotRunnerConnection;
  /**
   * Get usage history for a bot over a time range
   * Returns time-series data for charts (granularity depends on aggregation settings)
   */
  botUsageHistory: Array<ResourceUsageAggregation>;
  bots: BotConnection;
  /**
   * Check multiple permissions in a single request
   * Returns granted permissions for each resource/scope pair
   * Triggers self-healing if resource scopes are out of sync in Keycloak
   */
  checkPermissions: Array<PermissionCheckResult>;
  /**
   * Calculate estimated cost for usage over a time range
   * Uses runner-specific pricing rates
   */
  estimatedCost: UsageCost;
  exchanges: ExchangeConnection;
  getBotRunnerStatus?: Maybe<BotStatus>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  /**
   * Get total usage for an organization over a time range
   * Aggregates all resources (bots and backtests) owned by the organization
   */
  organizationUsage?: Maybe<ResourceUsageAggregation>;
  resourceUsageAggregations: Array<ResourceUsageAggregation>;
  resourceUsageSamples: Array<ResourceUsageSample>;
  strategies: StrategyConnection;
  /** Get all versions of a strategy by name (for version history view) */
  strategyVersions: Array<Strategy>;
  trades: TradeConnection;
};


export type QueryAlertEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AlertEventOrder>;
  where?: InputMaybe<AlertEventWhereInput>;
};


export type QueryAlertRulesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AlertRuleWhereInput>;
};


export type QueryAlertTypesForResourceArgs = {
  resourceID?: InputMaybe<Scalars['ID']['input']>;
  resourceType: AlertRuleAlertResourceType;
};


export type QueryBacktestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BacktestWhereInput>;
};


export type QueryBotRunnersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotRunnerWhereInput>;
};


export type QueryBotUsageHistoryArgs = {
  botID: Scalars['ID']['input'];
  end: Scalars['Time']['input'];
  start: Scalars['Time']['input'];
};


export type QueryBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};


export type QueryCheckPermissionsArgs = {
  permissions: Array<PermissionCheckInput>;
};


export type QueryEstimatedCostArgs = {
  end: Scalars['Time']['input'];
  ownerID: Scalars['String']['input'];
  start: Scalars['Time']['input'];
};


export type QueryExchangesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ExchangeWhereInput>;
};


export type QueryGetBotRunnerStatusArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryOrganizationUsageArgs = {
  end: Scalars['Time']['input'];
  ownerID: Scalars['String']['input'];
  start: Scalars['Time']['input'];
};


export type QueryStrategiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<StrategyWhereInput>;
};


export type QueryStrategyVersionsArgs = {
  name: Scalars['String']['input'];
};


export type QueryTradesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TradeOrder>;
  where?: InputMaybe<TradeWhereInput>;
};

export type RegistryAuthInput = {
  password: Scalars['String']['input'];
  serverAddress?: InputMaybe<Scalars['String']['input']>;
  username: Scalars['String']['input'];
};

export type ResourceUsageAggregation = Node & {
  __typename?: 'ResourceUsageAggregation';
  /** Total disk bytes read */
  blockReadBytes: Scalars['Int']['output'];
  /** Total disk bytes written */
  blockWriteBytes: Scalars['Int']['output'];
  /** End of the time bucket */
  bucketEnd: Scalars['Time']['output'];
  /** Start of the time bucket */
  bucketStart: Scalars['Time']['output'];
  /** Average CPU percentage during bucket */
  cpuAvgPercent: Scalars['Float']['output'];
  /** Total CPU consumption in core-seconds */
  cpuCoreSeconds: Scalars['Float']['output'];
  /** Maximum CPU percentage during bucket */
  cpuMaxPercent: Scalars['Float']['output'];
  createdAt: Scalars['Time']['output'];
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** Aggregation level: hourly or daily */
  granularity: ResourceUsageAggregationAggregationGranularity;
  id: Scalars['ID']['output'];
  /** Average memory usage in bytes */
  memoryAvgBytes: Scalars['Int']['output'];
  /** Total memory consumption in GB-seconds */
  memoryGBSeconds: Scalars['Float']['output'];
  /** Maximum memory usage in bytes */
  memoryMaxBytes: Scalars['Int']['output'];
  /** Total network bytes received */
  networkRxBytes: Scalars['Int']['output'];
  /** Total network bytes transmitted */
  networkTxBytes: Scalars['Int']['output'];
  /** Organization ID for billing */
  ownerID: Scalars['String']['output'];
  /** ID of the bot or backtest */
  resourceID: Scalars['ID']['output'];
  /** Type of resource: bot or backtest */
  resourceType: ResourceUsageAggregationResourceType;
  runner: BotRunner;
  /** Runner ID for rate lookup */
  runnerID: Scalars['ID']['output'];
  /** Number of samples in this aggregation */
  sampleCount: Scalars['Int']['output'];
};

/** ResourceUsageAggregationAggregationGranularity is enum for the field granularity */
export enum ResourceUsageAggregationAggregationGranularity {
  Daily = 'daily',
  Hourly = 'hourly'
}

/** ResourceUsageAggregationResourceType is enum for the field resource_type */
export enum ResourceUsageAggregationResourceType {
  Backtest = 'backtest',
  Bot = 'bot'
}

/**
 * ResourceUsageAggregationWhereInput is used for filtering ResourceUsageAggregation objects.
 * Input was generated by ent.
 */
export type ResourceUsageAggregationWhereInput = {
  and?: InputMaybe<Array<ResourceUsageAggregationWhereInput>>;
  /** block_read_bytes field predicates */
  blockReadBytes?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesGT?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  blockReadBytesLT?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** block_write_bytes field predicates */
  blockWriteBytes?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesGT?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  blockWriteBytesLT?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** bucket_end field predicates */
  bucketEnd?: InputMaybe<Scalars['Time']['input']>;
  bucketEndGT?: InputMaybe<Scalars['Time']['input']>;
  bucketEndGTE?: InputMaybe<Scalars['Time']['input']>;
  bucketEndIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  bucketEndLT?: InputMaybe<Scalars['Time']['input']>;
  bucketEndLTE?: InputMaybe<Scalars['Time']['input']>;
  bucketEndNEQ?: InputMaybe<Scalars['Time']['input']>;
  bucketEndNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** bucket_start field predicates */
  bucketStart?: InputMaybe<Scalars['Time']['input']>;
  bucketStartGT?: InputMaybe<Scalars['Time']['input']>;
  bucketStartGTE?: InputMaybe<Scalars['Time']['input']>;
  bucketStartIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  bucketStartLT?: InputMaybe<Scalars['Time']['input']>;
  bucketStartLTE?: InputMaybe<Scalars['Time']['input']>;
  bucketStartNEQ?: InputMaybe<Scalars['Time']['input']>;
  bucketStartNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** cpu_avg_percent field predicates */
  cpuAvgPercent?: InputMaybe<Scalars['Float']['input']>;
  cpuAvgPercentGT?: InputMaybe<Scalars['Float']['input']>;
  cpuAvgPercentGTE?: InputMaybe<Scalars['Float']['input']>;
  cpuAvgPercentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  cpuAvgPercentLT?: InputMaybe<Scalars['Float']['input']>;
  cpuAvgPercentLTE?: InputMaybe<Scalars['Float']['input']>;
  cpuAvgPercentNEQ?: InputMaybe<Scalars['Float']['input']>;
  cpuAvgPercentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** cpu_core_seconds field predicates */
  cpuCoreSeconds?: InputMaybe<Scalars['Float']['input']>;
  cpuCoreSecondsGT?: InputMaybe<Scalars['Float']['input']>;
  cpuCoreSecondsGTE?: InputMaybe<Scalars['Float']['input']>;
  cpuCoreSecondsIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  cpuCoreSecondsLT?: InputMaybe<Scalars['Float']['input']>;
  cpuCoreSecondsLTE?: InputMaybe<Scalars['Float']['input']>;
  cpuCoreSecondsNEQ?: InputMaybe<Scalars['Float']['input']>;
  cpuCoreSecondsNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** cpu_max_percent field predicates */
  cpuMaxPercent?: InputMaybe<Scalars['Float']['input']>;
  cpuMaxPercentGT?: InputMaybe<Scalars['Float']['input']>;
  cpuMaxPercentGTE?: InputMaybe<Scalars['Float']['input']>;
  cpuMaxPercentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  cpuMaxPercentLT?: InputMaybe<Scalars['Float']['input']>;
  cpuMaxPercentLTE?: InputMaybe<Scalars['Float']['input']>;
  cpuMaxPercentNEQ?: InputMaybe<Scalars['Float']['input']>;
  cpuMaxPercentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** granularity field predicates */
  granularity?: InputMaybe<ResourceUsageAggregationAggregationGranularity>;
  granularityIn?: InputMaybe<Array<ResourceUsageAggregationAggregationGranularity>>;
  granularityNEQ?: InputMaybe<ResourceUsageAggregationAggregationGranularity>;
  granularityNotIn?: InputMaybe<Array<ResourceUsageAggregationAggregationGranularity>>;
  /** runner edge predicates */
  hasRunner?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunnerWith?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** memory_avg_bytes field predicates */
  memoryAvgBytes?: InputMaybe<Scalars['Int']['input']>;
  memoryAvgBytesGT?: InputMaybe<Scalars['Int']['input']>;
  memoryAvgBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  memoryAvgBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  memoryAvgBytesLT?: InputMaybe<Scalars['Int']['input']>;
  memoryAvgBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  memoryAvgBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  memoryAvgBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** memory_gb_seconds field predicates */
  memoryGBSeconds?: InputMaybe<Scalars['Float']['input']>;
  memoryGBSecondsGT?: InputMaybe<Scalars['Float']['input']>;
  memoryGBSecondsGTE?: InputMaybe<Scalars['Float']['input']>;
  memoryGBSecondsIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  memoryGBSecondsLT?: InputMaybe<Scalars['Float']['input']>;
  memoryGBSecondsLTE?: InputMaybe<Scalars['Float']['input']>;
  memoryGBSecondsNEQ?: InputMaybe<Scalars['Float']['input']>;
  memoryGBSecondsNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** memory_max_bytes field predicates */
  memoryMaxBytes?: InputMaybe<Scalars['Int']['input']>;
  memoryMaxBytesGT?: InputMaybe<Scalars['Int']['input']>;
  memoryMaxBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  memoryMaxBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  memoryMaxBytesLT?: InputMaybe<Scalars['Int']['input']>;
  memoryMaxBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  memoryMaxBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  memoryMaxBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** network_rx_bytes field predicates */
  networkRxBytes?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesGT?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  networkRxBytesLT?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** network_tx_bytes field predicates */
  networkTxBytes?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesGT?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  networkTxBytesLT?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  not?: InputMaybe<ResourceUsageAggregationWhereInput>;
  or?: InputMaybe<Array<ResourceUsageAggregationWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  ownerIDContains?: InputMaybe<Scalars['String']['input']>;
  ownerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDGT?: InputMaybe<Scalars['String']['input']>;
  ownerIDGTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ownerIDLT?: InputMaybe<Scalars['String']['input']>;
  ownerIDLTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** resource_id field predicates */
  resourceID?: InputMaybe<Scalars['ID']['input']>;
  resourceIDGT?: InputMaybe<Scalars['ID']['input']>;
  resourceIDGTE?: InputMaybe<Scalars['ID']['input']>;
  resourceIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  resourceIDLT?: InputMaybe<Scalars['ID']['input']>;
  resourceIDLTE?: InputMaybe<Scalars['ID']['input']>;
  resourceIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  resourceIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** resource_type field predicates */
  resourceType?: InputMaybe<ResourceUsageAggregationResourceType>;
  resourceTypeIn?: InputMaybe<Array<ResourceUsageAggregationResourceType>>;
  resourceTypeNEQ?: InputMaybe<ResourceUsageAggregationResourceType>;
  resourceTypeNotIn?: InputMaybe<Array<ResourceUsageAggregationResourceType>>;
  /** runner_id field predicates */
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  runnerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  runnerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** sample_count field predicates */
  sampleCount?: InputMaybe<Scalars['Int']['input']>;
  sampleCountGT?: InputMaybe<Scalars['Int']['input']>;
  sampleCountGTE?: InputMaybe<Scalars['Int']['input']>;
  sampleCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  sampleCountLT?: InputMaybe<Scalars['Int']['input']>;
  sampleCountLTE?: InputMaybe<Scalars['Int']['input']>;
  sampleCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  sampleCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type ResourceUsageSample = Node & {
  __typename?: 'ResourceUsageSample';
  /** Disk bytes read */
  blockReadBytes: Scalars['Int']['output'];
  /** Disk bytes written */
  blockWriteBytes: Scalars['Int']['output'];
  /** CPU usage as percentage (0-100 per core) */
  cpuPercent: Scalars['Float']['output'];
  createdAt: Scalars['Time']['output'];
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** Memory usage in bytes */
  memoryBytes: Scalars['Int']['output'];
  /** Network bytes received */
  networkRxBytes: Scalars['Int']['output'];
  /** Network bytes transmitted */
  networkTxBytes: Scalars['Int']['output'];
  /** Organization ID for billing */
  ownerID: Scalars['String']['output'];
  /** ID of the bot or backtest */
  resourceID: Scalars['ID']['output'];
  /** Type of resource: bot or backtest */
  resourceType: ResourceUsageSampleResourceType;
  runner: BotRunner;
  /** Runner ID for rate lookup */
  runnerID: Scalars['ID']['output'];
  /** When this sample was collected */
  sampledAt: Scalars['Time']['output'];
};

/** ResourceUsageSampleResourceType is enum for the field resource_type */
export enum ResourceUsageSampleResourceType {
  Backtest = 'backtest',
  Bot = 'bot'
}

/**
 * ResourceUsageSampleWhereInput is used for filtering ResourceUsageSample objects.
 * Input was generated by ent.
 */
export type ResourceUsageSampleWhereInput = {
  and?: InputMaybe<Array<ResourceUsageSampleWhereInput>>;
  /** block_read_bytes field predicates */
  blockReadBytes?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesGT?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  blockReadBytesLT?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  blockReadBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** block_write_bytes field predicates */
  blockWriteBytes?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesGT?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  blockWriteBytesLT?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  blockWriteBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** cpu_percent field predicates */
  cpuPercent?: InputMaybe<Scalars['Float']['input']>;
  cpuPercentGT?: InputMaybe<Scalars['Float']['input']>;
  cpuPercentGTE?: InputMaybe<Scalars['Float']['input']>;
  cpuPercentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  cpuPercentLT?: InputMaybe<Scalars['Float']['input']>;
  cpuPercentLTE?: InputMaybe<Scalars['Float']['input']>;
  cpuPercentNEQ?: InputMaybe<Scalars['Float']['input']>;
  cpuPercentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** runner edge predicates */
  hasRunner?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunnerWith?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** memory_bytes field predicates */
  memoryBytes?: InputMaybe<Scalars['Int']['input']>;
  memoryBytesGT?: InputMaybe<Scalars['Int']['input']>;
  memoryBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  memoryBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  memoryBytesLT?: InputMaybe<Scalars['Int']['input']>;
  memoryBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  memoryBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  memoryBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** network_rx_bytes field predicates */
  networkRxBytes?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesGT?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  networkRxBytesLT?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  networkRxBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** network_tx_bytes field predicates */
  networkTxBytes?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesGT?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesGTE?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  networkTxBytesLT?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesLTE?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  networkTxBytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  not?: InputMaybe<ResourceUsageSampleWhereInput>;
  or?: InputMaybe<Array<ResourceUsageSampleWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  ownerIDContains?: InputMaybe<Scalars['String']['input']>;
  ownerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDGT?: InputMaybe<Scalars['String']['input']>;
  ownerIDGTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ownerIDLT?: InputMaybe<Scalars['String']['input']>;
  ownerIDLTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** resource_id field predicates */
  resourceID?: InputMaybe<Scalars['ID']['input']>;
  resourceIDGT?: InputMaybe<Scalars['ID']['input']>;
  resourceIDGTE?: InputMaybe<Scalars['ID']['input']>;
  resourceIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  resourceIDLT?: InputMaybe<Scalars['ID']['input']>;
  resourceIDLTE?: InputMaybe<Scalars['ID']['input']>;
  resourceIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  resourceIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** resource_type field predicates */
  resourceType?: InputMaybe<ResourceUsageSampleResourceType>;
  resourceTypeIn?: InputMaybe<Array<ResourceUsageSampleResourceType>>;
  resourceTypeNEQ?: InputMaybe<ResourceUsageSampleResourceType>;
  resourceTypeNotIn?: InputMaybe<Array<ResourceUsageSampleResourceType>>;
  /** runner_id field predicates */
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  runnerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  runnerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** sampled_at field predicates */
  sampledAt?: InputMaybe<Scalars['Time']['input']>;
  sampledAtGT?: InputMaybe<Scalars['Time']['input']>;
  sampledAtGTE?: InputMaybe<Scalars['Time']['input']>;
  sampledAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  sampledAtLT?: InputMaybe<Scalars['Time']['input']>;
  sampledAtLTE?: InputMaybe<Scalars['Time']['input']>;
  sampledAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  sampledAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type RunnerConfigInput = {
  docker?: InputMaybe<DockerConfigInput>;
  kubernetes?: InputMaybe<KubernetesConfigInput>;
  local?: InputMaybe<LocalConfigInput>;
  s3?: InputMaybe<S3ConfigInput>;
};

/**
 * S3 storage configuration for runner data distribution
 * Supports AWS S3, MinIO, Backblaze B2, and other S3-compatible storage
 */
export type S3ConfigInput = {
  /** AWS/S3 access key ID */
  accessKeyId: Scalars['String']['input'];
  /** S3 bucket name */
  bucket: Scalars['String']['input'];
  /** S3 endpoint URL (e.g., "s3.amazonaws.com" or "minio.local:9000") */
  endpoint: Scalars['String']['input'];
  /**
   * Force path-style addressing (required for MinIO, optional for AWS)
   * When true: http://endpoint/bucket/key
   * When false: http://bucket.endpoint/key
   */
  forcePathStyle?: InputMaybe<Scalars['Boolean']['input']>;
  /** AWS region (default: us-east-1) */
  region?: InputMaybe<Scalars['String']['input']>;
  /** AWS/S3 secret access key */
  secretAccessKey: Scalars['String']['input'];
  /** Enable HTTPS connections (default: true) */
  useSSL?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Option for select/multi_select condition fields */
export type SelectOption = {
  __typename?: 'SelectOption';
  label: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type Strategy = Node & {
  __typename?: 'Strategy';
  /** Strategy can have at most one backtest (one-to-one) */
  backtest?: Maybe<Backtest>;
  bots: BotConnection;
  /** Parent strategy for versioning (self-referential) */
  children?: Maybe<Array<Strategy>>;
  /** Python strategy code */
  code: Scalars['String']['output'];
  /** Strategy-specific configuration (config.json) - REQUIRED */
  config: Scalars['Map']['output'];
  createdAt: Scalars['Time']['output'];
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** Strategy description */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Indicates if this is the latest version of the strategy */
  isLatest: Scalars['Boolean']['output'];
  /** Strategy name (not unique, allows versions) */
  name: Scalars['String']['output'];
  /** Group ID (organization) that owns this strategy */
  ownerID: Scalars['String']['output'];
  parent?: Maybe<Strategy>;
  /** Parent strategy ID for versioning (null for root v1) */
  parentID?: Maybe<Scalars['ID']['output']>;
  /** Whether this resource is publicly visible to all authenticated users */
  public: Scalars['Boolean']['output'];
  updatedAt: Scalars['Time']['output'];
  /** Auto-incremented version number */
  versionNumber: Scalars['Int']['output'];
};


export type StrategyBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};

/** A connection to a list of items. */
export type StrategyConnection = {
  __typename?: 'StrategyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StrategyEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type StrategyEdge = {
  __typename?: 'StrategyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Strategy>;
};

/**
 * StrategyWhereInput is used for filtering Strategy objects.
 * Input was generated by ent.
 */
export type StrategyWhereInput = {
  and?: InputMaybe<Array<StrategyWhereInput>>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']['input']>;
  codeContains?: InputMaybe<Scalars['String']['input']>;
  codeContainsFold?: InputMaybe<Scalars['String']['input']>;
  codeEqualFold?: InputMaybe<Scalars['String']['input']>;
  codeGT?: InputMaybe<Scalars['String']['input']>;
  codeGTE?: InputMaybe<Scalars['String']['input']>;
  codeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  codeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  codeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  codeLT?: InputMaybe<Scalars['String']['input']>;
  codeLTE?: InputMaybe<Scalars['String']['input']>;
  codeNEQ?: InputMaybe<Scalars['String']['input']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** backtest edge predicates */
  hasBacktest?: InputMaybe<Scalars['Boolean']['input']>;
  hasBacktestWith?: InputMaybe<Array<BacktestWhereInput>>;
  /** bots edge predicates */
  hasBots?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotsWith?: InputMaybe<Array<BotWhereInput>>;
  /** children edge predicates */
  hasChildren?: InputMaybe<Scalars['Boolean']['input']>;
  hasChildrenWith?: InputMaybe<Array<StrategyWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']['input']>;
  hasParentWith?: InputMaybe<Array<StrategyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_latest field predicates */
  isLatest?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<StrategyWhereInput>;
  or?: InputMaybe<Array<StrategyWhereInput>>;
  /** owner_id field predicates */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  ownerIDContains?: InputMaybe<Scalars['String']['input']>;
  ownerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  ownerIDGT?: InputMaybe<Scalars['String']['input']>;
  ownerIDGTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ownerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ownerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ownerIDLT?: InputMaybe<Scalars['String']['input']>;
  ownerIDLTE?: InputMaybe<Scalars['String']['input']>;
  ownerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  ownerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** parent_id field predicates */
  parentID?: InputMaybe<Scalars['ID']['input']>;
  parentIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  parentIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  parentIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  parentIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  parentIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** public field predicates */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  publicNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** version_number field predicates */
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
  versionNumberGT?: InputMaybe<Scalars['Int']['input']>;
  versionNumberGTE?: InputMaybe<Scalars['Int']['input']>;
  versionNumberIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  versionNumberLT?: InputMaybe<Scalars['Int']['input']>;
  versionNumberLTE?: InputMaybe<Scalars['Int']['input']>;
  versionNumberNEQ?: InputMaybe<Scalars['Int']['input']>;
  versionNumberNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type Trade = Node & {
  __typename?: 'Trade';
  /** Amount of coins */
  amount: Scalars['Float']['output'];
  bot: Bot;
  /** Foreign key to bot */
  botID: Scalars['ID']['output'];
  /** Trade close time */
  closeDate?: Maybe<Scalars['Time']['output']>;
  /** Exit price */
  closeRate?: Maybe<Scalars['Float']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** Original trade ID from freqtrade */
  freqtradeTradeID: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** Trade open status */
  isOpen: Scalars['Boolean']['output'];
  /** Trade open time */
  openDate: Scalars['Time']['output'];
  /** Entry price */
  openRate: Scalars['Float']['output'];
  /** Trading pair (BTC/USDT) */
  pair: Scalars['String']['output'];
  /** Absolute profit */
  profitAbs: Scalars['Float']['output'];
  /** Profit percentage (0.05 = 5%) */
  profitRatio: Scalars['Float']['output'];
  /** Reason for selling (roi, stoploss, etc.) */
  sellReason?: Maybe<Scalars['String']['output']>;
  /** Stake in base currency */
  stakeAmount: Scalars['Float']['output'];
  /** Strategy used */
  strategyName?: Maybe<Scalars['String']['output']>;
  /** Timeframe used */
  timeframe?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type TradeConnection = {
  __typename?: 'TradeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TradeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TradeEdge = {
  __typename?: 'TradeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Trade>;
};

/** Ordering options for Trade connections */
export type TradeOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Trades. */
  field: TradeOrderField;
};

/** Properties by which Trade connections can be ordered. */
export enum TradeOrderField {
  CloseDate = 'CLOSE_DATE',
  OpenDate = 'OPEN_DATE',
  ProfitAbs = 'PROFIT_ABS',
  ProfitRatio = 'PROFIT_RATIO'
}

/**
 * TradeWhereInput is used for filtering Trade objects.
 * Input was generated by ent.
 */
export type TradeWhereInput = {
  /** amount field predicates */
  amount?: InputMaybe<Scalars['Float']['input']>;
  amountGT?: InputMaybe<Scalars['Float']['input']>;
  amountGTE?: InputMaybe<Scalars['Float']['input']>;
  amountIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  amountLT?: InputMaybe<Scalars['Float']['input']>;
  amountLTE?: InputMaybe<Scalars['Float']['input']>;
  amountNEQ?: InputMaybe<Scalars['Float']['input']>;
  amountNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  and?: InputMaybe<Array<TradeWhereInput>>;
  /** bot_id field predicates */
  botID?: InputMaybe<Scalars['ID']['input']>;
  botIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  botIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  botIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** close_date field predicates */
  closeDate?: InputMaybe<Scalars['Time']['input']>;
  closeDateGT?: InputMaybe<Scalars['Time']['input']>;
  closeDateGTE?: InputMaybe<Scalars['Time']['input']>;
  closeDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  closeDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  closeDateLT?: InputMaybe<Scalars['Time']['input']>;
  closeDateLTE?: InputMaybe<Scalars['Time']['input']>;
  closeDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  closeDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  closeDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** close_rate field predicates */
  closeRate?: InputMaybe<Scalars['Float']['input']>;
  closeRateGT?: InputMaybe<Scalars['Float']['input']>;
  closeRateGTE?: InputMaybe<Scalars['Float']['input']>;
  closeRateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  closeRateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  closeRateLT?: InputMaybe<Scalars['Float']['input']>;
  closeRateLTE?: InputMaybe<Scalars['Float']['input']>;
  closeRateNEQ?: InputMaybe<Scalars['Float']['input']>;
  closeRateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  closeRateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** freqtrade_trade_id field predicates */
  freqtradeTradeID?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDGT?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDGTE?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  freqtradeTradeIDLT?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDLTE?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** bot edge predicates */
  hasBot?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_open field predicates */
  isOpen?: InputMaybe<Scalars['Boolean']['input']>;
  isOpenNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<TradeWhereInput>;
  /** open_date field predicates */
  openDate?: InputMaybe<Scalars['Time']['input']>;
  openDateGT?: InputMaybe<Scalars['Time']['input']>;
  openDateGTE?: InputMaybe<Scalars['Time']['input']>;
  openDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  openDateLT?: InputMaybe<Scalars['Time']['input']>;
  openDateLTE?: InputMaybe<Scalars['Time']['input']>;
  openDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  openDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** open_rate field predicates */
  openRate?: InputMaybe<Scalars['Float']['input']>;
  openRateGT?: InputMaybe<Scalars['Float']['input']>;
  openRateGTE?: InputMaybe<Scalars['Float']['input']>;
  openRateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  openRateLT?: InputMaybe<Scalars['Float']['input']>;
  openRateLTE?: InputMaybe<Scalars['Float']['input']>;
  openRateNEQ?: InputMaybe<Scalars['Float']['input']>;
  openRateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  or?: InputMaybe<Array<TradeWhereInput>>;
  /** pair field predicates */
  pair?: InputMaybe<Scalars['String']['input']>;
  pairContains?: InputMaybe<Scalars['String']['input']>;
  pairContainsFold?: InputMaybe<Scalars['String']['input']>;
  pairEqualFold?: InputMaybe<Scalars['String']['input']>;
  pairGT?: InputMaybe<Scalars['String']['input']>;
  pairGTE?: InputMaybe<Scalars['String']['input']>;
  pairHasPrefix?: InputMaybe<Scalars['String']['input']>;
  pairHasSuffix?: InputMaybe<Scalars['String']['input']>;
  pairIn?: InputMaybe<Array<Scalars['String']['input']>>;
  pairLT?: InputMaybe<Scalars['String']['input']>;
  pairLTE?: InputMaybe<Scalars['String']['input']>;
  pairNEQ?: InputMaybe<Scalars['String']['input']>;
  pairNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** profit_abs field predicates */
  profitAbs?: InputMaybe<Scalars['Float']['input']>;
  profitAbsGT?: InputMaybe<Scalars['Float']['input']>;
  profitAbsGTE?: InputMaybe<Scalars['Float']['input']>;
  profitAbsIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAbsLT?: InputMaybe<Scalars['Float']['input']>;
  profitAbsLTE?: InputMaybe<Scalars['Float']['input']>;
  profitAbsNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitAbsNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** profit_ratio field predicates */
  profitRatio?: InputMaybe<Scalars['Float']['input']>;
  profitRatioGT?: InputMaybe<Scalars['Float']['input']>;
  profitRatioGTE?: InputMaybe<Scalars['Float']['input']>;
  profitRatioIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitRatioLT?: InputMaybe<Scalars['Float']['input']>;
  profitRatioLTE?: InputMaybe<Scalars['Float']['input']>;
  profitRatioNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitRatioNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** sell_reason field predicates */
  sellReason?: InputMaybe<Scalars['String']['input']>;
  sellReasonContains?: InputMaybe<Scalars['String']['input']>;
  sellReasonContainsFold?: InputMaybe<Scalars['String']['input']>;
  sellReasonEqualFold?: InputMaybe<Scalars['String']['input']>;
  sellReasonGT?: InputMaybe<Scalars['String']['input']>;
  sellReasonGTE?: InputMaybe<Scalars['String']['input']>;
  sellReasonHasPrefix?: InputMaybe<Scalars['String']['input']>;
  sellReasonHasSuffix?: InputMaybe<Scalars['String']['input']>;
  sellReasonIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sellReasonIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sellReasonLT?: InputMaybe<Scalars['String']['input']>;
  sellReasonLTE?: InputMaybe<Scalars['String']['input']>;
  sellReasonNEQ?: InputMaybe<Scalars['String']['input']>;
  sellReasonNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sellReasonNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** stake_amount field predicates */
  stakeAmount?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountGT?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountGTE?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  stakeAmountLT?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountLTE?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountNEQ?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** strategy_name field predicates */
  strategyName?: InputMaybe<Scalars['String']['input']>;
  strategyNameContains?: InputMaybe<Scalars['String']['input']>;
  strategyNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  strategyNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  strategyNameGT?: InputMaybe<Scalars['String']['input']>;
  strategyNameGTE?: InputMaybe<Scalars['String']['input']>;
  strategyNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  strategyNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  strategyNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  strategyNameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  strategyNameLT?: InputMaybe<Scalars['String']['input']>;
  strategyNameLTE?: InputMaybe<Scalars['String']['input']>;
  strategyNameNEQ?: InputMaybe<Scalars['String']['input']>;
  strategyNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  strategyNameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** timeframe field predicates */
  timeframe?: InputMaybe<Scalars['String']['input']>;
  timeframeContains?: InputMaybe<Scalars['String']['input']>;
  timeframeContainsFold?: InputMaybe<Scalars['String']['input']>;
  timeframeEqualFold?: InputMaybe<Scalars['String']['input']>;
  timeframeGT?: InputMaybe<Scalars['String']['input']>;
  timeframeGTE?: InputMaybe<Scalars['String']['input']>;
  timeframeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  timeframeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  timeframeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  timeframeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  timeframeLT?: InputMaybe<Scalars['String']['input']>;
  timeframeLTE?: InputMaybe<Scalars['String']['input']>;
  timeframeNEQ?: InputMaybe<Scalars['String']['input']>;
  timeframeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  timeframeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * UpdateAlertRuleInput is used for update AlertRule object.
 * Input was generated by ent.
 */
export type UpdateAlertRuleInput = {
  addEventIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Type of alert: status_change, trade_opened, trade_closed, etc. */
  alertType?: InputMaybe<AlertRuleAlertType>;
  appendRecipients?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Batch window in minutes (only used if delivery_mode=batched) */
  batchIntervalMinutes?: InputMaybe<Scalars['Int']['input']>;
  /** Filter by bot trading mode: all, live, dry_run */
  botModeFilter?: InputMaybe<AlertRuleAlertBotModeFilter>;
  clearConditions?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearEvents?: InputMaybe<Scalars['Boolean']['input']>;
  clearLastTriggeredAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearResourceID?: InputMaybe<Scalars['Boolean']['input']>;
  /** Condition parameters: thresholds, status values, etc. */
  conditions?: InputMaybe<Scalars['Map']['input']>;
  /** Minimum minutes between alerts of same type for same resource */
  cooldownMinutes?: InputMaybe<Scalars['Int']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Delivery mode: immediate or batched */
  deliveryMode?: InputMaybe<AlertRuleAlertDeliveryMode>;
  /** Whether this rule is active */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** When this rule last triggered (for cooldown calculation) */
  lastTriggeredAt?: InputMaybe<Scalars['Time']['input']>;
  /** Human-readable rule name (e.g., 'Bot Error Alert') */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Organization ID that owns this rule */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  /** List of recipient email addresses */
  recipients?: InputMaybe<Array<Scalars['String']['input']>>;
  removeEventIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Specific resource ID (null for org-level rules that apply to all resources) */
  resourceID?: InputMaybe<Scalars['ID']['input']>;
  /** Type of resource: organization, bot, strategy, runner */
  resourceType?: InputMaybe<AlertRuleAlertResourceType>;
  /** Alert severity: critical, warning, info */
  severity?: InputMaybe<AlertRuleAlertSeverity>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateBotInput is used for update Bot object.
 * Input was generated by ent.
 */
export type UpdateBotInput = {
  addTradeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearErrorMessage?: InputMaybe<Scalars['Boolean']['input']>;
  clearLastSeenAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearMetrics?: InputMaybe<Scalars['Boolean']['input']>;
  clearTrades?: InputMaybe<Scalars['Boolean']['input']>;
  /** Complete freqtrade bot configuration (stake, pairlists, pricing, api_server, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Last error message if status is error */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  exchangeID?: InputMaybe<Scalars['ID']['input']>;
  /** Freqtrade Docker image version tag */
  freqtradeVersion?: InputMaybe<Scalars['String']['input']>;
  /** Last successful health check */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>;
  metricsID?: InputMaybe<Scalars['ID']['input']>;
  /** Trading mode (dry-run or live) */
  mode?: InputMaybe<BotBotMode>;
  /** Bot display name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Group ID (organization) that owns this bot */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  /** Whether this resource is publicly visible to all authenticated users */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  removeTradeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  /** Bot lifecycle status */
  status?: InputMaybe<BotBotStatus>;
  strategyID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateBotMetricsInput is used for update BotMetrics object.
 * Input was generated by ent.
 */
export type UpdateBotMetricsInput = {
  /** Best performing trading pair */
  bestPair?: InputMaybe<Scalars['String']['input']>;
  /** Best trade profit rate */
  bestRate?: InputMaybe<Scalars['Float']['input']>;
  botID?: InputMaybe<Scalars['ID']['input']>;
  clearBestPair?: InputMaybe<Scalars['Boolean']['input']>;
  clearBestRate?: InputMaybe<Scalars['Boolean']['input']>;
  clearClosedTradeCount?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearExpectancy?: InputMaybe<Scalars['Boolean']['input']>;
  clearFirstTradeTimestamp?: InputMaybe<Scalars['Boolean']['input']>;
  clearLastTradeSyncAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearLatestTradeTimestamp?: InputMaybe<Scalars['Boolean']['input']>;
  clearLosingTrades?: InputMaybe<Scalars['Boolean']['input']>;
  clearMaxDrawdown?: InputMaybe<Scalars['Boolean']['input']>;
  clearMaxDrawdownAbs?: InputMaybe<Scalars['Boolean']['input']>;
  clearOpenTradeCount?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitAllCoin?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitAllPercent?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitClosedCoin?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitClosedPercent?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitFactor?: InputMaybe<Scalars['Boolean']['input']>;
  clearTradeCount?: InputMaybe<Scalars['Boolean']['input']>;
  clearWinningTrades?: InputMaybe<Scalars['Boolean']['input']>;
  clearWinrate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of closed trades */
  closedTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Average profit per trade */
  expectancy?: InputMaybe<Scalars['Float']['input']>;
  /** When these metrics were fetched from Freqtrade API */
  fetchedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of first trade */
  firstTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Highest trade ID ever seen - used to detect bot reset (when current max < this) */
  lastKnownMaxTradeID?: InputMaybe<Scalars['Int']['input']>;
  /** Last freqtrade_trade_id synced for incremental fetch */
  lastSyncedTradeID?: InputMaybe<Scalars['Int']['input']>;
  /** Last successful trade sync timestamp */
  lastTradeSyncAt?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of latest trade */
  latestTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Number of losing trades */
  losingTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum drawdown percentage */
  maxDrawdown?: InputMaybe<Scalars['Float']['input']>;
  /** Maximum drawdown absolute value */
  maxDrawdownAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Current number of open trades */
  openTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Total profit (closed + open) in coin */
  profitAllCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total profit (closed + open) percentage */
  profitAllPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit in coin */
  profitClosedCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit percentage */
  profitClosedPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Ratio of gross profit to gross loss */
  profitFactor?: InputMaybe<Scalars['Float']['input']>;
  /** Total number of trades */
  tradeCount?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Number of winning trades */
  winningTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Win rate percentage (0-100) */
  winrate?: InputMaybe<Scalars['Float']['input']>;
};

/**
 * UpdateBotRunnerInput is used for update BotRunner object.
 * Input was generated by ent.
 */
export type UpdateBotRunnerInput = {
  addBacktestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Whether usage tracking and billing is enabled for this runner */
  billingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  clearBacktests?: InputMaybe<Scalars['Boolean']['input']>;
  clearBots?: InputMaybe<Scalars['Boolean']['input']>;
  clearCPUPricePerCoreHour?: InputMaybe<Scalars['Boolean']['input']>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataDownloadConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataDownloadProgress?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataDownloadStartedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataErrorMessage?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataLastUpdated?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearMemoryPricePerGBHour?: InputMaybe<Scalars['Boolean']['input']>;
  clearNetworkPricePerGB?: InputMaybe<Scalars['Boolean']['input']>;
  clearS3Config?: InputMaybe<Scalars['Boolean']['input']>;
  clearS3DataKey?: InputMaybe<Scalars['Boolean']['input']>;
  clearS3DataUploadedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearStoragePricePerGB?: InputMaybe<Scalars['Boolean']['input']>;
  /** Runner connection configuration (host, port, credentials, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Price per core-hour in USD (only used if billing_enabled) */
  cpuPricePerCoreHour?: InputMaybe<Scalars['Float']['input']>;
  /** Data download configuration: {exchanges: [{name, enabled, timeframes, pairs_pattern, days, trading_mode}]} */
  dataDownloadConfig?: InputMaybe<Scalars['Map']['input']>;
  /** Progress details: {pairs_completed, pairs_total, current_pair, percent_complete} */
  dataDownloadProgress?: InputMaybe<Scalars['Map']['input']>;
  /** When the current data download started (for stuck detection) */
  dataDownloadStartedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Current data download status (idle, downloading, completed, failed) */
  dataDownloadStatus?: InputMaybe<BotRunnerDataDownloadStatus>;
  /** Error message if data download failed */
  dataErrorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Whether runner has downloaded historical data for backtesting */
  dataIsReady?: InputMaybe<Scalars['Boolean']['input']>;
  /** When data was last refreshed */
  dataLastUpdated?: InputMaybe<Scalars['Time']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Price per GB-hour in USD (only used if billing_enabled) */
  memoryPricePerGBHour?: InputMaybe<Scalars['Float']['input']>;
  /** Runner display name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Price per GB of network transfer in USD (only used if billing_enabled) */
  networkPricePerGB?: InputMaybe<Scalars['Float']['input']>;
  /** Group ID (organization) that owns this bot runner */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  /** Whether this resource is publicly visible to all authenticated users */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  removeBacktestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** S3 config: {endpoint, bucket, accessKeyId, secretAccessKey, region, forcePathStyle, useSSL} */
  s3Config?: InputMaybe<Scalars['Map']['input']>;
  /** S3 object key: runners/data/{runnerId}.zip */
  s3DataKey?: InputMaybe<Scalars['String']['input']>;
  /** When data was last uploaded to S3 */
  s3DataUploadedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Price per GB of disk I/O in USD (only used if billing_enabled) */
  storagePricePerGB?: InputMaybe<Scalars['Float']['input']>;
  /** Runner environment type (docker, kubernetes, local) */
  type?: InputMaybe<BotRunnerRunnerType>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateExchangeInput is used for update Exchange object.
 * Input was generated by ent.
 */
export type UpdateExchangeInput = {
  addBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearBots?: InputMaybe<Scalars['Boolean']['input']>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  /** Complete freqtrade exchange configuration (name, key, secret, pair_whitelist, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Exchange display name (e.g., 'Binance Production', 'Coinbase Testnet') */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Group ID (organization) that owns this exchange */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  removeBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateStrategyInput is used for update Strategy object.
 * Input was generated by ent.
 */
export type UpdateStrategyInput = {
  addBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addChildIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  backtestID?: InputMaybe<Scalars['ID']['input']>;
  clearBacktest?: InputMaybe<Scalars['Boolean']['input']>;
  clearBots?: InputMaybe<Scalars['Boolean']['input']>;
  clearChildren?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  clearParent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Python strategy code */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Strategy-specific configuration (config.json) - REQUIRED */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Strategy description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if this is the latest version of the strategy */
  isLatest?: InputMaybe<Scalars['Boolean']['input']>;
  /** Strategy name (not unique, allows versions) */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Group ID (organization) that owns this strategy */
  ownerID?: InputMaybe<Scalars['String']['input']>;
  parentID?: InputMaybe<Scalars['ID']['input']>;
  /** Whether this resource is publicly visible to all authenticated users */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  removeBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeChildIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Auto-incremented version number */
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * UpdateTradeInput is used for update Trade object.
 * Input was generated by ent.
 */
export type UpdateTradeInput = {
  /** Amount of coins */
  amount?: InputMaybe<Scalars['Float']['input']>;
  botID?: InputMaybe<Scalars['ID']['input']>;
  clearCloseDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearCloseRate?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearSellReason?: InputMaybe<Scalars['Boolean']['input']>;
  clearStrategyName?: InputMaybe<Scalars['Boolean']['input']>;
  clearTimeframe?: InputMaybe<Scalars['Boolean']['input']>;
  /** Trade close time */
  closeDate?: InputMaybe<Scalars['Time']['input']>;
  /** Exit price */
  closeRate?: InputMaybe<Scalars['Float']['input']>;
  /** Soft-delete timestamp. If set, record is considered deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Original trade ID from freqtrade */
  freqtradeTradeID?: InputMaybe<Scalars['Int']['input']>;
  /** Trade open status */
  isOpen?: InputMaybe<Scalars['Boolean']['input']>;
  /** Trade open time */
  openDate?: InputMaybe<Scalars['Time']['input']>;
  /** Entry price */
  openRate?: InputMaybe<Scalars['Float']['input']>;
  /** Trading pair (BTC/USDT) */
  pair?: InputMaybe<Scalars['String']['input']>;
  /** Absolute profit */
  profitAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Profit percentage (0.05 = 5%) */
  profitRatio?: InputMaybe<Scalars['Float']['input']>;
  /** Reason for selling (roi, stoploss, etc.) */
  sellReason?: InputMaybe<Scalars['String']['input']>;
  /** Stake in base currency */
  stakeAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Strategy used */
  strategyName?: InputMaybe<Scalars['String']['input']>;
  /** Timeframe used */
  timeframe?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * Estimated cost breakdown for resource usage
 * Uses runner-specific pricing rates
 */
export type UsageCost = {
  __typename?: 'UsageCost';
  /** Cost for CPU usage (core-hours * rate) */
  cpuCost: Scalars['Float']['output'];
  /** Currency for the cost */
  currency: Scalars['String']['output'];
  /** Cost for memory usage (GB-hours * rate) */
  memoryCost: Scalars['Float']['output'];
  /** Cost for network transfer (GB * rate) */
  networkCost: Scalars['Float']['output'];
  /** Cost for disk I/O (GB * rate) */
  storageCost: Scalars['Float']['output'];
  /** Total estimated cost */
  totalCost: Scalars['Float']['output'];
};
