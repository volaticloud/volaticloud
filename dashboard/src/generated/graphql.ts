import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Cursor: { input: string; output: string; }
  Map: { input: any; output: any; }
  Time: { input: string; output: string; }
};

export type Backtest = Node & {
  __typename?: 'Backtest';
  /** Completion timestamp */
  completedAt?: Maybe<Scalars['Time']['output']>;
  /** Backtest configuration (pairs, timeframe, dates, stake, etc.) */
  config?: Maybe<Scalars['Map']['output']>;
  /** Docker container ID for running backtest */
  containerID?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Error message if backtest failed */
  errorMessage?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Backtest result data (metrics, logs, trades, etc.) */
  result?: Maybe<Scalars['Map']['output']>;
  runner: BotRunner;
  /** Foreign key to runner */
  runnerID: Scalars['ID']['output'];
  /** Task status */
  status: BacktestTaskStatus;
  strategy: Strategy;
  /** Foreign key to strategy */
  strategyID: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type BacktestConnection = {
  __typename?: 'BacktestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BacktestEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BacktestEdge = {
  __typename?: 'BacktestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Backtest>;
};

/** BacktestTaskStatus is enum for the field status */
export enum BacktestTaskStatus {
  Completed = 'completed',
  Failed = 'failed',
  Pending = 'pending',
  Running = 'running'
}

/**
 * BacktestWhereInput is used for filtering Backtest objects.
 * Input was generated by ent.
 */
export type BacktestWhereInput = {
  and?: InputMaybe<Array<BacktestWhereInput>>;
  /** completed_at field predicates */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  completedAtGT?: InputMaybe<Scalars['Time']['input']>;
  completedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  completedAtLT?: InputMaybe<Scalars['Time']['input']>;
  completedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  completedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** container_id field predicates */
  containerID?: InputMaybe<Scalars['String']['input']>;
  containerIDContains?: InputMaybe<Scalars['String']['input']>;
  containerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  containerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  containerIDGT?: InputMaybe<Scalars['String']['input']>;
  containerIDGTE?: InputMaybe<Scalars['String']['input']>;
  containerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  containerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  containerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  containerIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  containerIDLT?: InputMaybe<Scalars['String']['input']>;
  containerIDLTE?: InputMaybe<Scalars['String']['input']>;
  containerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  containerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  containerIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** error_message field predicates */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  errorMessageContains?: InputMaybe<Scalars['String']['input']>;
  errorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageGT?: InputMaybe<Scalars['String']['input']>;
  errorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  errorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  errorMessageLT?: InputMaybe<Scalars['String']['input']>;
  errorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  errorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** runner edge predicates */
  hasRunner?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunnerWith?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** strategy edge predicates */
  hasStrategy?: InputMaybe<Scalars['Boolean']['input']>;
  hasStrategyWith?: InputMaybe<Array<StrategyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<BacktestWhereInput>;
  or?: InputMaybe<Array<BacktestWhereInput>>;
  /** runner_id field predicates */
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  runnerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  runnerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** status field predicates */
  status?: InputMaybe<BacktestTaskStatus>;
  statusIn?: InputMaybe<Array<BacktestTaskStatus>>;
  statusNEQ?: InputMaybe<BacktestTaskStatus>;
  statusNotIn?: InputMaybe<Array<BacktestTaskStatus>>;
  /** strategy_id field predicates */
  strategyID?: InputMaybe<Scalars['ID']['input']>;
  strategyIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  strategyIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  strategyIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type BinanceConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

export type BitfinexConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

export type Bot = Node & {
  __typename?: 'Bot';
  /** Complete freqtrade bot configuration (stake, pairlists, pricing, api_server, etc.) */
  config?: Maybe<Scalars['Map']['output']>;
  /** Runner-specific identifier (container ID, pod name, etc.) */
  containerID?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Last error message if status is error */
  errorMessage?: Maybe<Scalars['String']['output']>;
  exchange: Exchange;
  /** Foreign key to exchange (provides credentials) */
  exchangeID: Scalars['ID']['output'];
  /** Freqtrade Docker image version tag */
  freqtradeVersion: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Last successful health check */
  lastSeenAt?: Maybe<Scalars['Time']['output']>;
  metrics?: Maybe<BotMetrics>;
  /** Trading mode (dry-run or live) */
  mode: BotBotMode;
  /** Bot display name */
  name: Scalars['String']['output'];
  runner: BotRunner;
  /** Foreign key to runner (provides execution environment) */
  runnerID: Scalars['ID']['output'];
  /** Bot lifecycle status */
  status: BotBotStatus;
  strategy: Strategy;
  /** Foreign key to strategy (provides code) */
  strategyID: Scalars['ID']['output'];
  trades: TradeConnection;
  updatedAt: Scalars['Time']['output'];
};


export type BotTradesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TradeWhereInput>;
};

/** BotBotMode is enum for the field mode */
export enum BotBotMode {
  DryRun = 'dry_run',
  Live = 'live'
}

/** BotBotStatus is enum for the field status */
export enum BotBotStatus {
  Backtesting = 'backtesting',
  Creating = 'creating',
  Error = 'error',
  Hyperopt = 'hyperopt',
  Running = 'running',
  Stopped = 'stopped',
  Unhealthy = 'unhealthy'
}

/** A connection to a list of items. */
export type BotConnection = {
  __typename?: 'BotConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BotEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BotEdge = {
  __typename?: 'BotEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Bot>;
};

export type BotMetrics = Node & {
  __typename?: 'BotMetrics';
  /** Best performing trading pair */
  bestPair?: Maybe<Scalars['String']['output']>;
  /** Best trade profit rate */
  bestRate?: Maybe<Scalars['Float']['output']>;
  bot: Bot;
  /** Foreign key to bot (one-to-one) */
  botID: Scalars['ID']['output'];
  /** Number of closed trades */
  closedTradeCount?: Maybe<Scalars['Int']['output']>;
  /** Average profit per trade */
  expectancy?: Maybe<Scalars['Float']['output']>;
  /** When these metrics were fetched from Freqtrade API */
  fetchedAt: Scalars['Time']['output'];
  /** Timestamp of first trade */
  firstTradeTimestamp?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** Timestamp of latest trade */
  latestTradeTimestamp?: Maybe<Scalars['Time']['output']>;
  /** Number of losing trades */
  losingTrades?: Maybe<Scalars['Int']['output']>;
  /** Maximum drawdown percentage */
  maxDrawdown?: Maybe<Scalars['Float']['output']>;
  /** Maximum drawdown absolute value */
  maxDrawdownAbs?: Maybe<Scalars['Float']['output']>;
  /** Current number of open trades */
  openTradeCount?: Maybe<Scalars['Int']['output']>;
  /** Total profit (closed + open) in coin */
  profitAllCoin?: Maybe<Scalars['Float']['output']>;
  /** Total profit (closed + open) percentage */
  profitAllPercent?: Maybe<Scalars['Float']['output']>;
  /** Total closed profit in coin */
  profitClosedCoin?: Maybe<Scalars['Float']['output']>;
  /** Total closed profit percentage */
  profitClosedPercent?: Maybe<Scalars['Float']['output']>;
  /** Ratio of gross profit to gross loss */
  profitFactor?: Maybe<Scalars['Float']['output']>;
  /** Total number of trades */
  tradeCount?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['Time']['output'];
  /** Number of winning trades */
  winningTrades?: Maybe<Scalars['Int']['output']>;
  /** Win rate percentage (0-100) */
  winrate?: Maybe<Scalars['Float']['output']>;
};

/**
 * BotMetricsWhereInput is used for filtering BotMetrics objects.
 * Input was generated by ent.
 */
export type BotMetricsWhereInput = {
  and?: InputMaybe<Array<BotMetricsWhereInput>>;
  /** best_pair field predicates */
  bestPair?: InputMaybe<Scalars['String']['input']>;
  bestPairContains?: InputMaybe<Scalars['String']['input']>;
  bestPairContainsFold?: InputMaybe<Scalars['String']['input']>;
  bestPairEqualFold?: InputMaybe<Scalars['String']['input']>;
  bestPairGT?: InputMaybe<Scalars['String']['input']>;
  bestPairGTE?: InputMaybe<Scalars['String']['input']>;
  bestPairHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bestPairHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bestPairIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bestPairIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bestPairLT?: InputMaybe<Scalars['String']['input']>;
  bestPairLTE?: InputMaybe<Scalars['String']['input']>;
  bestPairNEQ?: InputMaybe<Scalars['String']['input']>;
  bestPairNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bestPairNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** best_rate field predicates */
  bestRate?: InputMaybe<Scalars['Float']['input']>;
  bestRateGT?: InputMaybe<Scalars['Float']['input']>;
  bestRateGTE?: InputMaybe<Scalars['Float']['input']>;
  bestRateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestRateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bestRateLT?: InputMaybe<Scalars['Float']['input']>;
  bestRateLTE?: InputMaybe<Scalars['Float']['input']>;
  bestRateNEQ?: InputMaybe<Scalars['Float']['input']>;
  bestRateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestRateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** bot_id field predicates */
  botID?: InputMaybe<Scalars['ID']['input']>;
  botIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  botIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  botIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** closed_trade_count field predicates */
  closedTradeCount?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountGT?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountGTE?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  closedTradeCountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  closedTradeCountLT?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountLTE?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  closedTradeCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  closedTradeCountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** expectancy field predicates */
  expectancy?: InputMaybe<Scalars['Float']['input']>;
  expectancyGT?: InputMaybe<Scalars['Float']['input']>;
  expectancyGTE?: InputMaybe<Scalars['Float']['input']>;
  expectancyIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  expectancyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  expectancyLT?: InputMaybe<Scalars['Float']['input']>;
  expectancyLTE?: InputMaybe<Scalars['Float']['input']>;
  expectancyNEQ?: InputMaybe<Scalars['Float']['input']>;
  expectancyNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  expectancyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** fetched_at field predicates */
  fetchedAt?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtGT?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  fetchedAtLT?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  fetchedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** first_trade_timestamp field predicates */
  firstTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampGT?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampGTE?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  firstTradeTimestampIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  firstTradeTimestampLT?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampLTE?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampNEQ?: InputMaybe<Scalars['Time']['input']>;
  firstTradeTimestampNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  firstTradeTimestampNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** bot edge predicates */
  hasBot?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** latest_trade_timestamp field predicates */
  latestTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampGT?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampGTE?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  latestTradeTimestampIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  latestTradeTimestampLT?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampLTE?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampNEQ?: InputMaybe<Scalars['Time']['input']>;
  latestTradeTimestampNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  latestTradeTimestampNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** losing_trades field predicates */
  losingTrades?: InputMaybe<Scalars['Int']['input']>;
  losingTradesGT?: InputMaybe<Scalars['Int']['input']>;
  losingTradesGTE?: InputMaybe<Scalars['Int']['input']>;
  losingTradesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  losingTradesIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  losingTradesLT?: InputMaybe<Scalars['Int']['input']>;
  losingTradesLTE?: InputMaybe<Scalars['Int']['input']>;
  losingTradesNEQ?: InputMaybe<Scalars['Int']['input']>;
  losingTradesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  losingTradesNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** max_drawdown field predicates */
  maxDrawdown?: InputMaybe<Scalars['Float']['input']>;
  /** max_drawdown_abs field predicates */
  maxDrawdownAbs?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsGT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsGTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownAbsIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  maxDrawdownAbsLT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsLTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsNEQ?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownAbsNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownAbsNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  maxDrawdownGT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownGTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  maxDrawdownLT?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownLTE?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownNEQ?: InputMaybe<Scalars['Float']['input']>;
  maxDrawdownNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  maxDrawdownNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<BotMetricsWhereInput>;
  /** open_trade_count field predicates */
  openTradeCount?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountGT?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountGTE?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  openTradeCountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  openTradeCountLT?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountLTE?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  openTradeCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  openTradeCountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<BotMetricsWhereInput>>;
  /** profit_all_coin field predicates */
  profitAllCoin?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinGT?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinGTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllCoinIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitAllCoinLT?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinLTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitAllCoinNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllCoinNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_all_percent field predicates */
  profitAllPercent?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentGT?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentGTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllPercentIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitAllPercentLT?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentLTE?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitAllPercentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAllPercentNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_closed_coin field predicates */
  profitClosedCoin?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinGT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinGTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedCoinIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitClosedCoinLT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinLTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitClosedCoinNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedCoinNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_closed_percent field predicates */
  profitClosedPercent?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentGT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentGTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedPercentIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitClosedPercentLT?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentLTE?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitClosedPercentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitClosedPercentNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** profit_factor field predicates */
  profitFactor?: InputMaybe<Scalars['Float']['input']>;
  profitFactorGT?: InputMaybe<Scalars['Float']['input']>;
  profitFactorGTE?: InputMaybe<Scalars['Float']['input']>;
  profitFactorIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitFactorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profitFactorLT?: InputMaybe<Scalars['Float']['input']>;
  profitFactorLTE?: InputMaybe<Scalars['Float']['input']>;
  profitFactorNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitFactorNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitFactorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** trade_count field predicates */
  tradeCount?: InputMaybe<Scalars['Int']['input']>;
  tradeCountGT?: InputMaybe<Scalars['Int']['input']>;
  tradeCountGTE?: InputMaybe<Scalars['Int']['input']>;
  tradeCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  tradeCountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  tradeCountLT?: InputMaybe<Scalars['Int']['input']>;
  tradeCountLTE?: InputMaybe<Scalars['Int']['input']>;
  tradeCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  tradeCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  tradeCountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** winning_trades field predicates */
  winningTrades?: InputMaybe<Scalars['Int']['input']>;
  winningTradesGT?: InputMaybe<Scalars['Int']['input']>;
  winningTradesGTE?: InputMaybe<Scalars['Int']['input']>;
  winningTradesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  winningTradesIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  winningTradesLT?: InputMaybe<Scalars['Int']['input']>;
  winningTradesLTE?: InputMaybe<Scalars['Int']['input']>;
  winningTradesNEQ?: InputMaybe<Scalars['Int']['input']>;
  winningTradesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  winningTradesNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** winrate field predicates */
  winrate?: InputMaybe<Scalars['Float']['input']>;
  winrateGT?: InputMaybe<Scalars['Float']['input']>;
  winrateGTE?: InputMaybe<Scalars['Float']['input']>;
  winrateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  winrateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  winrateLT?: InputMaybe<Scalars['Float']['input']>;
  winrateLTE?: InputMaybe<Scalars['Float']['input']>;
  winrateNEQ?: InputMaybe<Scalars['Float']['input']>;
  winrateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  winrateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BotRunner = Node & {
  __typename?: 'BotRunner';
  backtests: BacktestConnection;
  bots: BotConnection;
  /** Runner connection configuration (host, port, credentials, etc.) */
  config?: Maybe<Scalars['Map']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Data download configuration: {exchanges: [{name, enabled, timeframes, pairs_pattern, days, trading_mode}]} */
  dataDownloadConfig?: Maybe<Scalars['Map']['output']>;
  /** Progress details: {pairs_completed, pairs_total, current_pair, percent_complete} */
  dataDownloadProgress?: Maybe<Scalars['Map']['output']>;
  /** Current data download status (idle, downloading, completed, failed) */
  dataDownloadStatus: BotRunnerDataDownloadStatus;
  /** Error message if data download failed */
  dataErrorMessage?: Maybe<Scalars['String']['output']>;
  /** Whether runner has downloaded historical data for backtesting */
  dataIsReady: Scalars['Boolean']['output'];
  /** When data was last refreshed */
  dataLastUpdated?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** Runner display name */
  name: Scalars['String']['output'];
  /** Runner environment type (docker, kubernetes, local) */
  type: BotRunnerRunnerType;
  updatedAt: Scalars['Time']['output'];
};


export type BotRunnerBacktestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BacktestWhereInput>;
};


export type BotRunnerBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};

/** A connection to a list of items. */
export type BotRunnerConnection = {
  __typename?: 'BotRunnerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BotRunnerEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** BotRunnerDataDownloadStatus is enum for the field data_download_status */
export enum BotRunnerDataDownloadStatus {
  Completed = 'completed',
  Downloading = 'downloading',
  Failed = 'failed',
  Idle = 'idle'
}

/** An edge in a connection. */
export type BotRunnerEdge = {
  __typename?: 'BotRunnerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BotRunner>;
};

/** BotRunnerRunnerType is enum for the field type */
export enum BotRunnerRunnerType {
  Docker = 'docker',
  Kubernetes = 'kubernetes',
  Local = 'local'
}

/**
 * BotRunnerWhereInput is used for filtering BotRunner objects.
 * Input was generated by ent.
 */
export type BotRunnerWhereInput = {
  and?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** data_download_status field predicates */
  dataDownloadStatus?: InputMaybe<BotRunnerDataDownloadStatus>;
  dataDownloadStatusIn?: InputMaybe<Array<BotRunnerDataDownloadStatus>>;
  dataDownloadStatusNEQ?: InputMaybe<BotRunnerDataDownloadStatus>;
  dataDownloadStatusNotIn?: InputMaybe<Array<BotRunnerDataDownloadStatus>>;
  /** data_error_message field predicates */
  dataErrorMessage?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageContains?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageGT?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dataErrorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dataErrorMessageLT?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  dataErrorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dataErrorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** data_is_ready field predicates */
  dataIsReady?: InputMaybe<Scalars['Boolean']['input']>;
  dataIsReadyNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** data_last_updated field predicates */
  dataLastUpdated?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedGT?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedGTE?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dataLastUpdatedIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dataLastUpdatedLT?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedLTE?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedNEQ?: InputMaybe<Scalars['Time']['input']>;
  dataLastUpdatedNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dataLastUpdatedNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** backtests edge predicates */
  hasBacktests?: InputMaybe<Scalars['Boolean']['input']>;
  hasBacktestsWith?: InputMaybe<Array<BacktestWhereInput>>;
  /** bots edge predicates */
  hasBots?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotsWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<BotRunnerWhereInput>;
  or?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<BotRunnerRunnerType>;
  typeIn?: InputMaybe<Array<BotRunnerRunnerType>>;
  typeNEQ?: InputMaybe<BotRunnerRunnerType>;
  typeNotIn?: InputMaybe<Array<BotRunnerRunnerType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type BotStatus = {
  __typename?: 'BotStatus';
  botID: Scalars['String']['output'];
  containerID: Scalars['String']['output'];
  cpuUsage: Scalars['Float']['output'];
  createdAt: Scalars['Time']['output'];
  errorMessage: Scalars['String']['output'];
  healthy: Scalars['Boolean']['output'];
  hostPort: Scalars['Int']['output'];
  ipAddress: Scalars['String']['output'];
  lastSeenAt?: Maybe<Scalars['Time']['output']>;
  memoryUsage: Scalars['Int']['output'];
  startedAt?: Maybe<Scalars['Time']['output']>;
  status: BotBotStatus;
  stoppedAt?: Maybe<Scalars['Time']['output']>;
};

/**
 * BotWhereInput is used for filtering Bot objects.
 * Input was generated by ent.
 */
export type BotWhereInput = {
  and?: InputMaybe<Array<BotWhereInput>>;
  /** container_id field predicates */
  containerID?: InputMaybe<Scalars['String']['input']>;
  containerIDContains?: InputMaybe<Scalars['String']['input']>;
  containerIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  containerIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  containerIDGT?: InputMaybe<Scalars['String']['input']>;
  containerIDGTE?: InputMaybe<Scalars['String']['input']>;
  containerIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  containerIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  containerIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  containerIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  containerIDLT?: InputMaybe<Scalars['String']['input']>;
  containerIDLTE?: InputMaybe<Scalars['String']['input']>;
  containerIDNEQ?: InputMaybe<Scalars['String']['input']>;
  containerIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  containerIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** error_message field predicates */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  errorMessageContains?: InputMaybe<Scalars['String']['input']>;
  errorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  errorMessageGT?: InputMaybe<Scalars['String']['input']>;
  errorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  errorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  errorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  errorMessageLT?: InputMaybe<Scalars['String']['input']>;
  errorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  errorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  errorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** exchange_id field predicates */
  exchangeID?: InputMaybe<Scalars['ID']['input']>;
  exchangeIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  exchangeIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  exchangeIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** freqtrade_version field predicates */
  freqtradeVersion?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionContains?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionContainsFold?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionEqualFold?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionGT?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionGTE?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  freqtradeVersionLT?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionLTE?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionNEQ?: InputMaybe<Scalars['String']['input']>;
  freqtradeVersionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** exchange edge predicates */
  hasExchange?: InputMaybe<Scalars['Boolean']['input']>;
  hasExchangeWith?: InputMaybe<Array<ExchangeWhereInput>>;
  /** metrics edge predicates */
  hasMetrics?: InputMaybe<Scalars['Boolean']['input']>;
  hasMetricsWith?: InputMaybe<Array<BotMetricsWhereInput>>;
  /** runner edge predicates */
  hasRunner?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunnerWith?: InputMaybe<Array<BotRunnerWhereInput>>;
  /** strategy edge predicates */
  hasStrategy?: InputMaybe<Scalars['Boolean']['input']>;
  hasStrategyWith?: InputMaybe<Array<StrategyWhereInput>>;
  /** trades edge predicates */
  hasTrades?: InputMaybe<Scalars['Boolean']['input']>;
  hasTradesWith?: InputMaybe<Array<TradeWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_seen_at field predicates */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtGT?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtGTE?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSeenAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastSeenAtLT?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtLTE?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastSeenAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSeenAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** mode field predicates */
  mode?: InputMaybe<BotBotMode>;
  modeIn?: InputMaybe<Array<BotBotMode>>;
  modeNEQ?: InputMaybe<BotBotMode>;
  modeNotIn?: InputMaybe<Array<BotBotMode>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<BotWhereInput>;
  or?: InputMaybe<Array<BotWhereInput>>;
  /** runner_id field predicates */
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  runnerIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  runnerIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** status field predicates */
  status?: InputMaybe<BotBotStatus>;
  statusIn?: InputMaybe<Array<BotBotStatus>>;
  statusNEQ?: InputMaybe<BotBotStatus>;
  statusNotIn?: InputMaybe<Array<BotBotStatus>>;
  /** strategy_id field predicates */
  strategyID?: InputMaybe<Scalars['ID']['input']>;
  strategyIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  strategyIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  strategyIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type BybitConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

/**
 * CreateBacktestInput is used for create Backtest object.
 * Input was generated by ent.
 */
export type CreateBacktestInput = {
  /** Completion timestamp */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Backtest configuration (pairs, timeframe, dates, stake, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Docker container ID for running backtest */
  containerID?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Error message if backtest failed */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Backtest result data (metrics, logs, trades, etc.) */
  result?: InputMaybe<Scalars['Map']['input']>;
  runnerID: Scalars['ID']['input'];
  /** Task status */
  status?: InputMaybe<BacktestTaskStatus>;
  strategyID: Scalars['ID']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBotInput is used for create Bot object.
 * Input was generated by ent.
 */
export type CreateBotInput = {
  /** Complete freqtrade bot configuration (stake, pairlists, pricing, api_server, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Runner-specific identifier (container ID, pod name, etc.) */
  containerID?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Last error message if status is error */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  exchangeID: Scalars['ID']['input'];
  /** Freqtrade Docker image version tag */
  freqtradeVersion?: InputMaybe<Scalars['String']['input']>;
  /** Last successful health check */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>;
  metricsID?: InputMaybe<Scalars['ID']['input']>;
  /** Trading mode (dry-run or live) */
  mode?: InputMaybe<BotBotMode>;
  /** Bot display name */
  name: Scalars['String']['input'];
  runnerID: Scalars['ID']['input'];
  /** Bot lifecycle status */
  status?: InputMaybe<BotBotStatus>;
  strategyID: Scalars['ID']['input'];
  tradeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBotMetricsInput is used for create BotMetrics object.
 * Input was generated by ent.
 */
export type CreateBotMetricsInput = {
  /** Best performing trading pair */
  bestPair?: InputMaybe<Scalars['String']['input']>;
  /** Best trade profit rate */
  bestRate?: InputMaybe<Scalars['Float']['input']>;
  botID: Scalars['ID']['input'];
  /** Number of closed trades */
  closedTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Average profit per trade */
  expectancy?: InputMaybe<Scalars['Float']['input']>;
  /** When these metrics were fetched from Freqtrade API */
  fetchedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of first trade */
  firstTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of latest trade */
  latestTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Number of losing trades */
  losingTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum drawdown percentage */
  maxDrawdown?: InputMaybe<Scalars['Float']['input']>;
  /** Maximum drawdown absolute value */
  maxDrawdownAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Current number of open trades */
  openTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Total profit (closed + open) in coin */
  profitAllCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total profit (closed + open) percentage */
  profitAllPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit in coin */
  profitClosedCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit percentage */
  profitClosedPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Ratio of gross profit to gross loss */
  profitFactor?: InputMaybe<Scalars['Float']['input']>;
  /** Total number of trades */
  tradeCount?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Number of winning trades */
  winningTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Win rate percentage (0-100) */
  winrate?: InputMaybe<Scalars['Float']['input']>;
};

/**
 * CreateBotRunnerInput is used for create BotRunner object.
 * Input was generated by ent.
 */
export type CreateBotRunnerInput = {
  backtestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  botIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Runner connection configuration (host, port, credentials, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Data download configuration: {exchanges: [{name, enabled, timeframes, pairs_pattern, days, trading_mode}]} */
  dataDownloadConfig?: InputMaybe<Scalars['Map']['input']>;
  /** Progress details: {pairs_completed, pairs_total, current_pair, percent_complete} */
  dataDownloadProgress?: InputMaybe<Scalars['Map']['input']>;
  /** Current data download status (idle, downloading, completed, failed) */
  dataDownloadStatus?: InputMaybe<BotRunnerDataDownloadStatus>;
  /** Error message if data download failed */
  dataErrorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Whether runner has downloaded historical data for backtesting */
  dataIsReady?: InputMaybe<Scalars['Boolean']['input']>;
  /** When data was last refreshed */
  dataLastUpdated?: InputMaybe<Scalars['Time']['input']>;
  /** Runner display name */
  name: Scalars['String']['input'];
  /** Runner environment type (docker, kubernetes, local) */
  type?: InputMaybe<BotRunnerRunnerType>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateExchangeInput is used for create Exchange object.
 * Input was generated by ent.
 */
export type CreateExchangeInput = {
  botIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Complete freqtrade exchange configuration (name, key, secret, pair_whitelist, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Exchange display name (e.g., 'Binance Production', 'Coinbase Testnet') */
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateStrategyInput is used for create Strategy object.
 * Input was generated by ent.
 */
export type CreateStrategyInput = {
  backtestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  botIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Python strategy code */
  code: Scalars['String']['input'];
  /** Strategy-specific configuration (config.json) */
  config?: InputMaybe<Scalars['Map']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Strategy description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Strategy name */
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Strategy version */
  version?: InputMaybe<Scalars['String']['input']>;
};

/**
 * CreateTradeInput is used for create Trade object.
 * Input was generated by ent.
 */
export type CreateTradeInput = {
  /** Amount of coins */
  amount: Scalars['Float']['input'];
  botID: Scalars['ID']['input'];
  /** Trade close time */
  closeDate?: InputMaybe<Scalars['Time']['input']>;
  /** Exit price */
  closeRate?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Original trade ID from freqtrade */
  freqtradeTradeID: Scalars['Int']['input'];
  /** Trade open status */
  isOpen?: InputMaybe<Scalars['Boolean']['input']>;
  /** Trade open time */
  openDate: Scalars['Time']['input'];
  /** Entry price */
  openRate: Scalars['Float']['input'];
  /** Trading pair (BTC/USDT) */
  pair: Scalars['String']['input'];
  /** Absolute profit */
  profitAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Profit percentage (0.05 = 5%) */
  profitRatio?: InputMaybe<Scalars['Float']['input']>;
  /** Reason for selling (roi, stoploss, etc.) */
  sellReason?: InputMaybe<Scalars['String']['input']>;
  /** Stake in base currency */
  stakeAmount: Scalars['Float']['input'];
  /** Strategy used */
  strategyName?: InputMaybe<Scalars['String']['input']>;
  /** Timeframe used */
  timeframe?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

export type DataDownloadConfigInput = {
  exchanges: Array<DataDownloadExchangeConfigInput>;
};

export type DataDownloadExchangeConfigInput = {
  days?: InputMaybe<Scalars['Int']['input']>;
  enabled: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  pairsPattern?: InputMaybe<Scalars['String']['input']>;
  timeframes?: InputMaybe<Array<Scalars['String']['input']>>;
  tradingMode?: InputMaybe<Scalars['String']['input']>;
};

export type DockerConfigInput = {
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  caPath?: InputMaybe<Scalars['String']['input']>;
  certPath?: InputMaybe<Scalars['String']['input']>;
  host: Scalars['String']['input'];
  keyPath?: InputMaybe<Scalars['String']['input']>;
  network?: InputMaybe<Scalars['String']['input']>;
  registryAuth?: InputMaybe<RegistryAuthInput>;
  tlsVerify?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Exchange = Node & {
  __typename?: 'Exchange';
  bots: BotConnection;
  /** Complete freqtrade exchange configuration (name, key, secret, pair_whitelist, etc.) */
  config?: Maybe<Scalars['Map']['output']>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  /** Exchange display name (e.g., 'Binance Production', 'Coinbase Testnet') */
  name: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};


export type ExchangeBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};

export type ExchangeConfigInput = {
  binance?: InputMaybe<BinanceConfigInput>;
  binanceus?: InputMaybe<BinanceConfigInput>;
  bitfinex?: InputMaybe<BitfinexConfigInput>;
  bybit?: InputMaybe<BybitConfigInput>;
  coinbase?: InputMaybe<PassphraseExchangeConfigInput>;
  kraken?: InputMaybe<KrakenConfigInput>;
  kucoin?: InputMaybe<PassphraseExchangeConfigInput>;
  okx?: InputMaybe<PassphraseExchangeConfigInput>;
};

/**
 * ExchangeWhereInput is used for filtering Exchange objects.
 * Input was generated by ent.
 */
export type ExchangeWhereInput = {
  and?: InputMaybe<Array<ExchangeWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** bots edge predicates */
  hasBots?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotsWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ExchangeWhereInput>;
  or?: InputMaybe<Array<ExchangeWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type KrakenConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
};

export type KubernetesConfigInput = {
  context?: InputMaybe<Scalars['String']['input']>;
  kubeconfigPath?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
};

export type LocalConfigInput = {
  basePath?: InputMaybe<Scalars['String']['input']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createBacktest: Backtest;
  createBot: Bot;
  createBotRunner: BotRunner;
  createExchange: Exchange;
  createStrategy: Strategy;
  createTrade: Trade;
  deleteBacktest: Scalars['Boolean']['output'];
  deleteBot: Scalars['Boolean']['output'];
  deleteBotRunner: Scalars['Boolean']['output'];
  deleteExchange: Scalars['Boolean']['output'];
  deleteStrategy: Scalars['Boolean']['output'];
  deleteTrade: Scalars['Boolean']['output'];
  refreshRunnerData: BotRunner;
  restartBot: Bot;
  runBacktest: Backtest;
  startBot: Bot;
  stopBacktest: Backtest;
  stopBot: Bot;
  updateBacktest: Backtest;
  updateBot: Bot;
  updateBotRunner: BotRunner;
  updateExchange: Exchange;
  updateStrategy: Strategy;
  updateTrade: Trade;
};


export type MutationCreateBacktestArgs = {
  input: CreateBacktestInput;
};


export type MutationCreateBotArgs = {
  input: CreateBotInput;
};


export type MutationCreateBotRunnerArgs = {
  input: CreateBotRunnerInput;
};


export type MutationCreateExchangeArgs = {
  input: CreateExchangeInput;
};


export type MutationCreateStrategyArgs = {
  input: CreateStrategyInput;
};


export type MutationCreateTradeArgs = {
  input: CreateTradeInput;
};


export type MutationDeleteBacktestArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteBotRunnerArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteExchangeArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteStrategyArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteTradeArgs = {
  id: Scalars['ID']['input'];
};


export type MutationRefreshRunnerDataArgs = {
  id: Scalars['ID']['input'];
};


export type MutationRestartBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationRunBacktestArgs = {
  id: Scalars['ID']['input'];
};


export type MutationStartBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationStopBacktestArgs = {
  id: Scalars['ID']['input'];
};


export type MutationStopBotArgs = {
  id: Scalars['ID']['input'];
};


export type MutationUpdateBacktestArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBacktestInput;
};


export type MutationUpdateBotArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBotInput;
};


export type MutationUpdateBotRunnerArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBotRunnerInput;
};


export type MutationUpdateExchangeArgs = {
  id: Scalars['ID']['input'];
  input: UpdateExchangeInput;
};


export type MutationUpdateStrategyArgs = {
  id: Scalars['ID']['input'];
  input: UpdateStrategyInput;
};


export type MutationUpdateTradeArgs = {
  id: Scalars['ID']['input'];
  input: UpdateTradeInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type PassphraseExchangeConfigInput = {
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
  passphrase: Scalars['String']['input'];
};

export type Query = {
  __typename?: 'Query';
  backtests: BacktestConnection;
  botMetricsSlice: Array<BotMetrics>;
  botRunners: BotRunnerConnection;
  bots: BotConnection;
  exchanges: Array<Exchange>;
  getBotRunnerStatus?: Maybe<BotStatus>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  strategies: StrategyConnection;
  trades: TradeConnection;
};


export type QueryBacktestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BacktestWhereInput>;
};


export type QueryBotRunnersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotRunnerWhereInput>;
};


export type QueryBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};


export type QueryGetBotRunnerStatusArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryStrategiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<StrategyWhereInput>;
};


export type QueryTradesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TradeWhereInput>;
};

export type RegistryAuthInput = {
  password: Scalars['String']['input'];
  serverAddress?: InputMaybe<Scalars['String']['input']>;
  username: Scalars['String']['input'];
};

export type RunnerConfigInput = {
  docker?: InputMaybe<DockerConfigInput>;
  kubernetes?: InputMaybe<KubernetesConfigInput>;
  local?: InputMaybe<LocalConfigInput>;
};

export type Strategy = Node & {
  __typename?: 'Strategy';
  backtests: BacktestConnection;
  bots: BotConnection;
  /** Python strategy code */
  code: Scalars['String']['output'];
  /** Strategy-specific configuration (config.json) */
  config?: Maybe<Scalars['Map']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Strategy description */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Strategy name */
  name: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  /** Strategy version */
  version: Scalars['String']['output'];
};


export type StrategyBacktestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BacktestWhereInput>;
};


export type StrategyBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BotWhereInput>;
};

/** A connection to a list of items. */
export type StrategyConnection = {
  __typename?: 'StrategyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StrategyEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type StrategyEdge = {
  __typename?: 'StrategyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Strategy>;
};

/**
 * StrategyWhereInput is used for filtering Strategy objects.
 * Input was generated by ent.
 */
export type StrategyWhereInput = {
  and?: InputMaybe<Array<StrategyWhereInput>>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']['input']>;
  codeContains?: InputMaybe<Scalars['String']['input']>;
  codeContainsFold?: InputMaybe<Scalars['String']['input']>;
  codeEqualFold?: InputMaybe<Scalars['String']['input']>;
  codeGT?: InputMaybe<Scalars['String']['input']>;
  codeGTE?: InputMaybe<Scalars['String']['input']>;
  codeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  codeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  codeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  codeLT?: InputMaybe<Scalars['String']['input']>;
  codeLTE?: InputMaybe<Scalars['String']['input']>;
  codeNEQ?: InputMaybe<Scalars['String']['input']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** backtests edge predicates */
  hasBacktests?: InputMaybe<Scalars['Boolean']['input']>;
  hasBacktestsWith?: InputMaybe<Array<BacktestWhereInput>>;
  /** bots edge predicates */
  hasBots?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotsWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<StrategyWhereInput>;
  or?: InputMaybe<Array<StrategyWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** version field predicates */
  version?: InputMaybe<Scalars['String']['input']>;
  versionContains?: InputMaybe<Scalars['String']['input']>;
  versionContainsFold?: InputMaybe<Scalars['String']['input']>;
  versionEqualFold?: InputMaybe<Scalars['String']['input']>;
  versionGT?: InputMaybe<Scalars['String']['input']>;
  versionGTE?: InputMaybe<Scalars['String']['input']>;
  versionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  versionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  versionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  versionLT?: InputMaybe<Scalars['String']['input']>;
  versionLTE?: InputMaybe<Scalars['String']['input']>;
  versionNEQ?: InputMaybe<Scalars['String']['input']>;
  versionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Trade = Node & {
  __typename?: 'Trade';
  /** Amount of coins */
  amount: Scalars['Float']['output'];
  bot: Bot;
  /** Foreign key to bot */
  botID: Scalars['ID']['output'];
  /** Trade close time */
  closeDate?: Maybe<Scalars['Time']['output']>;
  /** Exit price */
  closeRate?: Maybe<Scalars['Float']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Original trade ID from freqtrade */
  freqtradeTradeID: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** Trade open status */
  isOpen: Scalars['Boolean']['output'];
  /** Trade open time */
  openDate: Scalars['Time']['output'];
  /** Entry price */
  openRate: Scalars['Float']['output'];
  /** Trading pair (BTC/USDT) */
  pair: Scalars['String']['output'];
  /** Absolute profit */
  profitAbs: Scalars['Float']['output'];
  /** Profit percentage (0.05 = 5%) */
  profitRatio: Scalars['Float']['output'];
  /** Reason for selling (roi, stoploss, etc.) */
  sellReason?: Maybe<Scalars['String']['output']>;
  /** Stake in base currency */
  stakeAmount: Scalars['Float']['output'];
  /** Strategy used */
  strategyName?: Maybe<Scalars['String']['output']>;
  /** Timeframe used */
  timeframe?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type TradeConnection = {
  __typename?: 'TradeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TradeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TradeEdge = {
  __typename?: 'TradeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Trade>;
};

/**
 * TradeWhereInput is used for filtering Trade objects.
 * Input was generated by ent.
 */
export type TradeWhereInput = {
  /** amount field predicates */
  amount?: InputMaybe<Scalars['Float']['input']>;
  amountGT?: InputMaybe<Scalars['Float']['input']>;
  amountGTE?: InputMaybe<Scalars['Float']['input']>;
  amountIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  amountLT?: InputMaybe<Scalars['Float']['input']>;
  amountLTE?: InputMaybe<Scalars['Float']['input']>;
  amountNEQ?: InputMaybe<Scalars['Float']['input']>;
  amountNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  and?: InputMaybe<Array<TradeWhereInput>>;
  /** bot_id field predicates */
  botID?: InputMaybe<Scalars['ID']['input']>;
  botIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  botIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  botIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** close_date field predicates */
  closeDate?: InputMaybe<Scalars['Time']['input']>;
  closeDateGT?: InputMaybe<Scalars['Time']['input']>;
  closeDateGTE?: InputMaybe<Scalars['Time']['input']>;
  closeDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  closeDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  closeDateLT?: InputMaybe<Scalars['Time']['input']>;
  closeDateLTE?: InputMaybe<Scalars['Time']['input']>;
  closeDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  closeDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  closeDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** close_rate field predicates */
  closeRate?: InputMaybe<Scalars['Float']['input']>;
  closeRateGT?: InputMaybe<Scalars['Float']['input']>;
  closeRateGTE?: InputMaybe<Scalars['Float']['input']>;
  closeRateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  closeRateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  closeRateLT?: InputMaybe<Scalars['Float']['input']>;
  closeRateLTE?: InputMaybe<Scalars['Float']['input']>;
  closeRateNEQ?: InputMaybe<Scalars['Float']['input']>;
  closeRateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  closeRateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** freqtrade_trade_id field predicates */
  freqtradeTradeID?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDGT?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDGTE?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  freqtradeTradeIDLT?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDLTE?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  freqtradeTradeIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** bot edge predicates */
  hasBot?: InputMaybe<Scalars['Boolean']['input']>;
  hasBotWith?: InputMaybe<Array<BotWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_open field predicates */
  isOpen?: InputMaybe<Scalars['Boolean']['input']>;
  isOpenNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<TradeWhereInput>;
  /** open_date field predicates */
  openDate?: InputMaybe<Scalars['Time']['input']>;
  openDateGT?: InputMaybe<Scalars['Time']['input']>;
  openDateGTE?: InputMaybe<Scalars['Time']['input']>;
  openDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  openDateLT?: InputMaybe<Scalars['Time']['input']>;
  openDateLTE?: InputMaybe<Scalars['Time']['input']>;
  openDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  openDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** open_rate field predicates */
  openRate?: InputMaybe<Scalars['Float']['input']>;
  openRateGT?: InputMaybe<Scalars['Float']['input']>;
  openRateGTE?: InputMaybe<Scalars['Float']['input']>;
  openRateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  openRateLT?: InputMaybe<Scalars['Float']['input']>;
  openRateLTE?: InputMaybe<Scalars['Float']['input']>;
  openRateNEQ?: InputMaybe<Scalars['Float']['input']>;
  openRateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  or?: InputMaybe<Array<TradeWhereInput>>;
  /** pair field predicates */
  pair?: InputMaybe<Scalars['String']['input']>;
  pairContains?: InputMaybe<Scalars['String']['input']>;
  pairContainsFold?: InputMaybe<Scalars['String']['input']>;
  pairEqualFold?: InputMaybe<Scalars['String']['input']>;
  pairGT?: InputMaybe<Scalars['String']['input']>;
  pairGTE?: InputMaybe<Scalars['String']['input']>;
  pairHasPrefix?: InputMaybe<Scalars['String']['input']>;
  pairHasSuffix?: InputMaybe<Scalars['String']['input']>;
  pairIn?: InputMaybe<Array<Scalars['String']['input']>>;
  pairLT?: InputMaybe<Scalars['String']['input']>;
  pairLTE?: InputMaybe<Scalars['String']['input']>;
  pairNEQ?: InputMaybe<Scalars['String']['input']>;
  pairNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** profit_abs field predicates */
  profitAbs?: InputMaybe<Scalars['Float']['input']>;
  profitAbsGT?: InputMaybe<Scalars['Float']['input']>;
  profitAbsGTE?: InputMaybe<Scalars['Float']['input']>;
  profitAbsIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitAbsLT?: InputMaybe<Scalars['Float']['input']>;
  profitAbsLTE?: InputMaybe<Scalars['Float']['input']>;
  profitAbsNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitAbsNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** profit_ratio field predicates */
  profitRatio?: InputMaybe<Scalars['Float']['input']>;
  profitRatioGT?: InputMaybe<Scalars['Float']['input']>;
  profitRatioGTE?: InputMaybe<Scalars['Float']['input']>;
  profitRatioIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  profitRatioLT?: InputMaybe<Scalars['Float']['input']>;
  profitRatioLTE?: InputMaybe<Scalars['Float']['input']>;
  profitRatioNEQ?: InputMaybe<Scalars['Float']['input']>;
  profitRatioNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** sell_reason field predicates */
  sellReason?: InputMaybe<Scalars['String']['input']>;
  sellReasonContains?: InputMaybe<Scalars['String']['input']>;
  sellReasonContainsFold?: InputMaybe<Scalars['String']['input']>;
  sellReasonEqualFold?: InputMaybe<Scalars['String']['input']>;
  sellReasonGT?: InputMaybe<Scalars['String']['input']>;
  sellReasonGTE?: InputMaybe<Scalars['String']['input']>;
  sellReasonHasPrefix?: InputMaybe<Scalars['String']['input']>;
  sellReasonHasSuffix?: InputMaybe<Scalars['String']['input']>;
  sellReasonIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sellReasonIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sellReasonLT?: InputMaybe<Scalars['String']['input']>;
  sellReasonLTE?: InputMaybe<Scalars['String']['input']>;
  sellReasonNEQ?: InputMaybe<Scalars['String']['input']>;
  sellReasonNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sellReasonNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** stake_amount field predicates */
  stakeAmount?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountGT?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountGTE?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  stakeAmountLT?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountLTE?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountNEQ?: InputMaybe<Scalars['Float']['input']>;
  stakeAmountNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** strategy_name field predicates */
  strategyName?: InputMaybe<Scalars['String']['input']>;
  strategyNameContains?: InputMaybe<Scalars['String']['input']>;
  strategyNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  strategyNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  strategyNameGT?: InputMaybe<Scalars['String']['input']>;
  strategyNameGTE?: InputMaybe<Scalars['String']['input']>;
  strategyNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  strategyNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  strategyNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  strategyNameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  strategyNameLT?: InputMaybe<Scalars['String']['input']>;
  strategyNameLTE?: InputMaybe<Scalars['String']['input']>;
  strategyNameNEQ?: InputMaybe<Scalars['String']['input']>;
  strategyNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  strategyNameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** timeframe field predicates */
  timeframe?: InputMaybe<Scalars['String']['input']>;
  timeframeContains?: InputMaybe<Scalars['String']['input']>;
  timeframeContainsFold?: InputMaybe<Scalars['String']['input']>;
  timeframeEqualFold?: InputMaybe<Scalars['String']['input']>;
  timeframeGT?: InputMaybe<Scalars['String']['input']>;
  timeframeGTE?: InputMaybe<Scalars['String']['input']>;
  timeframeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  timeframeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  timeframeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  timeframeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  timeframeLT?: InputMaybe<Scalars['String']['input']>;
  timeframeLTE?: InputMaybe<Scalars['String']['input']>;
  timeframeNEQ?: InputMaybe<Scalars['String']['input']>;
  timeframeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  timeframeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * UpdateBacktestInput is used for update Backtest object.
 * Input was generated by ent.
 */
export type UpdateBacktestInput = {
  clearCompletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearContainerID?: InputMaybe<Scalars['Boolean']['input']>;
  clearErrorMessage?: InputMaybe<Scalars['Boolean']['input']>;
  clearResult?: InputMaybe<Scalars['Boolean']['input']>;
  /** Completion timestamp */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Backtest configuration (pairs, timeframe, dates, stake, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Docker container ID for running backtest */
  containerID?: InputMaybe<Scalars['String']['input']>;
  /** Error message if backtest failed */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Backtest result data (metrics, logs, trades, etc.) */
  result?: InputMaybe<Scalars['Map']['input']>;
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  /** Task status */
  status?: InputMaybe<BacktestTaskStatus>;
  strategyID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateBotInput is used for update Bot object.
 * Input was generated by ent.
 */
export type UpdateBotInput = {
  addTradeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearContainerID?: InputMaybe<Scalars['Boolean']['input']>;
  clearErrorMessage?: InputMaybe<Scalars['Boolean']['input']>;
  clearLastSeenAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearMetrics?: InputMaybe<Scalars['Boolean']['input']>;
  clearTrades?: InputMaybe<Scalars['Boolean']['input']>;
  /** Complete freqtrade bot configuration (stake, pairlists, pricing, api_server, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Runner-specific identifier (container ID, pod name, etc.) */
  containerID?: InputMaybe<Scalars['String']['input']>;
  /** Last error message if status is error */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  exchangeID?: InputMaybe<Scalars['ID']['input']>;
  /** Freqtrade Docker image version tag */
  freqtradeVersion?: InputMaybe<Scalars['String']['input']>;
  /** Last successful health check */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>;
  metricsID?: InputMaybe<Scalars['ID']['input']>;
  /** Trading mode (dry-run or live) */
  mode?: InputMaybe<BotBotMode>;
  /** Bot display name */
  name?: InputMaybe<Scalars['String']['input']>;
  removeTradeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  runnerID?: InputMaybe<Scalars['ID']['input']>;
  /** Bot lifecycle status */
  status?: InputMaybe<BotBotStatus>;
  strategyID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateBotMetricsInput is used for update BotMetrics object.
 * Input was generated by ent.
 */
export type UpdateBotMetricsInput = {
  /** Best performing trading pair */
  bestPair?: InputMaybe<Scalars['String']['input']>;
  /** Best trade profit rate */
  bestRate?: InputMaybe<Scalars['Float']['input']>;
  botID?: InputMaybe<Scalars['ID']['input']>;
  clearBestPair?: InputMaybe<Scalars['Boolean']['input']>;
  clearBestRate?: InputMaybe<Scalars['Boolean']['input']>;
  clearClosedTradeCount?: InputMaybe<Scalars['Boolean']['input']>;
  clearExpectancy?: InputMaybe<Scalars['Boolean']['input']>;
  clearFirstTradeTimestamp?: InputMaybe<Scalars['Boolean']['input']>;
  clearLatestTradeTimestamp?: InputMaybe<Scalars['Boolean']['input']>;
  clearLosingTrades?: InputMaybe<Scalars['Boolean']['input']>;
  clearMaxDrawdown?: InputMaybe<Scalars['Boolean']['input']>;
  clearMaxDrawdownAbs?: InputMaybe<Scalars['Boolean']['input']>;
  clearOpenTradeCount?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitAllCoin?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitAllPercent?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitClosedCoin?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitClosedPercent?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfitFactor?: InputMaybe<Scalars['Boolean']['input']>;
  clearTradeCount?: InputMaybe<Scalars['Boolean']['input']>;
  clearWinningTrades?: InputMaybe<Scalars['Boolean']['input']>;
  clearWinrate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of closed trades */
  closedTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Average profit per trade */
  expectancy?: InputMaybe<Scalars['Float']['input']>;
  /** When these metrics were fetched from Freqtrade API */
  fetchedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of first trade */
  firstTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of latest trade */
  latestTradeTimestamp?: InputMaybe<Scalars['Time']['input']>;
  /** Number of losing trades */
  losingTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum drawdown percentage */
  maxDrawdown?: InputMaybe<Scalars['Float']['input']>;
  /** Maximum drawdown absolute value */
  maxDrawdownAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Current number of open trades */
  openTradeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Total profit (closed + open) in coin */
  profitAllCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total profit (closed + open) percentage */
  profitAllPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit in coin */
  profitClosedCoin?: InputMaybe<Scalars['Float']['input']>;
  /** Total closed profit percentage */
  profitClosedPercent?: InputMaybe<Scalars['Float']['input']>;
  /** Ratio of gross profit to gross loss */
  profitFactor?: InputMaybe<Scalars['Float']['input']>;
  /** Total number of trades */
  tradeCount?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Number of winning trades */
  winningTrades?: InputMaybe<Scalars['Int']['input']>;
  /** Win rate percentage (0-100) */
  winrate?: InputMaybe<Scalars['Float']['input']>;
};

/**
 * UpdateBotRunnerInput is used for update BotRunner object.
 * Input was generated by ent.
 */
export type UpdateBotRunnerInput = {
  addBacktestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearBacktests?: InputMaybe<Scalars['Boolean']['input']>;
  clearBots?: InputMaybe<Scalars['Boolean']['input']>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataDownloadConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataDownloadProgress?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataErrorMessage?: InputMaybe<Scalars['Boolean']['input']>;
  clearDataLastUpdated?: InputMaybe<Scalars['Boolean']['input']>;
  /** Runner connection configuration (host, port, credentials, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Data download configuration: {exchanges: [{name, enabled, timeframes, pairs_pattern, days, trading_mode}]} */
  dataDownloadConfig?: InputMaybe<Scalars['Map']['input']>;
  /** Progress details: {pairs_completed, pairs_total, current_pair, percent_complete} */
  dataDownloadProgress?: InputMaybe<Scalars['Map']['input']>;
  /** Current data download status (idle, downloading, completed, failed) */
  dataDownloadStatus?: InputMaybe<BotRunnerDataDownloadStatus>;
  /** Error message if data download failed */
  dataErrorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Whether runner has downloaded historical data for backtesting */
  dataIsReady?: InputMaybe<Scalars['Boolean']['input']>;
  /** When data was last refreshed */
  dataLastUpdated?: InputMaybe<Scalars['Time']['input']>;
  /** Runner display name */
  name?: InputMaybe<Scalars['String']['input']>;
  removeBacktestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Runner environment type (docker, kubernetes, local) */
  type?: InputMaybe<BotRunnerRunnerType>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateExchangeInput is used for update Exchange object.
 * Input was generated by ent.
 */
export type UpdateExchangeInput = {
  addBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearBots?: InputMaybe<Scalars['Boolean']['input']>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  /** Complete freqtrade exchange configuration (name, key, secret, pair_whitelist, etc.) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Exchange display name (e.g., 'Binance Production', 'Coinbase Testnet') */
  name?: InputMaybe<Scalars['String']['input']>;
  removeBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateStrategyInput is used for update Strategy object.
 * Input was generated by ent.
 */
export type UpdateStrategyInput = {
  addBacktestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearBacktests?: InputMaybe<Scalars['Boolean']['input']>;
  clearBots?: InputMaybe<Scalars['Boolean']['input']>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  /** Python strategy code */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Strategy-specific configuration (config.json) */
  config?: InputMaybe<Scalars['Map']['input']>;
  /** Strategy description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Strategy name */
  name?: InputMaybe<Scalars['String']['input']>;
  removeBacktestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeBotIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Strategy version */
  version?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateTradeInput is used for update Trade object.
 * Input was generated by ent.
 */
export type UpdateTradeInput = {
  /** Amount of coins */
  amount?: InputMaybe<Scalars['Float']['input']>;
  botID?: InputMaybe<Scalars['ID']['input']>;
  clearCloseDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearCloseRate?: InputMaybe<Scalars['Boolean']['input']>;
  clearSellReason?: InputMaybe<Scalars['Boolean']['input']>;
  clearStrategyName?: InputMaybe<Scalars['Boolean']['input']>;
  clearTimeframe?: InputMaybe<Scalars['Boolean']['input']>;
  /** Trade close time */
  closeDate?: InputMaybe<Scalars['Time']['input']>;
  /** Exit price */
  closeRate?: InputMaybe<Scalars['Float']['input']>;
  /** Original trade ID from freqtrade */
  freqtradeTradeID?: InputMaybe<Scalars['Int']['input']>;
  /** Trade open status */
  isOpen?: InputMaybe<Scalars['Boolean']['input']>;
  /** Trade open time */
  openDate?: InputMaybe<Scalars['Time']['input']>;
  /** Entry price */
  openRate?: InputMaybe<Scalars['Float']['input']>;
  /** Trading pair (BTC/USDT) */
  pair?: InputMaybe<Scalars['String']['input']>;
  /** Absolute profit */
  profitAbs?: InputMaybe<Scalars['Float']['input']>;
  /** Profit percentage (0.05 = 5%) */
  profitRatio?: InputMaybe<Scalars['Float']['input']>;
  /** Reason for selling (roi, stoploss, etc.) */
  sellReason?: InputMaybe<Scalars['String']['input']>;
  /** Stake in base currency */
  stakeAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Strategy used */
  strategyName?: InputMaybe<Scalars['String']['input']>;
  /** Timeframe used */
  timeframe?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

export type GetBacktestsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['Cursor']['input']>;
}>;


export type GetBacktestsQuery = { __typename?: 'Query', backtests: { __typename?: 'BacktestConnection', totalCount: number, edges?: Array<{ __typename?: 'BacktestEdge', node?: { __typename?: 'Backtest', id: string, status: BacktestTaskStatus, config?: any | null, result?: any | null, containerID?: string | null, errorMessage?: string | null, createdAt: string, updatedAt: string, completedAt?: string | null, strategy: { __typename?: 'Strategy', id: string, name: string }, runner: { __typename?: 'BotRunner', id: string, name: string, type: BotRunnerRunnerType } } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } } };

export type GetBacktestQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetBacktestQuery = { __typename?: 'Query', node?:
    | { __typename?: 'Backtest', id: string, status: BacktestTaskStatus, config?: any | null, result?: any | null, containerID?: string | null, errorMessage?: string | null, createdAt: string, updatedAt: string, completedAt?: string | null, strategy: { __typename?: 'Strategy', id: string, name: string, description?: string | null, version: string }, runner: { __typename?: 'BotRunner', id: string, name: string, type: BotRunnerRunnerType } }
    | { __typename?: 'Bot' }
    | { __typename?: 'BotMetrics' }
    | { __typename?: 'BotRunner' }
    | { __typename?: 'Exchange' }
    | { __typename?: 'Strategy' }
    | { __typename?: 'Trade' }
   | null };

export type GetBacktestOptionsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetBacktestOptionsQuery = { __typename?: 'Query', strategies: { __typename?: 'StrategyConnection', edges?: Array<{ __typename?: 'StrategyEdge', node?: { __typename?: 'Strategy', id: string, name: string } | null } | null> | null }, botRunners: { __typename?: 'BotRunnerConnection', edges?: Array<{ __typename?: 'BotRunnerEdge', node?: { __typename?: 'BotRunner', id: string, name: string, type: BotRunnerRunnerType } | null } | null> | null } };

export type CreateBacktestMutationVariables = Exact<{
  input: CreateBacktestInput;
}>;


export type CreateBacktestMutation = { __typename?: 'Mutation', createBacktest: { __typename?: 'Backtest', id: string, status: BacktestTaskStatus, config?: any | null, createdAt: string } };

export type UpdateBacktestMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  input: UpdateBacktestInput;
}>;


export type UpdateBacktestMutation = { __typename?: 'Mutation', updateBacktest: { __typename?: 'Backtest', id: string, status: BacktestTaskStatus, config?: any | null } };

export type DeleteBacktestMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteBacktestMutation = { __typename?: 'Mutation', deleteBacktest: boolean };

export type RunBacktestMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RunBacktestMutation = { __typename?: 'Mutation', runBacktest: { __typename?: 'Backtest', id: string, status: BacktestTaskStatus, containerID?: string | null } };

export type StopBacktestMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StopBacktestMutation = { __typename?: 'Mutation', stopBacktest: { __typename?: 'Backtest', id: string, status: BacktestTaskStatus } };

export type GetBotsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['Cursor']['input']>;
}>;


export type GetBotsQuery = { __typename?: 'Query', bots: { __typename?: 'BotConnection', totalCount: number, edges?: Array<{ __typename?: 'BotEdge', node?: { __typename?: 'Bot', id: string, name: string, status: BotBotStatus, mode: BotBotMode, containerID?: string | null, freqtradeVersion: string, lastSeenAt?: string | null, errorMessage?: string | null, createdAt: string, config?: any | null, exchange: { __typename?: 'Exchange', id: string, name: string }, strategy: { __typename?: 'Strategy', id: string, name: string }, runner: { __typename?: 'BotRunner', id: string, name: string, type: BotRunnerRunnerType } } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } } };

export type GetBotQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetBotQuery = { __typename?: 'Query', bots: { __typename?: 'BotConnection', edges?: Array<{ __typename?: 'BotEdge', node?: { __typename?: 'Bot', id: string, name: string, status: BotBotStatus, mode: BotBotMode, containerID?: string | null, freqtradeVersion: string, lastSeenAt?: string | null, errorMessage?: string | null, createdAt: string, updatedAt: string, config?: any | null, exchange: { __typename?: 'Exchange', id: string, name: string }, strategy: { __typename?: 'Strategy', id: string, name: string, description?: string | null, version: string }, runner: { __typename?: 'BotRunner', id: string, name: string, type: BotRunnerRunnerType }, metrics?: { __typename?: 'BotMetrics', id: string, profitClosedCoin?: number | null, profitClosedPercent?: number | null, profitAllCoin?: number | null, profitAllPercent?: number | null, tradeCount?: number | null, closedTradeCount?: number | null, openTradeCount?: number | null, winningTrades?: number | null, losingTrades?: number | null, winrate?: number | null, expectancy?: number | null, profitFactor?: number | null, maxDrawdown?: number | null, maxDrawdownAbs?: number | null, bestPair?: string | null, bestRate?: number | null, firstTradeTimestamp?: string | null, latestTradeTimestamp?: string | null, fetchedAt: string, updatedAt: string } | null, trades: { __typename?: 'TradeConnection', totalCount: number, edges?: Array<{ __typename?: 'TradeEdge', node?: { __typename?: 'Trade', id: string, pair: string, isOpen: boolean, openDate: string, closeDate?: string | null, profitAbs: number, profitRatio: number } | null } | null> | null } } | null } | null> | null } };

export type GetBotRunnerStatusQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetBotRunnerStatusQuery = { __typename?: 'Query', getBotRunnerStatus?: { __typename?: 'BotStatus', botID: string, status: BotBotStatus, containerID: string, healthy: boolean, lastSeenAt?: string | null, cpuUsage: number, memoryUsage: number, ipAddress: string, hostPort: number, errorMessage: string, createdAt: string, startedAt?: string | null, stoppedAt?: string | null } | null };

export type CreateBotMutationVariables = Exact<{
  input: CreateBotInput;
}>;


export type CreateBotMutation = { __typename?: 'Mutation', createBot: { __typename?: 'Bot', id: string, name: string, status: BotBotStatus, mode: BotBotMode, freqtradeVersion: string, config?: any | null } };

export type UpdateBotMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  input: UpdateBotInput;
}>;


export type UpdateBotMutation = { __typename?: 'Mutation', updateBot: { __typename?: 'Bot', id: string, name: string, status: BotBotStatus, mode: BotBotMode, config?: any | null } };

export type DeleteBotMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteBotMutation = { __typename?: 'Mutation', deleteBot: boolean };

export type StartBotMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StartBotMutation = { __typename?: 'Mutation', startBot: { __typename?: 'Bot', id: string, name: string, status: BotBotStatus } };

export type StopBotMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StopBotMutation = { __typename?: 'Mutation', stopBot: { __typename?: 'Bot', id: string, name: string, status: BotBotStatus } };

export type RestartBotMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RestartBotMutation = { __typename?: 'Mutation', restartBot: { __typename?: 'Bot', id: string, name: string, status: BotBotStatus } };

export type GetDashboardDataQueryVariables = Exact<{ [key: string]: never; }>;


export type GetDashboardDataQuery = { __typename?: 'Query', bots: { __typename?: 'BotConnection', totalCount: number, edges?: Array<{ __typename?: 'BotEdge', node?: { __typename?: 'Bot', id: string, name: string, status: BotBotStatus, mode: BotBotMode, freqtradeVersion: string, lastSeenAt?: string | null, exchange: { __typename?: 'Exchange', id: string, name: string }, strategy: { __typename?: 'Strategy', id: string, name: string } } | null } | null> | null }, trades: { __typename?: 'TradeConnection', totalCount: number, edges?: Array<{ __typename?: 'TradeEdge', node?: { __typename?: 'Trade', id: string, pair: string, isOpen: boolean, openDate: string, closeDate?: string | null, profitAbs: number, profitRatio: number, bot: { __typename?: 'Bot', id: string, name: string } } | null } | null> | null }, exchanges: Array<{ __typename?: 'Exchange', id: string, name: string }>, strategies: { __typename?: 'StrategyConnection', totalCount: number, edges?: Array<{ __typename?: 'StrategyEdge', node?: { __typename?: 'Strategy', id: string, name: string, version: string } | null } | null> | null } };

export type GetExchangesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetExchangesQuery = { __typename?: 'Query', exchanges: Array<{ __typename?: 'Exchange', id: string, name: string, config?: any | null, createdAt: string, updatedAt: string, bots: { __typename?: 'BotConnection', totalCount: number } }> };

export type GetExchangeQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetExchangeQuery = { __typename?: 'Query', node?:
    | { __typename?: 'Backtest' }
    | { __typename?: 'Bot' }
    | { __typename?: 'BotMetrics' }
    | { __typename?: 'BotRunner' }
    | { __typename?: 'Exchange', id: string, name: string, config?: any | null, createdAt: string, updatedAt: string, bots: { __typename?: 'BotConnection', totalCount: number, edges?: Array<{ __typename?: 'BotEdge', node?: { __typename?: 'Bot', id: string, name: string, status: BotBotStatus } | null } | null> | null } }
    | { __typename?: 'Strategy' }
    | { __typename?: 'Trade' }
   | null };

export type CreateExchangeMutationVariables = Exact<{
  input: CreateExchangeInput;
}>;


export type CreateExchangeMutation = { __typename?: 'Mutation', createExchange: { __typename?: 'Exchange', id: string, name: string, config?: any | null } };

export type UpdateExchangeMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  input: UpdateExchangeInput;
}>;


export type UpdateExchangeMutation = { __typename?: 'Mutation', updateExchange: { __typename?: 'Exchange', id: string, name: string, config?: any | null } };

export type DeleteExchangeMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteExchangeMutation = { __typename?: 'Mutation', deleteExchange: boolean };

export type GetBotsCountQueryVariables = Exact<{ [key: string]: never; }>;


export type GetBotsCountQuery = { __typename?: 'Query', bots: { __typename?: 'BotConnection', totalCount: number } };

export type GetExchangesForLayoutQueryVariables = Exact<{ [key: string]: never; }>;


export type GetExchangesForLayoutQuery = { __typename?: 'Query', exchanges: Array<{ __typename?: 'Exchange', id: string, name: string }> };

export type GetRunnersQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['Cursor']['input']>;
}>;


export type GetRunnersQuery = { __typename?: 'Query', botRunners: { __typename?: 'BotRunnerConnection', totalCount: number, edges?: Array<{ __typename?: 'BotRunnerEdge', node?: { __typename?: 'BotRunner', id: string, name: string, type: BotRunnerRunnerType, createdAt: string, dataIsReady: boolean, dataLastUpdated?: string | null, dataDownloadStatus: BotRunnerDataDownloadStatus, dataDownloadProgress?: any | null, dataDownloadConfig?: any | null, dataErrorMessage?: string | null, bots: { __typename?: 'BotConnection', totalCount: number } } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } } };

export type GetRunnerQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetRunnerQuery = { __typename?: 'Query', node?:
    | { __typename?: 'Backtest' }
    | { __typename?: 'Bot' }
    | { __typename?: 'BotMetrics' }
    | { __typename?: 'BotRunner', id: string, name: string, type: BotRunnerRunnerType, createdAt: string, dataIsReady: boolean, dataLastUpdated?: string | null, dataDownloadStatus: BotRunnerDataDownloadStatus, dataDownloadProgress?: any | null, dataDownloadConfig?: any | null, dataErrorMessage?: string | null, bots: { __typename?: 'BotConnection', totalCount: number } }
    | { __typename?: 'Exchange' }
    | { __typename?: 'Strategy' }
    | { __typename?: 'Trade' }
   | null };

export type CreateRunnerMutationVariables = Exact<{
  input: CreateBotRunnerInput;
}>;


export type CreateRunnerMutation = { __typename?: 'Mutation', createBotRunner: { __typename?: 'BotRunner', id: string, name: string, type: BotRunnerRunnerType, dataDownloadConfig?: any | null } };

export type UpdateRunnerMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  input: UpdateBotRunnerInput;
}>;


export type UpdateRunnerMutation = { __typename?: 'Mutation', updateBotRunner: { __typename?: 'BotRunner', id: string, name: string, type: BotRunnerRunnerType, dataDownloadConfig?: any | null } };

export type DeleteRunnerMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteRunnerMutation = { __typename?: 'Mutation', deleteBotRunner: boolean };

export type RefreshRunnerDataMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RefreshRunnerDataMutation = { __typename?: 'Mutation', refreshRunnerData: { __typename?: 'BotRunner', id: string, name: string, type: BotRunnerRunnerType, dataIsReady: boolean, dataLastUpdated?: string | null, dataDownloadStatus: BotRunnerDataDownloadStatus, dataDownloadProgress?: any | null, dataErrorMessage?: string | null } };

export type GetStrategiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['Cursor']['input']>;
}>;


export type GetStrategiesQuery = { __typename?: 'Query', strategies: { __typename?: 'StrategyConnection', totalCount: number, edges?: Array<{ __typename?: 'StrategyEdge', node?: { __typename?: 'Strategy', id: string, name: string, description?: string | null, code: string, version: string, config?: any | null, createdAt: string, bots: { __typename?: 'BotConnection', totalCount: number } } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } } };

export type CreateStrategyMutationVariables = Exact<{
  input: CreateStrategyInput;
}>;


export type CreateStrategyMutation = { __typename?: 'Mutation', createStrategy: { __typename?: 'Strategy', id: string, name: string, description?: string | null, code: string, version: string, config?: any | null } };

export type UpdateStrategyMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  input: UpdateStrategyInput;
}>;


export type UpdateStrategyMutation = { __typename?: 'Mutation', updateStrategy: { __typename?: 'Strategy', id: string, name: string, description?: string | null, code: string, version: string, config?: any | null } };

export type DeleteStrategyMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteStrategyMutation = { __typename?: 'Mutation', deleteStrategy: boolean };


export const GetBacktestsDocument = gql`
    query GetBacktests($first: Int, $after: Cursor) {
  backtests(first: $first, after: $after) {
    edges {
      node {
        id
        status
        config
        result
        containerID
        errorMessage
        createdAt
        updatedAt
        completedAt
        strategy {
          id
          name
        }
        runner {
          id
          name
          type
        }
      }
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
  }
}
    `;

/**
 * __useGetBacktestsQuery__
 *
 * To run a query within a React component, call `useGetBacktestsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBacktestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBacktestsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useGetBacktestsQuery(baseOptions?: Apollo.QueryHookOptions<GetBacktestsQuery, GetBacktestsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBacktestsQuery, GetBacktestsQueryVariables>(GetBacktestsDocument, options);
      }
export function useGetBacktestsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBacktestsQuery, GetBacktestsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBacktestsQuery, GetBacktestsQueryVariables>(GetBacktestsDocument, options);
        }
export function useGetBacktestsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBacktestsQuery, GetBacktestsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBacktestsQuery, GetBacktestsQueryVariables>(GetBacktestsDocument, options);
        }
export type GetBacktestsQueryHookResult = ReturnType<typeof useGetBacktestsQuery>;
export type GetBacktestsLazyQueryHookResult = ReturnType<typeof useGetBacktestsLazyQuery>;
export type GetBacktestsSuspenseQueryHookResult = ReturnType<typeof useGetBacktestsSuspenseQuery>;
export type GetBacktestsQueryResult = Apollo.QueryResult<GetBacktestsQuery, GetBacktestsQueryVariables>;
export const GetBacktestDocument = gql`
    query GetBacktest($id: ID!) {
  node(id: $id) {
    ... on Backtest {
      id
      status
      config
      result
      containerID
      errorMessage
      createdAt
      updatedAt
      completedAt
      strategy {
        id
        name
        description
        version
      }
      runner {
        id
        name
        type
      }
    }
  }
}
    `;

/**
 * __useGetBacktestQuery__
 *
 * To run a query within a React component, call `useGetBacktestQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBacktestQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBacktestQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBacktestQuery(baseOptions: Apollo.QueryHookOptions<GetBacktestQuery, GetBacktestQueryVariables> & ({ variables: GetBacktestQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBacktestQuery, GetBacktestQueryVariables>(GetBacktestDocument, options);
      }
export function useGetBacktestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBacktestQuery, GetBacktestQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBacktestQuery, GetBacktestQueryVariables>(GetBacktestDocument, options);
        }
export function useGetBacktestSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBacktestQuery, GetBacktestQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBacktestQuery, GetBacktestQueryVariables>(GetBacktestDocument, options);
        }
export type GetBacktestQueryHookResult = ReturnType<typeof useGetBacktestQuery>;
export type GetBacktestLazyQueryHookResult = ReturnType<typeof useGetBacktestLazyQuery>;
export type GetBacktestSuspenseQueryHookResult = ReturnType<typeof useGetBacktestSuspenseQuery>;
export type GetBacktestQueryResult = Apollo.QueryResult<GetBacktestQuery, GetBacktestQueryVariables>;
export const GetBacktestOptionsDocument = gql`
    query GetBacktestOptions {
  strategies(first: 50) {
    edges {
      node {
        id
        name
      }
    }
  }
  botRunners(first: 50) {
    edges {
      node {
        id
        name
        type
      }
    }
  }
}
    `;

/**
 * __useGetBacktestOptionsQuery__
 *
 * To run a query within a React component, call `useGetBacktestOptionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBacktestOptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBacktestOptionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetBacktestOptionsQuery(baseOptions?: Apollo.QueryHookOptions<GetBacktestOptionsQuery, GetBacktestOptionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBacktestOptionsQuery, GetBacktestOptionsQueryVariables>(GetBacktestOptionsDocument, options);
      }
export function useGetBacktestOptionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBacktestOptionsQuery, GetBacktestOptionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBacktestOptionsQuery, GetBacktestOptionsQueryVariables>(GetBacktestOptionsDocument, options);
        }
export function useGetBacktestOptionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBacktestOptionsQuery, GetBacktestOptionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBacktestOptionsQuery, GetBacktestOptionsQueryVariables>(GetBacktestOptionsDocument, options);
        }
export type GetBacktestOptionsQueryHookResult = ReturnType<typeof useGetBacktestOptionsQuery>;
export type GetBacktestOptionsLazyQueryHookResult = ReturnType<typeof useGetBacktestOptionsLazyQuery>;
export type GetBacktestOptionsSuspenseQueryHookResult = ReturnType<typeof useGetBacktestOptionsSuspenseQuery>;
export type GetBacktestOptionsQueryResult = Apollo.QueryResult<GetBacktestOptionsQuery, GetBacktestOptionsQueryVariables>;
export const CreateBacktestDocument = gql`
    mutation CreateBacktest($input: CreateBacktestInput!) {
  createBacktest(input: $input) {
    id
    status
    config
    createdAt
  }
}
    `;
export type CreateBacktestMutationFn = Apollo.MutationFunction<CreateBacktestMutation, CreateBacktestMutationVariables>;

/**
 * __useCreateBacktestMutation__
 *
 * To run a mutation, you first call `useCreateBacktestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBacktestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBacktestMutation, { data, loading, error }] = useCreateBacktestMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateBacktestMutation(baseOptions?: Apollo.MutationHookOptions<CreateBacktestMutation, CreateBacktestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateBacktestMutation, CreateBacktestMutationVariables>(CreateBacktestDocument, options);
      }
export type CreateBacktestMutationHookResult = ReturnType<typeof useCreateBacktestMutation>;
export type CreateBacktestMutationResult = Apollo.MutationResult<CreateBacktestMutation>;
export type CreateBacktestMutationOptions = Apollo.BaseMutationOptions<CreateBacktestMutation, CreateBacktestMutationVariables>;
export const UpdateBacktestDocument = gql`
    mutation UpdateBacktest($id: ID!, $input: UpdateBacktestInput!) {
  updateBacktest(id: $id, input: $input) {
    id
    status
    config
  }
}
    `;
export type UpdateBacktestMutationFn = Apollo.MutationFunction<UpdateBacktestMutation, UpdateBacktestMutationVariables>;

/**
 * __useUpdateBacktestMutation__
 *
 * To run a mutation, you first call `useUpdateBacktestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBacktestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBacktestMutation, { data, loading, error }] = useUpdateBacktestMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBacktestMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBacktestMutation, UpdateBacktestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBacktestMutation, UpdateBacktestMutationVariables>(UpdateBacktestDocument, options);
      }
export type UpdateBacktestMutationHookResult = ReturnType<typeof useUpdateBacktestMutation>;
export type UpdateBacktestMutationResult = Apollo.MutationResult<UpdateBacktestMutation>;
export type UpdateBacktestMutationOptions = Apollo.BaseMutationOptions<UpdateBacktestMutation, UpdateBacktestMutationVariables>;
export const DeleteBacktestDocument = gql`
    mutation DeleteBacktest($id: ID!) {
  deleteBacktest(id: $id)
}
    `;
export type DeleteBacktestMutationFn = Apollo.MutationFunction<DeleteBacktestMutation, DeleteBacktestMutationVariables>;

/**
 * __useDeleteBacktestMutation__
 *
 * To run a mutation, you first call `useDeleteBacktestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBacktestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBacktestMutation, { data, loading, error }] = useDeleteBacktestMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteBacktestMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBacktestMutation, DeleteBacktestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBacktestMutation, DeleteBacktestMutationVariables>(DeleteBacktestDocument, options);
      }
export type DeleteBacktestMutationHookResult = ReturnType<typeof useDeleteBacktestMutation>;
export type DeleteBacktestMutationResult = Apollo.MutationResult<DeleteBacktestMutation>;
export type DeleteBacktestMutationOptions = Apollo.BaseMutationOptions<DeleteBacktestMutation, DeleteBacktestMutationVariables>;
export const RunBacktestDocument = gql`
    mutation RunBacktest($id: ID!) {
  runBacktest(id: $id) {
    id
    status
    containerID
  }
}
    `;
export type RunBacktestMutationFn = Apollo.MutationFunction<RunBacktestMutation, RunBacktestMutationVariables>;

/**
 * __useRunBacktestMutation__
 *
 * To run a mutation, you first call `useRunBacktestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRunBacktestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [runBacktestMutation, { data, loading, error }] = useRunBacktestMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRunBacktestMutation(baseOptions?: Apollo.MutationHookOptions<RunBacktestMutation, RunBacktestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RunBacktestMutation, RunBacktestMutationVariables>(RunBacktestDocument, options);
      }
export type RunBacktestMutationHookResult = ReturnType<typeof useRunBacktestMutation>;
export type RunBacktestMutationResult = Apollo.MutationResult<RunBacktestMutation>;
export type RunBacktestMutationOptions = Apollo.BaseMutationOptions<RunBacktestMutation, RunBacktestMutationVariables>;
export const StopBacktestDocument = gql`
    mutation StopBacktest($id: ID!) {
  stopBacktest(id: $id) {
    id
    status
  }
}
    `;
export type StopBacktestMutationFn = Apollo.MutationFunction<StopBacktestMutation, StopBacktestMutationVariables>;

/**
 * __useStopBacktestMutation__
 *
 * To run a mutation, you first call `useStopBacktestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStopBacktestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [stopBacktestMutation, { data, loading, error }] = useStopBacktestMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStopBacktestMutation(baseOptions?: Apollo.MutationHookOptions<StopBacktestMutation, StopBacktestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StopBacktestMutation, StopBacktestMutationVariables>(StopBacktestDocument, options);
      }
export type StopBacktestMutationHookResult = ReturnType<typeof useStopBacktestMutation>;
export type StopBacktestMutationResult = Apollo.MutationResult<StopBacktestMutation>;
export type StopBacktestMutationOptions = Apollo.BaseMutationOptions<StopBacktestMutation, StopBacktestMutationVariables>;
export const GetBotsDocument = gql`
    query GetBots($first: Int, $after: Cursor) {
  bots(first: $first, after: $after) {
    edges {
      node {
        id
        name
        status
        mode
        containerID
        freqtradeVersion
        lastSeenAt
        errorMessage
        createdAt
        config
        exchange {
          id
          name
        }
        strategy {
          id
          name
        }
        runner {
          id
          name
          type
        }
      }
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
  }
}
    `;

/**
 * __useGetBotsQuery__
 *
 * To run a query within a React component, call `useGetBotsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBotsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBotsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useGetBotsQuery(baseOptions?: Apollo.QueryHookOptions<GetBotsQuery, GetBotsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBotsQuery, GetBotsQueryVariables>(GetBotsDocument, options);
      }
export function useGetBotsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBotsQuery, GetBotsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBotsQuery, GetBotsQueryVariables>(GetBotsDocument, options);
        }
export function useGetBotsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBotsQuery, GetBotsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBotsQuery, GetBotsQueryVariables>(GetBotsDocument, options);
        }
export type GetBotsQueryHookResult = ReturnType<typeof useGetBotsQuery>;
export type GetBotsLazyQueryHookResult = ReturnType<typeof useGetBotsLazyQuery>;
export type GetBotsSuspenseQueryHookResult = ReturnType<typeof useGetBotsSuspenseQuery>;
export type GetBotsQueryResult = Apollo.QueryResult<GetBotsQuery, GetBotsQueryVariables>;
export const GetBotDocument = gql`
    query GetBot($id: ID!) {
  bots(where: {id: $id}, first: 1) {
    edges {
      node {
        id
        name
        status
        mode
        containerID
        freqtradeVersion
        lastSeenAt
        errorMessage
        createdAt
        updatedAt
        config
        exchange {
          id
          name
        }
        strategy {
          id
          name
          description
          version
        }
        runner {
          id
          name
          type
        }
        metrics {
          id
          profitClosedCoin
          profitClosedPercent
          profitAllCoin
          profitAllPercent
          tradeCount
          closedTradeCount
          openTradeCount
          winningTrades
          losingTrades
          winrate
          expectancy
          profitFactor
          maxDrawdown
          maxDrawdownAbs
          bestPair
          bestRate
          firstTradeTimestamp
          latestTradeTimestamp
          fetchedAt
          updatedAt
        }
        trades(first: 10) {
          edges {
            node {
              id
              pair
              isOpen
              openDate
              closeDate
              profitAbs
              profitRatio
            }
          }
          totalCount
        }
      }
    }
  }
}
    `;

/**
 * __useGetBotQuery__
 *
 * To run a query within a React component, call `useGetBotQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBotQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBotQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBotQuery(baseOptions: Apollo.QueryHookOptions<GetBotQuery, GetBotQueryVariables> & ({ variables: GetBotQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBotQuery, GetBotQueryVariables>(GetBotDocument, options);
      }
export function useGetBotLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBotQuery, GetBotQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBotQuery, GetBotQueryVariables>(GetBotDocument, options);
        }
export function useGetBotSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBotQuery, GetBotQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBotQuery, GetBotQueryVariables>(GetBotDocument, options);
        }
export type GetBotQueryHookResult = ReturnType<typeof useGetBotQuery>;
export type GetBotLazyQueryHookResult = ReturnType<typeof useGetBotLazyQuery>;
export type GetBotSuspenseQueryHookResult = ReturnType<typeof useGetBotSuspenseQuery>;
export type GetBotQueryResult = Apollo.QueryResult<GetBotQuery, GetBotQueryVariables>;
export const GetBotRunnerStatusDocument = gql`
    query GetBotRunnerStatus($id: ID!) {
  getBotRunnerStatus(id: $id) {
    botID
    status
    containerID
    healthy
    lastSeenAt
    cpuUsage
    memoryUsage
    ipAddress
    hostPort
    errorMessage
    createdAt
    startedAt
    stoppedAt
  }
}
    `;

/**
 * __useGetBotRunnerStatusQuery__
 *
 * To run a query within a React component, call `useGetBotRunnerStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBotRunnerStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBotRunnerStatusQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBotRunnerStatusQuery(baseOptions: Apollo.QueryHookOptions<GetBotRunnerStatusQuery, GetBotRunnerStatusQueryVariables> & ({ variables: GetBotRunnerStatusQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBotRunnerStatusQuery, GetBotRunnerStatusQueryVariables>(GetBotRunnerStatusDocument, options);
      }
export function useGetBotRunnerStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBotRunnerStatusQuery, GetBotRunnerStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBotRunnerStatusQuery, GetBotRunnerStatusQueryVariables>(GetBotRunnerStatusDocument, options);
        }
export function useGetBotRunnerStatusSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBotRunnerStatusQuery, GetBotRunnerStatusQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBotRunnerStatusQuery, GetBotRunnerStatusQueryVariables>(GetBotRunnerStatusDocument, options);
        }
export type GetBotRunnerStatusQueryHookResult = ReturnType<typeof useGetBotRunnerStatusQuery>;
export type GetBotRunnerStatusLazyQueryHookResult = ReturnType<typeof useGetBotRunnerStatusLazyQuery>;
export type GetBotRunnerStatusSuspenseQueryHookResult = ReturnType<typeof useGetBotRunnerStatusSuspenseQuery>;
export type GetBotRunnerStatusQueryResult = Apollo.QueryResult<GetBotRunnerStatusQuery, GetBotRunnerStatusQueryVariables>;
export const CreateBotDocument = gql`
    mutation CreateBot($input: CreateBotInput!) {
  createBot(input: $input) {
    id
    name
    status
    mode
    freqtradeVersion
    config
  }
}
    `;
export type CreateBotMutationFn = Apollo.MutationFunction<CreateBotMutation, CreateBotMutationVariables>;

/**
 * __useCreateBotMutation__
 *
 * To run a mutation, you first call `useCreateBotMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBotMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBotMutation, { data, loading, error }] = useCreateBotMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateBotMutation(baseOptions?: Apollo.MutationHookOptions<CreateBotMutation, CreateBotMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateBotMutation, CreateBotMutationVariables>(CreateBotDocument, options);
      }
export type CreateBotMutationHookResult = ReturnType<typeof useCreateBotMutation>;
export type CreateBotMutationResult = Apollo.MutationResult<CreateBotMutation>;
export type CreateBotMutationOptions = Apollo.BaseMutationOptions<CreateBotMutation, CreateBotMutationVariables>;
export const UpdateBotDocument = gql`
    mutation UpdateBot($id: ID!, $input: UpdateBotInput!) {
  updateBot(id: $id, input: $input) {
    id
    name
    status
    mode
    config
  }
}
    `;
export type UpdateBotMutationFn = Apollo.MutationFunction<UpdateBotMutation, UpdateBotMutationVariables>;

/**
 * __useUpdateBotMutation__
 *
 * To run a mutation, you first call `useUpdateBotMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBotMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBotMutation, { data, loading, error }] = useUpdateBotMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBotMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBotMutation, UpdateBotMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBotMutation, UpdateBotMutationVariables>(UpdateBotDocument, options);
      }
export type UpdateBotMutationHookResult = ReturnType<typeof useUpdateBotMutation>;
export type UpdateBotMutationResult = Apollo.MutationResult<UpdateBotMutation>;
export type UpdateBotMutationOptions = Apollo.BaseMutationOptions<UpdateBotMutation, UpdateBotMutationVariables>;
export const DeleteBotDocument = gql`
    mutation DeleteBot($id: ID!) {
  deleteBot(id: $id)
}
    `;
export type DeleteBotMutationFn = Apollo.MutationFunction<DeleteBotMutation, DeleteBotMutationVariables>;

/**
 * __useDeleteBotMutation__
 *
 * To run a mutation, you first call `useDeleteBotMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBotMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBotMutation, { data, loading, error }] = useDeleteBotMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteBotMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBotMutation, DeleteBotMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBotMutation, DeleteBotMutationVariables>(DeleteBotDocument, options);
      }
export type DeleteBotMutationHookResult = ReturnType<typeof useDeleteBotMutation>;
export type DeleteBotMutationResult = Apollo.MutationResult<DeleteBotMutation>;
export type DeleteBotMutationOptions = Apollo.BaseMutationOptions<DeleteBotMutation, DeleteBotMutationVariables>;
export const StartBotDocument = gql`
    mutation StartBot($id: ID!) {
  startBot(id: $id) {
    id
    name
    status
  }
}
    `;
export type StartBotMutationFn = Apollo.MutationFunction<StartBotMutation, StartBotMutationVariables>;

/**
 * __useStartBotMutation__
 *
 * To run a mutation, you first call `useStartBotMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStartBotMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [startBotMutation, { data, loading, error }] = useStartBotMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStartBotMutation(baseOptions?: Apollo.MutationHookOptions<StartBotMutation, StartBotMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StartBotMutation, StartBotMutationVariables>(StartBotDocument, options);
      }
export type StartBotMutationHookResult = ReturnType<typeof useStartBotMutation>;
export type StartBotMutationResult = Apollo.MutationResult<StartBotMutation>;
export type StartBotMutationOptions = Apollo.BaseMutationOptions<StartBotMutation, StartBotMutationVariables>;
export const StopBotDocument = gql`
    mutation StopBot($id: ID!) {
  stopBot(id: $id) {
    id
    name
    status
  }
}
    `;
export type StopBotMutationFn = Apollo.MutationFunction<StopBotMutation, StopBotMutationVariables>;

/**
 * __useStopBotMutation__
 *
 * To run a mutation, you first call `useStopBotMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStopBotMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [stopBotMutation, { data, loading, error }] = useStopBotMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStopBotMutation(baseOptions?: Apollo.MutationHookOptions<StopBotMutation, StopBotMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StopBotMutation, StopBotMutationVariables>(StopBotDocument, options);
      }
export type StopBotMutationHookResult = ReturnType<typeof useStopBotMutation>;
export type StopBotMutationResult = Apollo.MutationResult<StopBotMutation>;
export type StopBotMutationOptions = Apollo.BaseMutationOptions<StopBotMutation, StopBotMutationVariables>;
export const RestartBotDocument = gql`
    mutation RestartBot($id: ID!) {
  restartBot(id: $id) {
    id
    name
    status
  }
}
    `;
export type RestartBotMutationFn = Apollo.MutationFunction<RestartBotMutation, RestartBotMutationVariables>;

/**
 * __useRestartBotMutation__
 *
 * To run a mutation, you first call `useRestartBotMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRestartBotMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [restartBotMutation, { data, loading, error }] = useRestartBotMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRestartBotMutation(baseOptions?: Apollo.MutationHookOptions<RestartBotMutation, RestartBotMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RestartBotMutation, RestartBotMutationVariables>(RestartBotDocument, options);
      }
export type RestartBotMutationHookResult = ReturnType<typeof useRestartBotMutation>;
export type RestartBotMutationResult = Apollo.MutationResult<RestartBotMutation>;
export type RestartBotMutationOptions = Apollo.BaseMutationOptions<RestartBotMutation, RestartBotMutationVariables>;
export const GetDashboardDataDocument = gql`
    query GetDashboardData {
  bots(first: 10) {
    edges {
      node {
        id
        name
        status
        mode
        freqtradeVersion
        lastSeenAt
        exchange {
          id
          name
        }
        strategy {
          id
          name
        }
      }
    }
    totalCount
  }
  trades(first: 10) {
    edges {
      node {
        id
        pair
        isOpen
        openDate
        closeDate
        profitAbs
        profitRatio
        bot {
          id
          name
        }
      }
    }
    totalCount
  }
  exchanges {
    id
    name
  }
  strategies(first: 10) {
    edges {
      node {
        id
        name
        version
      }
    }
    totalCount
  }
}
    `;

/**
 * __useGetDashboardDataQuery__
 *
 * To run a query within a React component, call `useGetDashboardDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDashboardDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDashboardDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetDashboardDataQuery(baseOptions?: Apollo.QueryHookOptions<GetDashboardDataQuery, GetDashboardDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDashboardDataQuery, GetDashboardDataQueryVariables>(GetDashboardDataDocument, options);
      }
export function useGetDashboardDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDashboardDataQuery, GetDashboardDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDashboardDataQuery, GetDashboardDataQueryVariables>(GetDashboardDataDocument, options);
        }
export function useGetDashboardDataSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetDashboardDataQuery, GetDashboardDataQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetDashboardDataQuery, GetDashboardDataQueryVariables>(GetDashboardDataDocument, options);
        }
export type GetDashboardDataQueryHookResult = ReturnType<typeof useGetDashboardDataQuery>;
export type GetDashboardDataLazyQueryHookResult = ReturnType<typeof useGetDashboardDataLazyQuery>;
export type GetDashboardDataSuspenseQueryHookResult = ReturnType<typeof useGetDashboardDataSuspenseQuery>;
export type GetDashboardDataQueryResult = Apollo.QueryResult<GetDashboardDataQuery, GetDashboardDataQueryVariables>;
export const GetExchangesDocument = gql`
    query GetExchanges {
  exchanges {
    id
    name
    config
    createdAt
    updatedAt
    bots(first: 10) {
      totalCount
    }
  }
}
    `;

/**
 * __useGetExchangesQuery__
 *
 * To run a query within a React component, call `useGetExchangesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetExchangesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetExchangesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetExchangesQuery(baseOptions?: Apollo.QueryHookOptions<GetExchangesQuery, GetExchangesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetExchangesQuery, GetExchangesQueryVariables>(GetExchangesDocument, options);
      }
export function useGetExchangesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetExchangesQuery, GetExchangesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetExchangesQuery, GetExchangesQueryVariables>(GetExchangesDocument, options);
        }
export function useGetExchangesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetExchangesQuery, GetExchangesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetExchangesQuery, GetExchangesQueryVariables>(GetExchangesDocument, options);
        }
export type GetExchangesQueryHookResult = ReturnType<typeof useGetExchangesQuery>;
export type GetExchangesLazyQueryHookResult = ReturnType<typeof useGetExchangesLazyQuery>;
export type GetExchangesSuspenseQueryHookResult = ReturnType<typeof useGetExchangesSuspenseQuery>;
export type GetExchangesQueryResult = Apollo.QueryResult<GetExchangesQuery, GetExchangesQueryVariables>;
export const GetExchangeDocument = gql`
    query GetExchange($id: ID!) {
  node(id: $id) {
    ... on Exchange {
      id
      name
      config
      createdAt
      updatedAt
      bots(first: 50) {
        edges {
          node {
            id
            name
            status
          }
        }
        totalCount
      }
    }
  }
}
    `;

/**
 * __useGetExchangeQuery__
 *
 * To run a query within a React component, call `useGetExchangeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetExchangeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetExchangeQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetExchangeQuery(baseOptions: Apollo.QueryHookOptions<GetExchangeQuery, GetExchangeQueryVariables> & ({ variables: GetExchangeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetExchangeQuery, GetExchangeQueryVariables>(GetExchangeDocument, options);
      }
export function useGetExchangeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetExchangeQuery, GetExchangeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetExchangeQuery, GetExchangeQueryVariables>(GetExchangeDocument, options);
        }
export function useGetExchangeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetExchangeQuery, GetExchangeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetExchangeQuery, GetExchangeQueryVariables>(GetExchangeDocument, options);
        }
export type GetExchangeQueryHookResult = ReturnType<typeof useGetExchangeQuery>;
export type GetExchangeLazyQueryHookResult = ReturnType<typeof useGetExchangeLazyQuery>;
export type GetExchangeSuspenseQueryHookResult = ReturnType<typeof useGetExchangeSuspenseQuery>;
export type GetExchangeQueryResult = Apollo.QueryResult<GetExchangeQuery, GetExchangeQueryVariables>;
export const CreateExchangeDocument = gql`
    mutation CreateExchange($input: CreateExchangeInput!) {
  createExchange(input: $input) {
    id
    name
    config
  }
}
    `;
export type CreateExchangeMutationFn = Apollo.MutationFunction<CreateExchangeMutation, CreateExchangeMutationVariables>;

/**
 * __useCreateExchangeMutation__
 *
 * To run a mutation, you first call `useCreateExchangeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateExchangeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createExchangeMutation, { data, loading, error }] = useCreateExchangeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateExchangeMutation(baseOptions?: Apollo.MutationHookOptions<CreateExchangeMutation, CreateExchangeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateExchangeMutation, CreateExchangeMutationVariables>(CreateExchangeDocument, options);
      }
export type CreateExchangeMutationHookResult = ReturnType<typeof useCreateExchangeMutation>;
export type CreateExchangeMutationResult = Apollo.MutationResult<CreateExchangeMutation>;
export type CreateExchangeMutationOptions = Apollo.BaseMutationOptions<CreateExchangeMutation, CreateExchangeMutationVariables>;
export const UpdateExchangeDocument = gql`
    mutation UpdateExchange($id: ID!, $input: UpdateExchangeInput!) {
  updateExchange(id: $id, input: $input) {
    id
    name
    config
  }
}
    `;
export type UpdateExchangeMutationFn = Apollo.MutationFunction<UpdateExchangeMutation, UpdateExchangeMutationVariables>;

/**
 * __useUpdateExchangeMutation__
 *
 * To run a mutation, you first call `useUpdateExchangeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateExchangeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateExchangeMutation, { data, loading, error }] = useUpdateExchangeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateExchangeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateExchangeMutation, UpdateExchangeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateExchangeMutation, UpdateExchangeMutationVariables>(UpdateExchangeDocument, options);
      }
export type UpdateExchangeMutationHookResult = ReturnType<typeof useUpdateExchangeMutation>;
export type UpdateExchangeMutationResult = Apollo.MutationResult<UpdateExchangeMutation>;
export type UpdateExchangeMutationOptions = Apollo.BaseMutationOptions<UpdateExchangeMutation, UpdateExchangeMutationVariables>;
export const DeleteExchangeDocument = gql`
    mutation DeleteExchange($id: ID!) {
  deleteExchange(id: $id)
}
    `;
export type DeleteExchangeMutationFn = Apollo.MutationFunction<DeleteExchangeMutation, DeleteExchangeMutationVariables>;

/**
 * __useDeleteExchangeMutation__
 *
 * To run a mutation, you first call `useDeleteExchangeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteExchangeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteExchangeMutation, { data, loading, error }] = useDeleteExchangeMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteExchangeMutation(baseOptions?: Apollo.MutationHookOptions<DeleteExchangeMutation, DeleteExchangeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteExchangeMutation, DeleteExchangeMutationVariables>(DeleteExchangeDocument, options);
      }
export type DeleteExchangeMutationHookResult = ReturnType<typeof useDeleteExchangeMutation>;
export type DeleteExchangeMutationResult = Apollo.MutationResult<DeleteExchangeMutation>;
export type DeleteExchangeMutationOptions = Apollo.BaseMutationOptions<DeleteExchangeMutation, DeleteExchangeMutationVariables>;
export const GetBotsCountDocument = gql`
    query GetBotsCount {
  bots(first: 1) {
    totalCount
  }
}
    `;

/**
 * __useGetBotsCountQuery__
 *
 * To run a query within a React component, call `useGetBotsCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBotsCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBotsCountQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetBotsCountQuery(baseOptions?: Apollo.QueryHookOptions<GetBotsCountQuery, GetBotsCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBotsCountQuery, GetBotsCountQueryVariables>(GetBotsCountDocument, options);
      }
export function useGetBotsCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBotsCountQuery, GetBotsCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBotsCountQuery, GetBotsCountQueryVariables>(GetBotsCountDocument, options);
        }
export function useGetBotsCountSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBotsCountQuery, GetBotsCountQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBotsCountQuery, GetBotsCountQueryVariables>(GetBotsCountDocument, options);
        }
export type GetBotsCountQueryHookResult = ReturnType<typeof useGetBotsCountQuery>;
export type GetBotsCountLazyQueryHookResult = ReturnType<typeof useGetBotsCountLazyQuery>;
export type GetBotsCountSuspenseQueryHookResult = ReturnType<typeof useGetBotsCountSuspenseQuery>;
export type GetBotsCountQueryResult = Apollo.QueryResult<GetBotsCountQuery, GetBotsCountQueryVariables>;
export const GetExchangesForLayoutDocument = gql`
    query GetExchangesForLayout {
  exchanges {
    id
    name
  }
}
    `;

/**
 * __useGetExchangesForLayoutQuery__
 *
 * To run a query within a React component, call `useGetExchangesForLayoutQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetExchangesForLayoutQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetExchangesForLayoutQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetExchangesForLayoutQuery(baseOptions?: Apollo.QueryHookOptions<GetExchangesForLayoutQuery, GetExchangesForLayoutQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetExchangesForLayoutQuery, GetExchangesForLayoutQueryVariables>(GetExchangesForLayoutDocument, options);
      }
export function useGetExchangesForLayoutLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetExchangesForLayoutQuery, GetExchangesForLayoutQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetExchangesForLayoutQuery, GetExchangesForLayoutQueryVariables>(GetExchangesForLayoutDocument, options);
        }
export function useGetExchangesForLayoutSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetExchangesForLayoutQuery, GetExchangesForLayoutQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetExchangesForLayoutQuery, GetExchangesForLayoutQueryVariables>(GetExchangesForLayoutDocument, options);
        }
export type GetExchangesForLayoutQueryHookResult = ReturnType<typeof useGetExchangesForLayoutQuery>;
export type GetExchangesForLayoutLazyQueryHookResult = ReturnType<typeof useGetExchangesForLayoutLazyQuery>;
export type GetExchangesForLayoutSuspenseQueryHookResult = ReturnType<typeof useGetExchangesForLayoutSuspenseQuery>;
export type GetExchangesForLayoutQueryResult = Apollo.QueryResult<GetExchangesForLayoutQuery, GetExchangesForLayoutQueryVariables>;
export const GetRunnersDocument = gql`
    query GetRunners($first: Int, $after: Cursor) {
  botRunners(first: $first, after: $after) {
    edges {
      node {
        id
        name
        type
        createdAt
        dataIsReady
        dataLastUpdated
        dataDownloadStatus
        dataDownloadProgress
        dataDownloadConfig
        dataErrorMessage
        bots {
          totalCount
        }
      }
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
  }
}
    `;

/**
 * __useGetRunnersQuery__
 *
 * To run a query within a React component, call `useGetRunnersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRunnersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRunnersQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useGetRunnersQuery(baseOptions?: Apollo.QueryHookOptions<GetRunnersQuery, GetRunnersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRunnersQuery, GetRunnersQueryVariables>(GetRunnersDocument, options);
      }
export function useGetRunnersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRunnersQuery, GetRunnersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRunnersQuery, GetRunnersQueryVariables>(GetRunnersDocument, options);
        }
export function useGetRunnersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRunnersQuery, GetRunnersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRunnersQuery, GetRunnersQueryVariables>(GetRunnersDocument, options);
        }
export type GetRunnersQueryHookResult = ReturnType<typeof useGetRunnersQuery>;
export type GetRunnersLazyQueryHookResult = ReturnType<typeof useGetRunnersLazyQuery>;
export type GetRunnersSuspenseQueryHookResult = ReturnType<typeof useGetRunnersSuspenseQuery>;
export type GetRunnersQueryResult = Apollo.QueryResult<GetRunnersQuery, GetRunnersQueryVariables>;
export const GetRunnerDocument = gql`
    query GetRunner($id: ID!) {
  node(id: $id) {
    ... on BotRunner {
      id
      name
      type
      createdAt
      dataIsReady
      dataLastUpdated
      dataDownloadStatus
      dataDownloadProgress
      dataDownloadConfig
      dataErrorMessage
      bots {
        totalCount
      }
    }
  }
}
    `;

/**
 * __useGetRunnerQuery__
 *
 * To run a query within a React component, call `useGetRunnerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRunnerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRunnerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetRunnerQuery(baseOptions: Apollo.QueryHookOptions<GetRunnerQuery, GetRunnerQueryVariables> & ({ variables: GetRunnerQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRunnerQuery, GetRunnerQueryVariables>(GetRunnerDocument, options);
      }
export function useGetRunnerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRunnerQuery, GetRunnerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRunnerQuery, GetRunnerQueryVariables>(GetRunnerDocument, options);
        }
export function useGetRunnerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRunnerQuery, GetRunnerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRunnerQuery, GetRunnerQueryVariables>(GetRunnerDocument, options);
        }
export type GetRunnerQueryHookResult = ReturnType<typeof useGetRunnerQuery>;
export type GetRunnerLazyQueryHookResult = ReturnType<typeof useGetRunnerLazyQuery>;
export type GetRunnerSuspenseQueryHookResult = ReturnType<typeof useGetRunnerSuspenseQuery>;
export type GetRunnerQueryResult = Apollo.QueryResult<GetRunnerQuery, GetRunnerQueryVariables>;
export const CreateRunnerDocument = gql`
    mutation CreateRunner($input: CreateBotRunnerInput!) {
  createBotRunner(input: $input) {
    id
    name
    type
    dataDownloadConfig
  }
}
    `;
export type CreateRunnerMutationFn = Apollo.MutationFunction<CreateRunnerMutation, CreateRunnerMutationVariables>;

/**
 * __useCreateRunnerMutation__
 *
 * To run a mutation, you first call `useCreateRunnerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRunnerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRunnerMutation, { data, loading, error }] = useCreateRunnerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateRunnerMutation(baseOptions?: Apollo.MutationHookOptions<CreateRunnerMutation, CreateRunnerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRunnerMutation, CreateRunnerMutationVariables>(CreateRunnerDocument, options);
      }
export type CreateRunnerMutationHookResult = ReturnType<typeof useCreateRunnerMutation>;
export type CreateRunnerMutationResult = Apollo.MutationResult<CreateRunnerMutation>;
export type CreateRunnerMutationOptions = Apollo.BaseMutationOptions<CreateRunnerMutation, CreateRunnerMutationVariables>;
export const UpdateRunnerDocument = gql`
    mutation UpdateRunner($id: ID!, $input: UpdateBotRunnerInput!) {
  updateBotRunner(id: $id, input: $input) {
    id
    name
    type
    dataDownloadConfig
  }
}
    `;
export type UpdateRunnerMutationFn = Apollo.MutationFunction<UpdateRunnerMutation, UpdateRunnerMutationVariables>;

/**
 * __useUpdateRunnerMutation__
 *
 * To run a mutation, you first call `useUpdateRunnerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRunnerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRunnerMutation, { data, loading, error }] = useUpdateRunnerMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateRunnerMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRunnerMutation, UpdateRunnerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRunnerMutation, UpdateRunnerMutationVariables>(UpdateRunnerDocument, options);
      }
export type UpdateRunnerMutationHookResult = ReturnType<typeof useUpdateRunnerMutation>;
export type UpdateRunnerMutationResult = Apollo.MutationResult<UpdateRunnerMutation>;
export type UpdateRunnerMutationOptions = Apollo.BaseMutationOptions<UpdateRunnerMutation, UpdateRunnerMutationVariables>;
export const DeleteRunnerDocument = gql`
    mutation DeleteRunner($id: ID!) {
  deleteBotRunner(id: $id)
}
    `;
export type DeleteRunnerMutationFn = Apollo.MutationFunction<DeleteRunnerMutation, DeleteRunnerMutationVariables>;

/**
 * __useDeleteRunnerMutation__
 *
 * To run a mutation, you first call `useDeleteRunnerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRunnerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRunnerMutation, { data, loading, error }] = useDeleteRunnerMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteRunnerMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRunnerMutation, DeleteRunnerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRunnerMutation, DeleteRunnerMutationVariables>(DeleteRunnerDocument, options);
      }
export type DeleteRunnerMutationHookResult = ReturnType<typeof useDeleteRunnerMutation>;
export type DeleteRunnerMutationResult = Apollo.MutationResult<DeleteRunnerMutation>;
export type DeleteRunnerMutationOptions = Apollo.BaseMutationOptions<DeleteRunnerMutation, DeleteRunnerMutationVariables>;
export const RefreshRunnerDataDocument = gql`
    mutation RefreshRunnerData($id: ID!) {
  refreshRunnerData(id: $id) {
    id
    name
    type
    dataIsReady
    dataLastUpdated
    dataDownloadStatus
    dataDownloadProgress
    dataErrorMessage
  }
}
    `;
export type RefreshRunnerDataMutationFn = Apollo.MutationFunction<RefreshRunnerDataMutation, RefreshRunnerDataMutationVariables>;

/**
 * __useRefreshRunnerDataMutation__
 *
 * To run a mutation, you first call `useRefreshRunnerDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRefreshRunnerDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [refreshRunnerDataMutation, { data, loading, error }] = useRefreshRunnerDataMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRefreshRunnerDataMutation(baseOptions?: Apollo.MutationHookOptions<RefreshRunnerDataMutation, RefreshRunnerDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RefreshRunnerDataMutation, RefreshRunnerDataMutationVariables>(RefreshRunnerDataDocument, options);
      }
export type RefreshRunnerDataMutationHookResult = ReturnType<typeof useRefreshRunnerDataMutation>;
export type RefreshRunnerDataMutationResult = Apollo.MutationResult<RefreshRunnerDataMutation>;
export type RefreshRunnerDataMutationOptions = Apollo.BaseMutationOptions<RefreshRunnerDataMutation, RefreshRunnerDataMutationVariables>;
export const GetStrategiesDocument = gql`
    query GetStrategies($first: Int, $after: Cursor) {
  strategies(first: $first, after: $after) {
    edges {
      node {
        id
        name
        description
        code
        version
        config
        createdAt
        bots {
          totalCount
        }
      }
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
  }
}
    `;

/**
 * __useGetStrategiesQuery__
 *
 * To run a query within a React component, call `useGetStrategiesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStrategiesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStrategiesQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useGetStrategiesQuery(baseOptions?: Apollo.QueryHookOptions<GetStrategiesQuery, GetStrategiesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStrategiesQuery, GetStrategiesQueryVariables>(GetStrategiesDocument, options);
      }
export function useGetStrategiesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStrategiesQuery, GetStrategiesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStrategiesQuery, GetStrategiesQueryVariables>(GetStrategiesDocument, options);
        }
export function useGetStrategiesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStrategiesQuery, GetStrategiesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStrategiesQuery, GetStrategiesQueryVariables>(GetStrategiesDocument, options);
        }
export type GetStrategiesQueryHookResult = ReturnType<typeof useGetStrategiesQuery>;
export type GetStrategiesLazyQueryHookResult = ReturnType<typeof useGetStrategiesLazyQuery>;
export type GetStrategiesSuspenseQueryHookResult = ReturnType<typeof useGetStrategiesSuspenseQuery>;
export type GetStrategiesQueryResult = Apollo.QueryResult<GetStrategiesQuery, GetStrategiesQueryVariables>;
export const CreateStrategyDocument = gql`
    mutation CreateStrategy($input: CreateStrategyInput!) {
  createStrategy(input: $input) {
    id
    name
    description
    code
    version
    config
  }
}
    `;
export type CreateStrategyMutationFn = Apollo.MutationFunction<CreateStrategyMutation, CreateStrategyMutationVariables>;

/**
 * __useCreateStrategyMutation__
 *
 * To run a mutation, you first call `useCreateStrategyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateStrategyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createStrategyMutation, { data, loading, error }] = useCreateStrategyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateStrategyMutation(baseOptions?: Apollo.MutationHookOptions<CreateStrategyMutation, CreateStrategyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateStrategyMutation, CreateStrategyMutationVariables>(CreateStrategyDocument, options);
      }
export type CreateStrategyMutationHookResult = ReturnType<typeof useCreateStrategyMutation>;
export type CreateStrategyMutationResult = Apollo.MutationResult<CreateStrategyMutation>;
export type CreateStrategyMutationOptions = Apollo.BaseMutationOptions<CreateStrategyMutation, CreateStrategyMutationVariables>;
export const UpdateStrategyDocument = gql`
    mutation UpdateStrategy($id: ID!, $input: UpdateStrategyInput!) {
  updateStrategy(id: $id, input: $input) {
    id
    name
    description
    code
    version
    config
  }
}
    `;
export type UpdateStrategyMutationFn = Apollo.MutationFunction<UpdateStrategyMutation, UpdateStrategyMutationVariables>;

/**
 * __useUpdateStrategyMutation__
 *
 * To run a mutation, you first call `useUpdateStrategyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStrategyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStrategyMutation, { data, loading, error }] = useUpdateStrategyMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateStrategyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStrategyMutation, UpdateStrategyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStrategyMutation, UpdateStrategyMutationVariables>(UpdateStrategyDocument, options);
      }
export type UpdateStrategyMutationHookResult = ReturnType<typeof useUpdateStrategyMutation>;
export type UpdateStrategyMutationResult = Apollo.MutationResult<UpdateStrategyMutation>;
export type UpdateStrategyMutationOptions = Apollo.BaseMutationOptions<UpdateStrategyMutation, UpdateStrategyMutationVariables>;
export const DeleteStrategyDocument = gql`
    mutation DeleteStrategy($id: ID!) {
  deleteStrategy(id: $id)
}
    `;
export type DeleteStrategyMutationFn = Apollo.MutationFunction<DeleteStrategyMutation, DeleteStrategyMutationVariables>;

/**
 * __useDeleteStrategyMutation__
 *
 * To run a mutation, you first call `useDeleteStrategyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteStrategyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteStrategyMutation, { data, loading, error }] = useDeleteStrategyMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteStrategyMutation(baseOptions?: Apollo.MutationHookOptions<DeleteStrategyMutation, DeleteStrategyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteStrategyMutation, DeleteStrategyMutationVariables>(DeleteStrategyDocument, options);
      }
export type DeleteStrategyMutationHookResult = ReturnType<typeof useDeleteStrategyMutation>;
export type DeleteStrategyMutationResult = Apollo.MutationResult<DeleteStrategyMutation>;
export type DeleteStrategyMutationOptions = Apollo.BaseMutationOptions<DeleteStrategyMutation, DeleteStrategyMutationVariables>;