# ENT ORM Integration Pattern

## Problem

How do you integrate a type-safe ORM with GraphQL while maintaining:

- Single source of truth for schema definitions
- Automatic resolver generation
- Type safety across database and API layers
- Support for complex queries, mutations, and edges

## Solution

Use ENT ORM with GraphQL extension to generate both database schema and GraphQL schema from ENT entity definitions. This ensures schemas stay in sync and provides automatic CRUD operations.

## Implementation

### 1. Define ENT Schema

Create entity schemas in `internal/ent/schema/`:

```go
// internal/ent/schema/bot.go
package schema

import (
    "entgo.io/contrib/entgql"
    "entgo.io/ent"
    "entgo.io/ent/schema/edge"
    "entgo.io/ent/schema/field"
)

type Bot struct {
    ent.Schema
}

func (Bot) Fields() []ent.Field {
    return []ent.Field{
        field.String("name").
            NotEmpty().
            Annotations(entgql.OrderField("NAME")),
        field.Enum("status").
            Values("STOPPED", "RUNNING", "FAILED").
            Default("STOPPED"),
        field.JSON("config", map[string]interface{}{}).
            Optional().
            Annotations(
                entgql.Type("Map"),
                entgql.Skip(entgql.SkipType),
            ),
    }
}

func (Bot) Edges() []ent.Edge {
    return []ent.Edge{
        edge.From("strategy", Strategy.Type).
            Ref("bots").
            Unique().
            Required(),
        edge.To("metrics", BotMetrics.Type).
            Unique(),
    }
}
```

### 2. Configure ENT GraphQL Extension

In `internal/ent/entc.go`:

```go
//go:build ignore
package main

import (
    "log"
    "entgo.io/contrib/entgql"
    "entgo.io/ent/entc"
    "entgo.io/ent/entc/gen"
)

func main() {
    ex, err := entgql.NewExtension(
        entgql.WithSchemaGenerator(),
        entgql.WithSchemaPath("../graph/ent.graphql"),
        entgql.WithConfigPath("../../gqlgen.yml"),
        entgql.WithWhereInputs(true),
    )
    if err != nil {
        log.Fatalf("creating entgql extension: %v", err)
    }

    if err := entc.Generate("./schema", &gen.Config{
        Features: []gen.Feature{
            gen.FeatureVersionedMigration,
        },
    }, entc.Extensions(ex)); err != nil {
        log.Fatal("running ent codegen:", err)
    }
}
```

### 3. Configure gqlgen

In `gqlgen.yml`:

```yaml
schema:
  - internal/graph/schema.graphqls
  - internal/graph/ent.graphql  # Generated by ENT

autobind:
  - volaticloud/internal/ent
  - volaticloud/internal/enum

models:
  Node:
    model: volaticloud/internal/ent.Noder

  # Map custom scalars
  Map:
    model: map[string]interface{}
  Time:
    model: github.com/99designs/gqlgen/graphql.Time
```

### 4. Generate Code

```bash
# Generate ENT entities + GraphQL schema
go generate ./internal/ent

# Generate GraphQL resolvers
go run github.com/99designs/gqlgen generate
```

### 5. Implement Custom Resolvers

ENT generates most resolvers automatically in `internal/graph/ent.resolvers.go`. Only implement custom business logic:

```go
// internal/graph/schema.resolvers.go
func (r *mutationResolver) CreateBot(ctx context.Context,
    input ent.CreateBotInput) (*ent.Bot, error) {

    // Custom validation
    if err := bot.ValidateConfig(input.Config); err != nil {
        return nil, err
    }

    // Use generated ENT client
    return r.client.Bot.Create().
        SetInput(input).
        Save(ctx)
}
```

## Benefits

1. **Single Source of Truth**: ENT schema drives both database and GraphQL
2. **Type Safety**: Full type safety from database to API
3. **Auto-Generated CRUD**: Reduces boilerplate code significantly
4. **Complex Queries**: Automatic support for filtering, pagination, ordering
5. **Relay Connections**: Built-in support for Relay-style pagination
6. **Schema Evolution**: Migrations generated automatically from schema changes
7. **Performance**: Optimized queries with automatic eager loading

## Trade-offs

### Pros

- Minimal manual code for CRUD operations
- Schemas stay in sync automatically
- Type-safe database operations
- Excellent developer experience

### Cons

- Learning curve for ENT schema annotations
- Generated code can be large (mitigated with `.gitignore`)
- Custom GraphQL types require manual mapping
- Limited control over generated GraphQL schema structure

## Common Patterns

### JSON Fields with Custom Types

```go
field.JSON("config", map[string]interface{}{}).
    Annotations(
        entgql.Type("MyCustomInput"),  // Map to custom GraphQL type
        entgql.Skip(entgql.SkipType),  // Don't generate default type
    )
```

### Enum Fields

```go
field.Enum("status").
    Values("RUNNING", "STOPPED").
    Annotations(entgql.OrderField("STATUS"))
```

### Edges with Custom Annotations

```go
edge.To("bots", Bot.Type).
    Annotations(entgql.RelayConnection())  // Enable Relay pagination
```

### Optional vs Required Fields

```go
field.String("name").NotEmpty()         // Required
field.String("description").Optional()  // Optional
```

## Related Patterns

- [GraphQL Code Generation](graphql-codegen.md) - How gqlgen generates resolvers
- [Dependency Injection](dependency-injection.md) - Injecting ENT client into resolvers
- [Transaction Management](transactions.md) - Using ENT transactions

## References

- [ADR-0002: ENT ORM with GraphQL Integration](../adr/0002-ent-orm-with-graphql.md)
- ENT Documentation: https://entgo.io/docs/graphql/
- gqlgen Documentation: https://gqlgen.com/
- `internal/ent/schema/` - Entity definitions
- `internal/graph/ent.resolvers.go` - Generated resolvers
