# 0001. Context-Based Dependency Injection

Date: 2025-01-15

## Status

Accepted

## Context and Problem Statement

VolatiCloud's GraphQL API needs access to multiple dependencies throughout the request lifecycle:
- **ENT Client**: Database operations in resolvers and hooks
- **UMA Client**: Keycloak authorization checks in GraphQL directives
- **User Context**: Authenticated user information from JWT tokens

Traditional dependency injection approaches (constructor injection, global variables) have significant drawbacks:
- **Constructor injection**: GraphQL resolvers generated by gqlgen don't support custom constructors
- **Global variables**: Not testable, not request-scoped, violates Go best practices
- **Function parameters**: Would require passing dependencies through every function call (verbose, brittle)

How do we pass request-scoped dependencies to GraphQL directives and resolvers in a clean, testable, idiomatic way?

## Decision Drivers

- **gqlgen compatibility**: Must work with gqlgen's code generation
- **Testability**: Must support dependency injection in tests (mocks)
- **Request isolation**: Dependencies must be request-scoped, not shared globally
- **Type safety**: Prevent context key collisions
- **Go idioms**: Follow Go best practices and standard library patterns
- **Zero boilerplate**: Minimal code changes when adding new dependencies

## Considered Options

### Option 1: Global Variables

Use package-level variables to store clients.

**Pros:**
- Simple to implement
- No ceremony - direct access everywhere

**Cons:**
- Not request-scoped (can't have different auth per request)
- Breaks testability (can't inject mocks)
- Not thread-safe without synchronization
- Violates Go best practices
- Can't support multiple concurrent requests with different contexts

### Option 2: Constructor Dependency Injection

Pass dependencies through resolver constructors.

**Pros:**
- Explicit dependencies
- Type-safe
- Standard DI pattern

**Cons:**
- **gqlgen doesn't support it** - resolvers are code-generated
- Would require custom resolver generation
- Breaks gqlgen's code generation workflow

### Option 3: Context-Based Dependency Injection

Store dependencies in `context.Context` using private keys, inject via HTTP middleware.

**Pros:**
- Works with gqlgen's generated code
- Request-scoped (each request has its own context)
- Fully testable (inject mocks in test contexts)
- Type-safe with private context keys
- Idiomatic Go (context is standard for request-scoped data)
- No boilerplate in resolvers
- Clean separation: middleware handles injection, directives/resolvers consume

**Cons:**
- Dependencies are implicit (not in function signatures)
- Requires runtime type assertions
- Potential nil pointer if context not set up correctly (mitigated by middleware guarantees)

## Decision Outcome

Chosen option: **Context-Based Dependency Injection**, because it:
1. **Works with gqlgen** - No conflicts with code generation
2. **Enables testing** - Easy to inject mocks via context
3. **Request isolation** - Each request gets its own dependency instances
4. **Type safety** - Private context keys prevent collisions
5. **Idiomatic** - Follows Go standard library patterns (`context.Context`)

### Consequences

**Positive:**
- Clean integration with gqlgen's code generation
- Full test coverage with mock dependencies (`internal/graph/test_setup_test.go`)
- Request-scoped user authentication and authorization
- Zero boilerplate in GraphQL resolvers
- Easy to add new dependencies (just add Set/Get helpers)

**Negative:**
- Dependencies are implicit (not visible in function signatures)
- Requires understanding of Go context patterns
- Runtime panics if context not properly initialized (mitigated by middleware order)

**Neutral:**
- Middleware must be ordered correctly (auth → inject clients)
- Test setup requires explicit context configuration

## Implementation

### Architecture Flow

```
HTTP Request
    ↓
Auth Middleware (JWT validation)
    ↓ SetUserContext(ctx, userInfo)
    ↓
Inject Clients Middleware
    ↓ SetEntClientInContext(ctx, entClient)
    ↓ SetUMAClientInContext(ctx, umaClient)
    ↓
GraphQL Handler
    ↓
GraphQL Directive (@isAuthenticated, @hasScope)
    ↓ GetUserContext(ctx), GetUMAClientFromContext(ctx)
    ↓
GraphQL Resolver
    ↓ GetEntClientFromContext(ctx)
    ↓
Response
```

### Key Files

**User Context:**
- `internal/auth/context.go:8-46` - User context definition, Set/Get/Must helpers
  - Private context key: `contextKey("user")`
  - `SetUserContext(ctx, user)` - Store authenticated user
  - `GetUserContext(ctx)` - Retrieve user (returns error if not authenticated)
  - `MustGetUserContext(ctx)` - Retrieve user (panics if not authenticated, safe after `@isAuthenticated`)

**Client Context:**
- `internal/graph/directives.go:310-338` - ENT and UMA client context helpers
  - Private context keys: `umaClientKey`, `entClientKey`
  - `SetEntClientInContext(ctx, client)` / `GetEntClientFromContext(ctx)`
  - `SetUMAClientInContext(ctx, client)` / `GetUMAClientFromContext(ctx)`

**Middleware Injection:**
- `cmd/server/main.go:254-263` - HTTP middleware that injects clients into every request context

**Transaction Helper:**
- `internal/graph/tx.go:23-53` - `WithTx` helper wraps operations in database transactions
  - Accepts ENT client as explicit parameter (retrieved from context by caller)
  - Follows ENT best practices with panic recovery and rollback

### Example Usage

**Middleware Setup (Server Initialization):**
```go
// cmd/server/main.go:254-263
injectClientsMiddleware := func(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        ctx = graph.SetEntClientInContext(ctx, client)
        ctx = graph.SetUMAClientInContext(ctx, umaClient)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

router.With(auth.RequireAuth(keycloakClient), injectClientsMiddleware).Handle("/query", srv)
```

**GraphQL Directive Usage:**
```go
// internal/graph/directives.go
func HasScopeDirective(ctx context.Context, obj interface{}, next graphql.Resolver,
                       resourceArg string, scope string) (interface{}, error) {
    // Get user context (injected by auth middleware)
    user := auth.MustGetUserContext(ctx)

    // Get UMA client (injected by clients middleware)
    umaClient := GetUMAClientFromContext(ctx)

    // Check permission
    hasPermission, err := umaClient.CheckPermission(ctx, user.RawToken, resourceID, scope)
    // ...
}
```

**Test Setup:**
```go
// internal/graph/test_setup_test.go:80-96
func (te *TestEnv) WithAuth(userID, groupID string, permissions map[string][]string) context.Context {
    token := GenerateTestJWT(te.T, userID, "test@example.com", []string{groupID})
    te.MockUMA.SetPermissions(permissions)

    userCtx := CreateUserContext(userID, "test@example.com", []string{groupID}, nil, token)

    ctx := te.Context
    ctx = auth.SetUserContext(ctx, userCtx)           // Inject user
    ctx = SetEntClientInContext(ctx, te.Client)       // Inject ENT client
    ctx = SetUMAClientInContext(ctx, te.MockUMA)      // Inject mock UMA
    return ctx
}
```

## Validation

### How to Verify This Decision

1. **Code Review**: Check that all GraphQL directives and resolvers retrieve dependencies from context (never use globals)
2. **Test Coverage**: Verify tests inject mock dependencies via context (`internal/graph/*_test.go`)
3. **Middleware Order**: Ensure auth middleware runs before client injection middleware
4. **No Globals**: Search codebase for global variables holding clients (should find none)

### Automated Checks

```bash
# Verify no global client variables
rg "var.*Client\s*=" --type go internal/ --glob '!*_test.go'

# Verify context pattern usage
rg "GetUserContext|GetEntClientFromContext|GetUMAClientFromContext" --type go internal/graph/

# Run authorization tests
go test -v ./internal/graph -run TestAuthorization
```

## References

- [Go Context Package](https://pkg.go.dev/context)
- [gqlgen Documentation](https://gqlgen.com/)
- ENT ORM Context Patterns
- [ADR-0002: ENT ORM with GraphQL Integration](0002-ent-orm-with-graphql.md)
- Test Implementation: `internal/graph/test_setup_test.go`
