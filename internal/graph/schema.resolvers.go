package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"
	"time"
	"volaticloud/internal/alert"
	"volaticloud/internal/auth"
	"volaticloud/internal/authz"
	backtest1 "volaticloud/internal/backtest"
	bot1 "volaticloud/internal/bot"
	"volaticloud/internal/ent"
	"volaticloud/internal/ent/alertevent"
	"volaticloud/internal/ent/backtest"
	"volaticloud/internal/ent/bot"
	"volaticloud/internal/ent/resourceusageaggregation"
	"volaticloud/internal/ent/strategy"
	"volaticloud/internal/enum"
	"volaticloud/internal/freqtrade"
	"volaticloud/internal/graph/model"
	"volaticloud/internal/keycloak"
	"volaticloud/internal/monitor"
	"volaticloud/internal/organization"
	"volaticloud/internal/runner"
	"volaticloud/internal/s3"
	strategy1 "volaticloud/internal/strategy"
	"volaticloud/internal/usage"

	"github.com/google/uuid"
)

func (r *backtestResolver) Summary(ctx context.Context, obj *ent.Backtest) (*backtest1.BacktestSummary, error) {
	// If no summary stored in database, return nil (not an error)
	if len(obj.Summary) == 0 {
		return nil, nil
	}

	// Convert map to BacktestSummary struct via JSON
	// This is safe because the summary was created by backtest1.ExtractSummaryFromResult
	summary := &backtest1.BacktestSummary{}

	// Simple field-by-field extraction would be more efficient,
	// but JSON marshaling is cleaner and safer
	jsonBytes, err := json.Marshal(obj.Summary)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal summary: %w", err)
	}

	if err := json.Unmarshal(jsonBytes, summary); err != nil {
		return nil, fmt.Errorf("failed to unmarshal summary: %w", err)
	}

	return summary, nil
}

// ResourceUsage returns the total usage for a backtest execution.
func (r *backtestResolver) ResourceUsage(ctx context.Context, obj *ent.Backtest) (*ent.ResourceUsageAggregation, error) {
	// Query all aggregations for this backtest
	aggs, err := r.client.ResourceUsageAggregation.Query().
		Where(
			resourceusageaggregation.ResourceTypeEQ(enum.ResourceTypeBacktest),
			resourceusageaggregation.ResourceID(obj.ID),
		).
		All(ctx)
	if err != nil {
		return nil, err
	}

	if len(aggs) == 0 {
		return nil, nil
	}

	if len(aggs) == 1 {
		return aggs[0], nil
	}

	// Combine all aggregations for this backtest
	var minStart, maxEnd time.Time
	for i, agg := range aggs {
		if i == 0 || agg.BucketStart.Before(minStart) {
			minStart = agg.BucketStart
		}
		if i == 0 || agg.BucketEnd.After(maxEnd) {
			maxEnd = agg.BucketEnd
		}
	}

	return usage.CombineAggregationsToEntity(aggs, minStart, maxEnd), nil
}

// RecentUsage returns the last 24 hours of usage for a bot.
func (r *botResolver) RecentUsage(ctx context.Context, obj *ent.Bot) (*ent.ResourceUsageAggregation, error) {
	// Query the most recent daily aggregation for this bot
	end := time.Now()
	start := end.Add(-24 * time.Hour)

	// Query aggregations for the past 24 hours
	aggs, err := r.client.ResourceUsageAggregation.Query().
		Where(
			resourceusageaggregation.ResourceTypeEQ(enum.ResourceTypeBot),
			resourceusageaggregation.ResourceID(obj.ID),
			resourceusageaggregation.BucketStartGTE(start),
			resourceusageaggregation.BucketStartLT(end),
		).
		Order(ent.Desc(resourceusageaggregation.FieldBucketStart)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	if len(aggs) == 0 {
		return nil, nil
	}

	// If we have multiple aggregations, combine them
	if len(aggs) == 1 {
		return aggs[0], nil
	}

	// Combine aggregations for the time period
	return usage.CombineAggregationsToEntity(aggs, start, end), nil
}

func (r *mutationResolver) CreateExchange(ctx context.Context, input ent.CreateExchangeInput) (*ent.Exchange, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Create exchange - ENT hook handles Keycloak resource sync automatically
	// OwnerID comes from the input and represents the selected group/organization
	return r.client.Exchange.Create().SetInput(input).Save(ctx)
}

func (r *mutationResolver) UpdateExchange(ctx context.Context, id uuid.UUID, input ent.UpdateExchangeInput) (*ent.Exchange, error) {
	return r.client.Exchange.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteExchange(ctx context.Context, id uuid.UUID) (bool, error) {
	// Soft-delete exchange by setting deleted_at timestamp
	// ENT hook handles Keycloak resource cleanup automatically
	_, err := r.client.Exchange.UpdateOneID(id).SetDeletedAt(time.Now()).Save(ctx)
	return err == nil, err
}

func (r *mutationResolver) CreateStrategy(ctx context.Context, input ent.CreateStrategyInput) (*ent.Strategy, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Create strategy - ENT hook handles Keycloak resource sync automatically
	// OwnerID comes from the input and represents the selected group/organization
	return r.client.Strategy.Create().SetInput(input).Save(ctx)
}

func (r *mutationResolver) UpdateStrategy(ctx context.Context, id uuid.UUID, input ent.UpdateStrategyInput) (*ent.Strategy, error) {
	var result *ent.Strategy

	// Use transaction to ensure atomicity - both operations succeed or both fail
	// ENT hook handles Keycloak resource sync for new version automatically
	err := WithTx(ctx, r.client, func(tx *ent.Tx) error {
		// Load existing strategy (within transaction)
		oldStrategy, err := tx.Strategy.Get(ctx, id)
		if err != nil {
			return fmt.Errorf("failed to load strategy: %w", err)
		}

		// Create new version using domain function
		// Preserves owner_id and public visibility from parent
		versionInput := &strategy1.VersionInput{
			Name:        input.Name,
			Description: input.Description,
			Code:        input.Code,
			Config:      input.Config,
		}

		result, err = strategy1.CreateVersion(ctx, tx, oldStrategy, versionInput)
		if err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

func (r *mutationResolver) DeleteStrategy(ctx context.Context, id uuid.UUID) (bool, error) {
	// Soft-delete strategy and all its versions
	// Uses DeleteOneID which triggers the soft-delete hook
	// ENT hook handles Keycloak resource cleanup automatically
	err := strategy1.DeleteAllVersions(ctx, r.client, id)
	return err == nil, err
}

func (r *mutationResolver) CreateBot(ctx context.Context, input ent.CreateBotInput) (*ent.Bot, error) {
	// Step 1: Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Step 2: Basic validation - just ensure config is provided
	// Note: Full schema validation is available in validateFreqtradeConfigWithSchema()
	// but requires a complete merged config (Exchange + Strategy + Bot)
	if input.Config == nil {
		return nil, fmt.Errorf("bot config is required for Freqtrade bots")
	}

	// Step 3: Create the bot in the database - ENT hook handles Keycloak resource sync automatically
	createdBot, err := r.client.Bot.Create().SetInput(input).Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create bot: %w", err)
	}

	// Step 4: Generate secure_config and update the bot
	// This config contains system-forced settings that users cannot override
	secureConfig, err := bot1.GenerateSecureConfig()
	if err != nil {
		return nil, fmt.Errorf("failed to generate secure config: %w", err)
	}

	// Update the bot with secure_config
	createdBot, err = r.client.Bot.UpdateOneID(createdBot.ID).
		SetSecureConfig(secureConfig).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot with secure config: %w", err)
	}

	// Step 2: Load the bot with all its relations
	createdBot, err = r.client.Bot.Query().
		Where(bot.IDEQ(createdBot.ID)).
		WithRunner().
		WithExchange().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot with relations: %w", err)
	}

	// Step 3: Create the runner client
	botRunner := createdBot.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Step 4: Build BotSpec from bot data
	spec, err := buildBotSpec(createdBot)
	if err != nil {
		return nil, fmt.Errorf("failed to build bot spec: %w", err)
	}

	// Generate presigned URL for S3 data download
	presignedURL, err := getPresignedDataURL(ctx, botRunner)
	if err != nil {
		return nil, fmt.Errorf("failed to get presigned URL: %w", err)
	}
	spec.DataDownloadURL = presignedURL

	// Step 5: Create the container (name derived from bot ID)
	if err := rt.CreateBot(ctx, *spec); err != nil {
		// Update bot status to error
		r.client.Bot.UpdateOneID(createdBot.ID).
			SetStatus(enum.BotStatusError).
			SetErrorMessage(fmt.Sprintf("Failed to create container: %v", err)).
			Save(ctx)
		return nil, fmt.Errorf("failed to create bot container: %w", err)
	}

	// Step 6: Update bot status to stopped (container created successfully)
	createdBot, err = r.client.Bot.UpdateOneID(createdBot.ID).
		SetStatus(enum.BotStatusStopped).
		ClearErrorMessage().
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot status: %w", err)
	}

	return createdBot, nil
}

func (r *mutationResolver) UpdateBot(ctx context.Context, id uuid.UUID, input ent.UpdateBotInput) (*ent.Bot, error) {
	// Note: Bot config is just one layer of the full Freqtrade config.
	// Exchange config is stored separately in the Exchange entity.
	// Full schema validation requires merging all config layers, which happens
	// at container creation time (StartBot), not at update time.
	// Basic nil check is sufficient here.
	return r.client.Bot.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteBot(ctx context.Context, id uuid.UUID) (bool, error) {
	// Soft-delete bot by setting deleted_at timestamp
	// ENT hook handles Keycloak resource cleanup automatically
	_, err := r.client.Bot.UpdateOneID(id).SetDeletedAt(time.Now()).Save(ctx)
	return err == nil, err
}

func (r *mutationResolver) StartBot(ctx context.Context, id uuid.UUID) (*ent.Bot, error) {
	// Load the bot with its runner, exchange, and strategy
	b, err := r.client.Bot.Query().
		Where(bot.ID(id)).
		WithRunner().
		WithExchange().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// If bot is in Error status, delete all resources and recreate
	// This ensures we get a fresh container with updated configs
	if b.Status == enum.BotStatusError {
		log.Printf("Bot %s is in Error status, cleaning up resources before recreation", b.ID.String())
		if err := rt.DeleteBot(ctx, b.ID.String()); err != nil {
			// Log but don't fail - resources might already be gone
			log.Printf("Warning: cleanup of failed bot %s returned error (may be ok): %v", b.ID.String(), err)
		}
		// Clear error message
		b, err = r.client.Bot.UpdateOneID(b.ID).
			ClearErrorMessage().
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to clear error message: %w", err)
		}
		// Reload with edges
		b, err = r.client.Bot.Query().
			Where(bot.ID(b.ID)).
			WithRunner().
			WithExchange().
			WithStrategy().
			Only(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to reload bot: %w", err)
		}
	}

	// Check if container exists by getting status
	_, statusErr := rt.GetBotStatus(ctx, b.ID.String())
	containerExists := statusErr == nil

	if !containerExists {
		// Regenerate secure_config on every start for fresh credentials
		secureConfig, err := bot1.GenerateSecureConfig()
		if err != nil {
			return nil, fmt.Errorf("failed to generate secure config: %w", err)
		}

		// Update bot with new secure_config
		_, err = r.client.Bot.UpdateOneID(b.ID).
			SetSecureConfig(secureConfig).
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to update bot secure config: %w", err)
		}

		// Reload bot with edges since Update().Save() doesn't include them
		b, err = r.client.Bot.Query().
			Where(bot.ID(b.ID)).
			WithRunner().
			WithExchange().
			WithStrategy().
			Only(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to reload bot with edges: %w", err)
		}

		// Build BotSpec from bot data (now with fresh secure_config)
		spec, err := buildBotSpec(b)
		if err != nil {
			return nil, fmt.Errorf("failed to build bot spec: %w", err)
		}

		// Generate presigned URL for S3 data download
		presignedURL, err := getPresignedDataURL(ctx, botRunner)
		if err != nil {
			return nil, fmt.Errorf("failed to get presigned URL: %w", err)
		}
		spec.DataDownloadURL = presignedURL

		// Create the container (name derived from bot ID)
		if err := rt.CreateBot(ctx, *spec); err != nil {
			// Update bot status to error
			r.client.Bot.UpdateOneID(b.ID).
				SetStatus(enum.BotStatusError).
				SetErrorMessage(fmt.Sprintf("Failed to create container: %v", err)).
				Save(ctx)
			return nil, fmt.Errorf("failed to create bot container: %w", err)
		}

		// Clear any error message after successful creation
		b, err = r.client.Bot.UpdateOneID(b.ID).
			ClearErrorMessage().
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to update bot: %w", err)
		}
	}

	// Start the bot in the runtime (using bot ID)
	if err := rt.StartBot(ctx, b.ID.String()); err != nil {
		// If container not found, mark as error and suggest restart
		if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "No such container") {
			r.client.Bot.UpdateOneID(id).
				SetStatus(enum.BotStatusError).
				SetErrorMessage("Container not found - try starting again").
				Save(ctx)
			return nil, fmt.Errorf("container was deleted manually - please try starting again")
		}
		return nil, fmt.Errorf("failed to start bot in runner: %w", err)
	}

	// Update bot status
	b, err = r.client.Bot.UpdateOneID(id).
		SetStatus(enum.BotStatusRunning).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot status: %w", err)
	}

	return b, nil
}

func (r *mutationResolver) StopBot(ctx context.Context, id uuid.UUID) (*ent.Bot, error) {
	// Load the bot with its runner configuration
	b, err := r.client.Bot.Query().
		Where(bot.ID(id)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Stop the bot in the runtime using bot ID
	if err := rt.StopBot(ctx, b.ID.String()); err != nil {
		// If container not found, just update status - it was manually deleted
		if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "No such container") {
			b, err = r.client.Bot.UpdateOneID(id).
				SetStatus(enum.BotStatusStopped).
				Save(ctx)
			if err != nil {
				return nil, fmt.Errorf("failed to update bot status: %w", err)
			}
			return b, nil
		}
		return nil, fmt.Errorf("failed to stop bot in runner: %w", err)
	}

	// Delete all bot resources to ensure fresh configs on next start
	// This enables config reload when bot is updated and restarted
	if err := rt.DeleteBot(ctx, id.String()); err != nil {
		// Log but don't fail - container is stopped, deletion is best-effort
		log.Printf("Warning: failed to delete stopped bot resources %s: %v", id.String(), err)
	}

	// Update bot status
	b, err = r.client.Bot.UpdateOneID(id).
		SetStatus(enum.BotStatusStopped).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot status: %w", err)
	}

	return b, nil
}

func (r *mutationResolver) RestartBot(ctx context.Context, id uuid.UUID) (*ent.Bot, error) {
	// RestartBot performs a full stop + start cycle to ensure config files are reloaded
	// This is important when bot config, strategy, or exchange has been updated

	// Step 1: Stop the bot (this also deletes container and clears containerID)
	_, err := r.StopBot(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to stop bot during restart: %w", err)
	}

	// Step 2: Start the bot (this creates a fresh container with current configs)
	return r.StartBot(ctx, id)
}

func (r *mutationResolver) CreateBotRunner(ctx context.Context, input ent.CreateBotRunnerInput) (*ent.BotRunner, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Create bot runner - ENT hook handles Keycloak resource sync automatically
	// OwnerID comes from the input and represents the selected group/organization
	return r.client.BotRunner.Create().SetInput(input).Save(ctx)
}

func (r *mutationResolver) UpdateBotRunner(ctx context.Context, id uuid.UUID, input ent.UpdateBotRunnerInput) (*ent.BotRunner, error) {
	return r.client.BotRunner.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteBotRunner(ctx context.Context, id uuid.UUID) (bool, error) {
	// Soft-delete bot runner by setting deleted_at timestamp
	// ENT hook handles Keycloak resource cleanup automatically
	_, err := r.client.BotRunner.UpdateOneID(id).SetDeletedAt(time.Now()).Save(ctx)
	return err == nil, err
}

func (r *mutationResolver) RefreshRunnerData(ctx context.Context, id uuid.UUID) (*ent.BotRunner, error) {
	// Load the runner
	runner, err := r.client.BotRunner.Get(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to load runner: %w", err)
	}

	// Check if already downloading
	if runner.DataDownloadStatus == enum.DataDownloadStatusDownloading {
		return nil, fmt.Errorf("data download already in progress for runner %s", runner.Name)
	}

	// Update status to downloading and clear any previous errors
	startedAt := time.Now()
	runner, err = r.client.BotRunner.UpdateOneID(id).
		SetDataDownloadStatus(enum.DataDownloadStatusDownloading).
		SetDataDownloadStartedAt(startedAt).
		SetDataDownloadProgress(map[string]interface{}{
			"pairs_completed":  0,
			"pairs_total":      0,
			"current_pair":     "",
			"percent_complete": 0.0,
		}).
		ClearDataErrorMessage().
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update runner status: %w", err)
	}

	// Trigger download in background goroutine
	go func() {
		downloadCtx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
		defer cancel()

		if err := monitor.DownloadRunnerData(downloadCtx, r.client, runner); err != nil {
			log.Printf("Runner %s: data download failed: %v", runner.Name, err)

			// Update status to failed
			r.client.BotRunner.UpdateOne(runner).
				SetDataDownloadStatus(enum.DataDownloadStatusFailed).
				SetDataIsReady(false).
				SetDataErrorMessage(err.Error()).
				ClearDataDownloadStartedAt().
				Save(context.Background())
		} else {
			log.Printf("Runner %s: data download completed successfully", runner.Name)

			// Update status to completed
			now := time.Now()
			r.client.BotRunner.UpdateOne(runner).
				SetDataDownloadStatus(enum.DataDownloadStatusCompleted).
				SetDataIsReady(true).
				SetDataLastUpdated(now).
				ClearDataErrorMessage().
				ClearDataDownloadProgress().
				ClearDataDownloadStartedAt().
				Save(context.Background())
		}
	}()

	return runner, nil
}

func (r *mutationResolver) TestRunnerConnection(ctx context.Context, typeArg enum.RunnerType, config model.RunnerConfigInput) (*model.ConnectionTestResult, error) {
	// Convert config input to map format
	configMap, err := convertRunnerConfigInput(config)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Invalid configuration: %v", err),
		}, nil
	}

	// Create runner using factory
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, typeArg, configMap)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to create runner client: %v", err),
		}, nil
	}
	defer rt.Close()

	// For Docker runners, try to ping and get version
	// Ping with timeout
	pingCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	// Use GetBotStatus as a connection test
	// This should return an error if connection fails
	_, err = rt.ListBots(pingCtx)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to connect to runner: %v", err),
		}, nil
	}

	return &model.ConnectionTestResult{
		Success: true,
		Message: fmt.Sprintf("Successfully connected to %s runner", typeArg),
	}, nil
}

func (r *mutationResolver) TestS3Connection(ctx context.Context, config model.S3ConfigInput) (*model.ConnectionTestResult, error) {
	// Convert GraphQL input to S3 config map
	s3ConfigMap := map[string]interface{}{
		"endpoint":        config.Endpoint,
		"bucket":          config.Bucket,
		"accessKeyId":     config.AccessKeyID,
		"secretAccessKey": config.SecretAccessKey,
	}

	// Apply optional fields with defaults
	if config.Region != nil {
		s3ConfigMap["region"] = *config.Region
	}
	if config.ForcePathStyle != nil {
		s3ConfigMap["forcePathStyle"] = *config.ForcePathStyle
	}
	if config.UseSsl != nil {
		s3ConfigMap["useSSL"] = *config.UseSsl
	}

	// Create S3 client
	client, err := s3.NewClientFromMap(s3ConfigMap)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to create S3 client: %v", err),
		}, nil
	}

	// Test connection by checking bucket existence
	if err := client.TestConnection(ctx); err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("S3 connection failed: %v", err),
		}, nil
	}

	return &model.ConnectionTestResult{
		Success: true,
		Message: fmt.Sprintf("Successfully connected to S3 bucket: %s", config.Bucket),
	}, nil
}

func (r *mutationResolver) RunBacktest(ctx context.Context, input ent.CreateBacktestInput) (*ent.Backtest, error) {
	var result *ent.Backtest

	// Use transaction to ensure atomicity - entity creation and validation both succeed or both fail
	err := WithTx(ctx, r.client, func(tx *ent.Tx) error {
		strategyID := input.StrategyID

		// Load strategy with backtest relationship to check if it already has one
		existingStrategy, err := tx.Strategy.Query().
			Where(strategy.ID(strategyID)).
			WithBacktest().
			Only(ctx)

		if err != nil {
			return fmt.Errorf("failed to load strategy: %w", err)
		}

		// If strategy already has a backtest, automatically create a new version
		if existingStrategy.Edges.Backtest != nil {
			log.Printf("Strategy %s (v%d) already has a backtest, creating new version for backtest",
				existingStrategy.Name, existingStrategy.VersionNumber)

			// Create new strategy version - ENT hook handles Keycloak resource sync automatically
			newVersion, err := createStrategyVersionDB(ctx, tx, existingStrategy)
			if err != nil {
				return fmt.Errorf("failed to create new strategy version: %w", err)
			}

			// Use the new strategy version for this backtest
			strategyID = newVersion.ID
			log.Printf("Created strategy version %d (ID: %s) for backtest",
				newVersion.VersionNumber, newVersion.ID)
		}

		// Create backtest entity with the (possibly new) strategy ID
		bt, err := tx.Backtest.Create().
			SetStrategyID(strategyID).
			SetRunnerID(input.RunnerID).
			SetNillableStartDate(input.StartDate).
			SetNillableEndDate(input.EndDate).
			SetStatus(enum.TaskStatusPending).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create backtest: %w", err)
		}

		// Load backtest with edges for validation
		bt, err = tx.Backtest.Query().
			Where(backtest.ID(bt.ID)).
			WithRunner().
			WithStrategy().
			Only(ctx)
		if err != nil {
			return fmt.Errorf("failed to reload backtest with edges: %w", err)
		}

		// Validate by building the backtest spec
		// This will fail with "pairs not found in strategy config" if validation fails
		// If this fails, the entire transaction rolls back and no backtest entity is created
		_, err = buildBacktestSpec(bt)
		if err != nil {
			return fmt.Errorf("failed to build backtest spec: %w", err)
		}

		result = bt
		return nil
	})

	if err != nil {
		return nil, err
	}

	// After transaction commits successfully, run the backtest
	// We need to reload with edges since the transaction result is detached
	result, err = r.client.Backtest.Query().
		Where(backtest.ID(result.ID)).
		WithRunner().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to reload backtest for execution: %w", err)
	}

	return r.runBacktestHelper(ctx, result)
}

func (r *mutationResolver) StopBacktest(ctx context.Context, id uuid.UUID) (*ent.Backtest, error) {
	// Load backtest with runner
	bt, err := r.client.Backtest.Query().
		Where(backtest.ID(id)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load backtest: %w", err)
	}

	// Only allow stopping running backtests
	if bt.Status != enum.TaskStatusRunning {
		return nil, fmt.Errorf("backtest is not running (status: %s)", bt.Status)
	}

	// Get the runner
	btRunner := bt.Edges.Runner
	if btRunner == nil {
		return nil, fmt.Errorf("backtest has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	backtestRunner, err := factory.CreateBacktestRunner(ctx, btRunner.Type, btRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create backtest runner client: %w", err)
	}
	defer func() {
		_ = backtestRunner.Close()
	}()

	// Stop the backtest container
	if err := backtestRunner.StopBacktest(ctx, id.String()); err != nil {
		return nil, fmt.Errorf("failed to stop backtest: %w", err)
	}

	// Update backtest status to cancelled
	bt, err = bt.Update().
		SetStatus(enum.TaskStatusCancelled).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update backtest status: %w", err)
	}

	return bt, nil
}

func (r *mutationResolver) DeleteBacktest(ctx context.Context, id uuid.UUID) (bool, error) {
	// Soft-delete backtest by setting deleted_at timestamp
	_, err := r.client.Backtest.UpdateOneID(id).SetDeletedAt(time.Now()).Save(ctx)
	return err == nil, err
}

func (r *mutationResolver) CreateTrade(ctx context.Context, input ent.CreateTradeInput) (*ent.Trade, error) {
	return r.client.Trade.Create().SetInput(input).Save(ctx)
}

func (r *mutationResolver) UpdateTrade(ctx context.Context, id uuid.UUID, input ent.UpdateTradeInput) (*ent.Trade, error) {
	return r.client.Trade.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteTrade(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.client.Trade.DeleteOneID(id).Exec(ctx)
	return err == nil, err
}

func (r *mutationResolver) SetStrategyVisibility(ctx context.Context, id uuid.UUID, public bool) (*ent.Strategy, error) {
	return UpdateStrategyVisibility(ctx, r.client, r.umaClient, id.String(), public)
}

func (r *mutationResolver) SetBotVisibility(ctx context.Context, id uuid.UUID, public bool) (*ent.Bot, error) {
	return UpdateBotVisibility(ctx, r.client, r.umaClient, id.String(), public)
}

func (r *mutationResolver) SetRunnerVisibility(ctx context.Context, id uuid.UUID, public bool) (*ent.BotRunner, error) {
	return UpdateBotRunnerVisibility(ctx, r.client, r.umaClient, id.String(), public)
}

func (r *mutationResolver) GetFreqtradeToken(ctx context.Context, botID uuid.UUID) (*model.FreqtradeToken, error) {
	// Load the bot with its runner configuration
	b, err := r.client.Bot.Query().
		Where(bot.ID(botID)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client to get bot status (for API URL)
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Get bot status from runner using bot ID
	status, err := rt.GetBotStatus(ctx, b.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get bot status (is the bot running?): %w", err)
	}

	// Verify bot is running and healthy
	if status.Status != enum.BotStatusRunning {
		return nil, fmt.Errorf("bot is not running (status: %s)", status.Status)
	}

	// Extract username and password from secure_config
	secureConfig := b.SecureConfig
	if secureConfig == nil {
		return nil, fmt.Errorf("bot has no secure_config")
	}

	apiServer, ok := secureConfig["api_server"].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("secure_config missing api_server")
	}

	username, ok := apiServer["username"].(string)
	if !ok || username == "" {
		return nil, fmt.Errorf("secure_config missing api_server.username")
	}

	password, ok := apiServer["password"].(string)
	if !ok || password == "" {
		return nil, fmt.Errorf("secure_config missing api_server.password")
	}

	// Get the direct API URL from the runtime
	// Each runtime (Docker, Kubernetes) handles this differently
	directAPIURL, err := rt.GetBotAPIURL(ctx, b.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get bot API URL: %w", err)
	}

	// Create Freqtrade client and login using direct URL
	ftClient := freqtrade.NewBotClient(directAPIURL, username, password)
	tokens, err := ftClient.Login(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to login to bot API: %w", err)
	}

	// Return the gateway proxy URL for frontend use
	// Frontend accesses bot via /gateway/v1/bot/{botId}/* which proxies to the bot
	proxyAPIURL := fmt.Sprintf("/gateway/v1/bot/%s", botID.String())

	return &model.FreqtradeToken{
		APIURL:       proxyAPIURL,
		Username:     username,
		AccessToken:  tokens.GetAccessToken(),
		RefreshToken: tokens.GetRefreshToken(),
	}, nil
}

func (r *mutationResolver) CreateAlertRule(ctx context.Context, input ent.CreateAlertRuleInput) (*ent.AlertRule, error) {
	alertSvc := alert.GetServiceFromContext(ctx)
	if alertSvc == nil {
		return nil, fmt.Errorf("alert service not available")
	}

	return alertSvc.CreateRule(ctx, input)
}

func (r *mutationResolver) UpdateAlertRule(ctx context.Context, id uuid.UUID, input ent.UpdateAlertRuleInput) (*ent.AlertRule, error) {
	alertSvc := alert.GetServiceFromContext(ctx)
	if alertSvc == nil {
		return nil, fmt.Errorf("alert service not available")
	}

	return alertSvc.UpdateRule(ctx, id, input)
}

func (r *mutationResolver) ToggleAlertRule(ctx context.Context, id uuid.UUID, enabled bool) (*ent.AlertRule, error) {
	alertSvc := alert.GetServiceFromContext(ctx)
	if alertSvc == nil {
		return nil, fmt.Errorf("alert service not available")
	}

	return alertSvc.ToggleRule(ctx, id, enabled)
}

func (r *mutationResolver) DeleteAlertRule(ctx context.Context, id uuid.UUID) (bool, error) {
	alertSvc := alert.GetServiceFromContext(ctx)
	if alertSvc == nil {
		return false, fmt.Errorf("alert service not available")
	}

	if err := alertSvc.DeleteRule(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

func (r *mutationResolver) TestAlertRule(ctx context.Context, id uuid.UUID) (bool, error) {
	alertMgr := alert.GetManagerFromContext(ctx)
	if alertMgr == nil {
		return false, fmt.Errorf("alert system not configured")
	}

	if err := alertMgr.TestRule(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

func (r *mutationResolver) MarkAlertEventAsRead(ctx context.Context, id uuid.UUID, ownerID string) (*ent.AlertEvent, error) {
	// Authorization is handled by @hasScope directive on ownerID
	// Verify the alert belongs to the specified organization
	event, err := r.client.AlertEvent.Get(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("alert event not found: %w", err)
	}

	if event.OwnerID != ownerID {
		return nil, fmt.Errorf("alert event does not belong to this organization")
	}

	// Update read_at timestamp
	now := time.Now()
	return r.client.AlertEvent.UpdateOneID(id).
		SetReadAt(now).
		Save(ctx)
}

func (r *mutationResolver) MarkAllAlertEventsAsRead(ctx context.Context, ownerID string) (int, error) {
	// Authentication is handled by @isAuthenticated directive
	// Update all unread events for this owner
	now := time.Now()
	count, err := r.client.AlertEvent.Update().
		Where(
			alertevent.OwnerID(ownerID),
			alertevent.ReadAtIsNil(),
		).
		SetReadAt(now).
		Save(ctx)
	if err != nil {
		return 0, fmt.Errorf("failed to mark events as read: %w", err)
	}

	return count, nil
}

func (r *queryResolver) GetBotRunnerStatus(ctx context.Context, id uuid.UUID) (*runner.BotStatus, error) {
	// Load the bot with its runner configuration
	b, err := r.client.Bot.Query().
		Where(bot.ID(id)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Get bot status from runner using bot ID
	status, err := rt.GetBotStatus(ctx, b.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get bot status from runner: %w", err)
	}

	return status, nil
}

// StrategyVersions returns all versions of a strategy by name
// Note: This query does NOT filter by owner - authorization should be handled by UMA/Keycloak
// or by the client passing the appropriate ownerID in the where clause of the main strategies query
func (r *queryResolver) StrategyVersions(ctx context.Context, name string) ([]*ent.Strategy, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Get all versions of a strategy by name, ordered by version number
	// No owner filtering here - that's handled at the authorization layer
	return r.client.Strategy.Query().
		Where(strategy.Name(name)).
		Order(ent.Asc(strategy.FieldVersionNumber)).
		All(ctx)
}

// OrganizationUsage returns total usage for an organization over a time range.
func (r *queryResolver) OrganizationUsage(ctx context.Context, ownerID string, start time.Time, end time.Time) (*ent.ResourceUsageAggregation, error) {
	// Verify user is authenticated
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, err
	}

	// Use the calculator to get organization usage
	calc := usage.NewCalculator(r.client)
	summary, err := calc.GetOrganizationUsage(ctx, ownerID, start, end)
	if err != nil {
		return nil, err
	}

	if summary == nil {
		return nil, nil
	}

	// Convert UsageSummary to ResourceUsageAggregation for GraphQL response
	// Note: This is a synthetic aggregation, not stored in the database
	return &ent.ResourceUsageAggregation{
		ResourceType:    summary.ResourceType,
		ResourceID:      summary.ResourceID,
		OwnerID:         summary.OwnerID,
		RunnerID:        summary.RunnerID,
		Granularity:     enum.AggregationGranularityDaily, // Synthetic aggregation
		BucketStart:     summary.PeriodStart,
		BucketEnd:       summary.PeriodEnd,
		CPUCoreSeconds:  summary.CPUCoreSeconds,
		CPUAvgPercent:   summary.CPUAvgPercent,
		CPUMaxPercent:   summary.CPUMaxPercent,
		MemoryGBSeconds: summary.MemoryGBSeconds,
		MemoryAvgBytes:  summary.MemoryAvgBytes,
		MemoryMaxBytes:  summary.MemoryMaxBytes,
		NetworkRxBytes:  summary.NetworkRxBytes,
		NetworkTxBytes:  summary.NetworkTxBytes,
		BlockReadBytes:  summary.BlockReadBytes,
		BlockWriteBytes: summary.BlockWriteBytes,
		SampleCount:     summary.SampleCount,
	}, nil
}

// EstimatedCost calculates the estimated cost for usage over a time range.
func (r *queryResolver) EstimatedCost(ctx context.Context, ownerID string, start time.Time, end time.Time) (*model.UsageCost, error) {
	// Verify user is authenticated
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, err
	}

	calc := usage.NewCalculator(r.client)

	// Get usage breakdown by resource to calculate costs per-runner
	breakdown, err := calc.GetUsageBreakdown(ctx, ownerID, start, end)
	if err != nil {
		return nil, err
	}

	// Aggregate costs across all resources
	totalCost := &model.UsageCost{Currency: "USD"}

	for _, summary := range breakdown {
		// Get runner rates
		rates, err := calc.GetRunnerRates(ctx, summary.RunnerID)
		if err != nil {
			// Skip if runner not found (may have been deleted)
			continue
		}

		// Calculate cost for this resource
		cost := calc.CalculateCost(&summary, rates)
		if cost != nil {
			totalCost.CPUCost += cost.CPUCost
			totalCost.MemoryCost += cost.MemoryCost
			totalCost.NetworkCost += cost.NetworkCost
			totalCost.StorageCost += cost.StorageCost
			totalCost.TotalCost += cost.TotalCost
		}
	}

	return totalCost, nil
}

// BotUsageHistory returns usage history for a bot over a time range.
// Returns raw aggregation records (not combined) for time-series charting.
func (r *queryResolver) BotUsageHistory(ctx context.Context, botID uuid.UUID, start time.Time, end time.Time) ([]*ent.ResourceUsageAggregation, error) {
	// Verify user is authenticated (directive handles scope check)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, err
	}

	// Convert times to local timezone to match how data is stored in SQLite
	localStart := start.Local()
	localEnd := end.Local()

	// Query aggregations for the bot within the time range
	// Return raw records sorted by bucket start for time-series charting
	aggs, err := r.client.ResourceUsageAggregation.Query().
		Where(
			resourceusageaggregation.ResourceID(botID),
			resourceusageaggregation.ResourceTypeEQ(enum.ResourceTypeBot),
			resourceusageaggregation.BucketStartGTE(localStart),
			resourceusageaggregation.BucketStartLT(localEnd),
		).
		Order(ent.Asc(resourceusageaggregation.FieldBucketStart)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query bot usage history: %w", err)
	}

	return aggs, nil
}

func (r *queryResolver) AlertTypesForResource(ctx context.Context, resourceType enum.AlertResourceType, resourceID *uuid.UUID) ([]*model.AlertTypeInfo, error) {
	// Get alert types from the alert package
	var resourceIDStr *string
	if resourceID != nil {
		s := resourceID.String()
		resourceIDStr = &s
	}

	alertTypes := alert.GetAlertTypesForResource(resourceType, resourceIDStr)

	// Convert to GraphQL model types
	result := make([]*model.AlertTypeInfo, 0, len(alertTypes))
	for _, at := range alertTypes {
		conditionFields := make([]*model.ConditionField, 0, len(at.ConditionFields))
		for _, cf := range at.ConditionFields {
			options := make([]*model.SelectOption, 0, len(cf.Options))
			for _, opt := range cf.Options {
				options = append(options, &model.SelectOption{
					Value: opt.Value,
					Label: opt.Label,
				})
			}

			var unit *string
			if cf.Unit != "" {
				unit = &cf.Unit
			}

			conditionFields = append(conditionFields, &model.ConditionField{
				Name:        cf.Name,
				Label:       cf.Label,
				Type:        model.ConditionFieldType(cf.Type),
				Required:    cf.Required,
				Description: cf.Description,
				Min:         cf.Min,
				Max:         cf.Max,
				Default:     cf.Default,
				Unit:        unit,
				Options:     options,
			})
		}

		result = append(result, &model.AlertTypeInfo{
			Type:            at.Type,
			Label:           at.Label,
			Description:     at.Description,
			DefaultSeverity: at.DefaultSeverity,
			ConditionFields: conditionFields,
		})
	}

	return result, nil
}

func (r *queryResolver) CheckPermissions(ctx context.Context, permissions []*model.PermissionCheckInput) ([]*model.PermissionCheckResult, error) {
	// Get user context
	userCtx, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Get UMA client from context
	umaClient := GetUMAClientFromContext(ctx)
	if umaClient == nil {
		return nil, fmt.Errorf("UMA client not available")
	}

	results := make([]*model.PermissionCheckResult, len(permissions))

	for i, perm := range permissions {
		resourceID := perm.ResourceID.String()
		scope := perm.Scope

		// Check permission
		granted, err := umaClient.CheckPermission(ctx, userCtx.RawToken, resourceID, scope)

		// If permission denied and might be due to invalid scope, trigger self-healing
		if authz.ShouldTriggerSelfHealing(granted, err) {
			// Try to sync scopes for this resource
			if syncErr := SyncResourceScopes(ctx, r.client, resourceID); syncErr != nil {
				log.Printf("Self-healing failed for resource %s: %v", resourceID, syncErr)
			} else {
				// Re-check permission after sync
				granted, err = umaClient.CheckPermission(ctx, userCtx.RawToken, resourceID, scope)
				if err != nil {
					log.Printf("Permission re-check failed for %s#%s: %v", resourceID, scope, err)
				}
			}
		}

		// Log non-invalid-scope errors but don't fail the whole request
		if err != nil && !authz.IsInvalidScopeError(err) {
			log.Printf("Permission check error for %s#%s: %v", resourceID, scope, err)
		}

		results[i] = &model.PermissionCheckResult{
			ResourceID: perm.ResourceID,
			Scope:      scope,
			Granted:    granted,
		}
	}

	return results, nil
}

func (r *queryResolver) OrganizationUsers(ctx context.Context, organizationID string) ([]*model.OrganizationUser, error) {
	// Authorization is handled by @hasScope directive
	// organizationId is validated by the directive to ensure user has view-users permission

	// Create admin client
	adminClient := keycloak.NewAdminClient(r.auth.GetConfig())

	// Get organization users from Keycloak
	// organizationID is the group UUID in Keycloak
	kcUsers, err := adminClient.GetGroupUsers(ctx, organizationID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch organization users: %w", err)
	}

	// Convert keycloak.OrganizationUser to model.OrganizationUser
	users := make([]*model.OrganizationUser, len(kcUsers))
	for i, kcUser := range kcUsers {
		// Parse Keycloak user ID (UUID string) to uuid.UUID
		userID, err := uuid.Parse(kcUser.ID)
		if err != nil {
			return nil, fmt.Errorf("invalid user ID format for user %s: %w", kcUser.Username, err)
		}

		users[i] = &model.OrganizationUser{
			ID:            userID,
			Username:      kcUser.Username,
			Email:         &kcUser.Email,
			EmailVerified: kcUser.EmailVerified,
			FirstName:     &kcUser.FirstName,
			LastName:      &kcUser.LastName,
			Enabled:       kcUser.Enabled,
			CreatedAt:     time.UnixMilli(kcUser.CreatedAt),
		}
	}

	return users, nil
}

func (r *queryResolver) OrganizationGroupTree(ctx context.Context, organizationID string) (*model.GroupNode, error) {
	// Authorization is handled by @hasScope directive
	// organizationId is validated by the directive to ensure user has view-users permission

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return nil, fmt.Errorf("admin client not available")
	}

	// Delegate to organization package (business logic layer)
	return organization.GetGroupTree(ctx, adminClient, organizationID)
}

func (r *queryResolver) GroupMembers(ctx context.Context, organizationID string, groupID string) ([]*model.OrganizationUser, error) {
	// Authorization is handled by @hasScope directive on organizationId
	// organizationId is validated by the directive to ensure user has view-users permission

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return nil, fmt.Errorf("admin client not available")
	}

	// Delegate to organization package (business logic layer)
	return organization.GetGroupMembers(ctx, adminClient, groupID)
}

func (r *queryResolver) ResourceGroups(ctx context.Context, organizationID string, where *model.ResourceGroupWhereInput, orderBy *model.ResourceGroupOrder, first *int, offset *int) (*model.ResourceGroupConnection, error) {
	// Authorization is handled by @hasScope directive
	// organizationId is validated by the directive to ensure user has view-users permission

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return nil, fmt.Errorf("admin client not available")
	}

	// Set defaults for pagination
	pageSize := 20
	pageOffset := 0
	if first != nil && *first > 0 {
		pageSize = *first
	}
	if offset != nil && *offset > 0 {
		pageOffset = *offset
	}

	// Call organization package (thin wrapper to Keycloak extension)
	return organization.GetResourceGroups(ctx, adminClient, organizationID, where, orderBy, pageSize, pageOffset)
}

func (r *queryResolver) ResourceGroupMembers(ctx context.Context, organizationID string, resourceGroupID string, where *model.ResourceGroupMemberWhereInput, orderBy *model.ResourceGroupMemberOrder, first *int, offset *int) (*model.ResourceGroupMemberConnection, error) {
	// Authorization is handled by @hasScope directive
	// organizationId is validated by the directive to ensure user has view-users permission

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return nil, fmt.Errorf("admin client not available")
	}

	// Set defaults for pagination
	pageSize := 50
	pageOffset := 0
	if first != nil && *first > 0 {
		pageSize = *first
	}
	if offset != nil && *offset > 0 {
		pageOffset = *offset
	}

	// Call organization package (thin wrapper to Keycloak extension)
	return organization.GetResourceGroupMembers(ctx, adminClient, organizationID, resourceGroupID, where, orderBy, pageSize, pageOffset)
}

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
