package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"
	"time"
	"volaticloud/internal/auth"
	backtest1 "volaticloud/internal/backtest"
	"volaticloud/internal/ent"
	"volaticloud/internal/ent/backtest"
	"volaticloud/internal/ent/bot"
	"volaticloud/internal/ent/strategy"
	"volaticloud/internal/enum"
	"volaticloud/internal/graph/model"
	"volaticloud/internal/monitor"
	"volaticloud/internal/runner"

	"github.com/google/uuid"
)

func (r *backtestResolver) Summary(ctx context.Context, obj *ent.Backtest) (*backtest1.BacktestSummary, error) {
	// If no summary stored in database, return nil (not an error)
	if len(obj.Summary) == 0 {
		return nil, nil
	}

	// Convert map to BacktestSummary struct via JSON
	// This is safe because the summary was created by backtest1.ExtractSummaryFromResult
	summary := &backtest1.BacktestSummary{}

	// Simple field-by-field extraction would be more efficient,
	// but JSON marshaling is cleaner and safer
	jsonBytes, err := json.Marshal(obj.Summary)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal summary: %w", err)
	}

	if err := json.Unmarshal(jsonBytes, summary); err != nil {
		return nil, fmt.Errorf("failed to unmarshal summary: %w", err)
	}

	return summary, nil
}

func (r *mutationResolver) CreateExchange(ctx context.Context, input ent.CreateExchangeInput) (*ent.Exchange, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Create exchange with Keycloak resource sync (uses transaction internally)
	// OwnerID comes from the input and represents the selected group/organization
	return CreateExchangeWithResource(ctx, r.client, r.umaClient, input, input.OwnerID)
}

func (r *mutationResolver) UpdateExchange(ctx context.Context, id uuid.UUID, input ent.UpdateExchangeInput) (*ent.Exchange, error) {
	return r.client.Exchange.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteExchange(ctx context.Context, id uuid.UUID) (bool, error) {
	// Use Keycloak-aware deletion
	err := DeleteExchangeWithResource(ctx, r.client, r.umaClient, id.String())
	return err == nil, err
}

func (r *mutationResolver) CreateStrategy(ctx context.Context, input ent.CreateStrategyInput) (*ent.Strategy, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Create strategy with Keycloak resource sync (uses transaction internally)
	// OwnerID comes from the input and represents the selected group/organization
	return CreateStrategyWithResource(ctx, r.client, r.umaClient, input, input.OwnerID)
}

func (r *mutationResolver) UpdateStrategy(ctx context.Context, id uuid.UUID, input ent.UpdateStrategyInput) (*ent.Strategy, error) {
	var result *ent.Strategy

	// Use transaction to ensure atomicity - both operations succeed or both fail
	err := WithTx(ctx, r.client, func(tx *ent.Tx) error {
		// Load existing strategy (within transaction)
		oldStrategy, err := tx.Strategy.Get(ctx, id)
		if err != nil {
			return fmt.Errorf("failed to load strategy: %w", err)
		}

		// Mark old strategy as not latest (within transaction)
		err = tx.Strategy.UpdateOneID(id).SetIsLatest(false).Exec(ctx)
		if err != nil {
			return fmt.Errorf("failed to mark old strategy as not latest: %w", err)
		}

		// Create new version with input values, falling back to old values (within transaction)
		newVersion := tx.Strategy.Create().
			SetName(coalesce(input.Name, &oldStrategy.Name)).
			SetDescription(coalesce(input.Description, &oldStrategy.Description)).
			SetCode(coalesce(input.Code, &oldStrategy.Code)).
			SetVersionNumber(oldStrategy.VersionNumber + 1).
			SetParentID(oldStrategy.ID).
			SetIsLatest(true).
			SetOwnerID(oldStrategy.OwnerID) // Preserve owner_id from parent

		// Handle optional fields
		if input.Config != nil {
			newVersion.SetConfig(input.Config)
		} else if oldStrategy.Config != nil {
			newVersion.SetConfig(oldStrategy.Config)
		}

		// Save new version (this will trigger validation hook)
		// If validation fails, the entire transaction rolls back
		result, err = newVersion.Save(ctx)
		if err != nil {
			return err
		}

		// Sync Keycloak resource for new version
		if r.umaClient != nil {
			err = SyncStrategyVersionResource(ctx, r.umaClient, result)
			if err != nil {
				// Keycloak sync failed - rollback transaction
				return fmt.Errorf("failed to sync Keycloak resource (transaction will rollback): %w", err)
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

func (r *mutationResolver) DeleteStrategy(ctx context.Context, id uuid.UUID) (bool, error) {
	// Use Keycloak-aware deletion
	err := DeleteStrategyWithResource(ctx, r.client, r.umaClient, id.String())
	return err == nil, err
}

func (r *mutationResolver) CreateBot(ctx context.Context, input ent.CreateBotInput) (*ent.Bot, error) {
	// Step 1: Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Step 2: Basic validation - just ensure config is provided
	// Note: Full schema validation is available in validateFreqtradeConfigWithSchema()
	// but requires a complete merged config (Exchange + Strategy + Bot)
	if input.Config == nil {
		return nil, fmt.Errorf("bot config is required for Freqtrade bots")
	}

	// Step 3: Create the bot in the database with Keycloak resource sync
	// This uses transaction internally and syncs with Keycloak
	createdBot, err := CreateBotWithResource(ctx, r.client, r.umaClient, input, input.OwnerID)
	if err != nil {
		return nil, fmt.Errorf("failed to create bot: %w", err)
	}

	// Step 2.5: Generate secure_config and update the bot
	// This config contains system-forced settings that users cannot override
	secureConfig, err := generateSecureConfig()
	if err != nil {
		return nil, fmt.Errorf("failed to generate secure config: %w", err)
	}

	// Update the bot with secure_config
	createdBot, err = r.client.Bot.UpdateOneID(createdBot.ID).
		SetSecureConfig(secureConfig).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot with secure config: %w", err)
	}

	// Step 2: Load the bot with all its relations
	createdBot, err = r.client.Bot.Query().
		Where(bot.IDEQ(createdBot.ID)).
		WithRunner().
		WithExchange().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot with relations: %w", err)
	}

	// Step 3: Create the runner client
	botRunner := createdBot.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Step 4: Build BotSpec from bot data
	spec, err := buildBotSpec(createdBot)
	if err != nil {
		return nil, fmt.Errorf("failed to build bot spec: %w", err)
	}

	// Step 5: Create the container
	containerID, err := rt.CreateBot(ctx, *spec)
	if err != nil {
		// Update bot status to error
		r.client.Bot.UpdateOneID(createdBot.ID).
			SetStatus(enum.BotStatusError).
			SetErrorMessage(fmt.Sprintf("Failed to create container: %v", err)).
			Save(ctx)
		return nil, fmt.Errorf("failed to create bot container: %w", err)
	}

	// Step 6: Update bot with container_id and set status to stopped
	createdBot, err = r.client.Bot.UpdateOneID(createdBot.ID).
		SetContainerID(containerID).
		SetStatus(enum.BotStatusStopped).
		ClearErrorMessage().
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot with container ID: %w", err)
	}

	return createdBot, nil
}

func (r *mutationResolver) UpdateBot(ctx context.Context, id uuid.UUID, input ent.UpdateBotInput) (*ent.Bot, error) {
	// Validate bot config if it's being updated
	if input.Config != nil {
		if err := validateFreqtradeConfigWithSchema(input.Config); err != nil {
			return nil, fmt.Errorf("invalid bot configuration: %w", err)
		}
	}

	return r.client.Bot.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteBot(ctx context.Context, id uuid.UUID) (bool, error) {
	// Use Keycloak-aware deletion
	err := DeleteBotWithResource(ctx, r.client, r.umaClient, id.String())
	return err == nil, err
}

func (r *mutationResolver) StartBot(ctx context.Context, id uuid.UUID) (*ent.Bot, error) {
	// Load the bot with its runner, exchange, and strategy
	b, err := r.client.Bot.Query().
		Where(bot.ID(id)).
		WithRunner().
		WithExchange().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Check if container exists, if not create it
	containerID := b.ContainerID
	if containerID == "" {
		// Build BotSpec from bot data
		spec, err := buildBotSpec(b)
		if err != nil {
			return nil, fmt.Errorf("failed to build bot spec: %w", err)
		}

		// Create the container
		containerID, err = rt.CreateBot(ctx, *spec)
		if err != nil {
			// Update bot status to error
			r.client.Bot.UpdateOneID(b.ID).
				SetStatus(enum.BotStatusError).
				SetErrorMessage(fmt.Sprintf("Failed to create container: %v", err)).
				Save(ctx)
			return nil, fmt.Errorf("failed to create bot container: %w", err)
		}

		// Update bot with container_id
		b, err = r.client.Bot.UpdateOneID(b.ID).
			SetContainerID(containerID).
			ClearErrorMessage().
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to update bot with container ID: %w", err)
		}
	}

	// Start the bot in the runtime
	if err := rt.StartBot(ctx, containerID); err != nil {
		// If container not found, clear container ID and return error
		if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "No such container") {
			r.client.Bot.UpdateOneID(id).
				ClearContainerID().
				SetStatus(enum.BotStatusStopped).
				Save(ctx)
			return nil, fmt.Errorf("container was deleted manually - please try starting again")
		}
		return nil, fmt.Errorf("failed to start bot in runner: %w", err)
	}

	// Update bot status
	b, err = r.client.Bot.UpdateOneID(id).
		SetStatus(enum.BotStatusRunning).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot status: %w", err)
	}

	return b, nil
}

func (r *mutationResolver) StopBot(ctx context.Context, id uuid.UUID) (*ent.Bot, error) {
	// Load the bot with its runner configuration
	b, err := r.client.Bot.Query().
		Where(bot.ID(id)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Stop the bot in the runtime
	containerID := b.ContainerID
	if containerID == "" {
		// No container ID means it was never created or already deleted
		// Just update status to stopped
		b, err = r.client.Bot.UpdateOneID(id).
			SetStatus(enum.BotStatusStopped).
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to update bot status: %w", err)
		}
		return b, nil
	}

	if err := rt.StopBot(ctx, containerID); err != nil {
		// If container not found, just update status - it was manually deleted
		if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "No such container") {
			b, err = r.client.Bot.UpdateOneID(id).
				SetStatus(enum.BotStatusStopped).
				ClearContainerID().
				Save(ctx)
			if err != nil {
				return nil, fmt.Errorf("failed to update bot status: %w", err)
			}
			return b, nil
		}
		return nil, fmt.Errorf("failed to stop bot in runner: %w", err)
	}

	// Update bot status
	b, err = r.client.Bot.UpdateOneID(id).
		SetStatus(enum.BotStatusStopped).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot status: %w", err)
	}

	return b, nil
}

func (r *mutationResolver) RestartBot(ctx context.Context, id uuid.UUID) (*ent.Bot, error) {
	// Load the bot with its runner, exchange, and strategy
	b, err := r.client.Bot.Query().
		Where(bot.ID(id)).
		WithRunner().
		WithExchange().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Check if container exists, if not create it
	containerID := b.ContainerID
	if containerID == "" {
		// Build BotSpec from bot data
		spec, err := buildBotSpec(b)
		if err != nil {
			return nil, fmt.Errorf("failed to build bot spec: %w", err)
		}

		// Create the container
		containerID, err = rt.CreateBot(ctx, *spec)
		if err != nil {
			// Update bot status to error
			r.client.Bot.UpdateOneID(b.ID).
				SetStatus(enum.BotStatusError).
				SetErrorMessage(fmt.Sprintf("Failed to create container: %v", err)).
				Save(ctx)
			return nil, fmt.Errorf("failed to create bot container: %w", err)
		}

		// Update bot with container_id
		b, err = r.client.Bot.UpdateOneID(b.ID).
			SetContainerID(containerID).
			ClearErrorMessage().
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to update bot with container ID: %w", err)
		}
	}

	// Restart the bot in the runtime
	if err := rt.RestartBot(ctx, containerID); err != nil {
		// If container not found, clear container ID and return error
		if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "No such container") {
			r.client.Bot.UpdateOneID(id).
				ClearContainerID().
				SetStatus(enum.BotStatusStopped).
				Save(ctx)
			return nil, fmt.Errorf("container was deleted manually - please try restarting again")
		}
		return nil, fmt.Errorf("failed to restart bot in runner: %w", err)
	}

	// Update bot status
	b, err = r.client.Bot.UpdateOneID(id).
		SetStatus(enum.BotStatusRunning).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot status: %w", err)
	}

	return b, nil
}

func (r *mutationResolver) CreateBotRunner(ctx context.Context, input ent.CreateBotRunnerInput) (*ent.BotRunner, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Create bot runner with Keycloak resource sync (uses transaction internally)
	// OwnerID comes from the input and represents the selected group/organization
	return CreateBotRunnerWithResource(ctx, r.client, r.umaClient, input, input.OwnerID)
}

func (r *mutationResolver) UpdateBotRunner(ctx context.Context, id uuid.UUID, input ent.UpdateBotRunnerInput) (*ent.BotRunner, error) {
	return r.client.BotRunner.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteBotRunner(ctx context.Context, id uuid.UUID) (bool, error) {
	// Use Keycloak-aware deletion
	err := DeleteBotRunnerWithResource(ctx, r.client, r.umaClient, id.String())
	return err == nil, err
}

func (r *mutationResolver) RefreshRunnerData(ctx context.Context, id uuid.UUID) (*ent.BotRunner, error) {
	// Load the runner
	runner, err := r.client.BotRunner.Get(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to load runner: %w", err)
	}

	// Check if already downloading
	if runner.DataDownloadStatus == enum.DataDownloadStatusDownloading {
		return nil, fmt.Errorf("data download already in progress for runner %s", runner.Name)
	}

	// Update status to downloading and clear any previous errors
	runner, err = r.client.BotRunner.UpdateOneID(id).
		SetDataDownloadStatus(enum.DataDownloadStatusDownloading).
		SetDataDownloadProgress(map[string]interface{}{
			"pairs_completed":  0,
			"pairs_total":      0,
			"current_pair":     "",
			"percent_complete": 0.0,
		}).
		ClearDataErrorMessage().
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update runner status: %w", err)
	}

	// Trigger download in background goroutine
	go func() {
		downloadCtx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
		defer cancel()

		if err := monitor.DownloadRunnerData(downloadCtx, r.client, runner); err != nil {
			log.Printf("Runner %s: data download failed: %v", runner.Name, err)

			// Update status to failed
			r.client.BotRunner.UpdateOne(runner).
				SetDataDownloadStatus(enum.DataDownloadStatusFailed).
				SetDataIsReady(false).
				SetDataErrorMessage(err.Error()).
				Save(context.Background())
		} else {
			log.Printf("Runner %s: data download completed successfully", runner.Name)

			// Update status to completed
			now := time.Now()
			r.client.BotRunner.UpdateOne(runner).
				SetDataDownloadStatus(enum.DataDownloadStatusCompleted).
				SetDataIsReady(true).
				SetDataLastUpdated(now).
				ClearDataErrorMessage().
				ClearDataDownloadProgress().
				Save(context.Background())
		}
	}()

	return runner, nil
}

func (r *mutationResolver) TestRunnerConnection(ctx context.Context, typeArg enum.RunnerType, config model.RunnerConfigInput) (*model.ConnectionTestResult, error) {
	// Convert config input to map format
	configMap, err := convertRunnerConfigInput(config)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Invalid configuration: %v", err),
		}, nil
	}

	// Create runner using factory
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, typeArg, configMap)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to create runner client: %v", err),
		}, nil
	}
	defer rt.Close()

	// For Docker runners, try to ping and get version
	// Ping with timeout
	pingCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	// Use GetBotStatus as a connection test
	// This should return an error if connection fails
	_, err = rt.ListBots(pingCtx)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to connect to runner: %v", err),
		}, nil
	}

	return &model.ConnectionTestResult{
		Success: true,
		Message: fmt.Sprintf("Successfully connected to %s runner", typeArg),
	}, nil
}

func (r *mutationResolver) CreateBacktest(ctx context.Context, input ent.CreateBacktestInput) (*ent.Backtest, error) {
	var result *ent.Backtest

	// Use transaction to ensure atomicity - entity creation and validation both succeed or both fail
	err := WithTx(ctx, r.client, func(tx *ent.Tx) error {
		strategyID := input.StrategyID

		// Load strategy with backtest relationship to check if it already has one
		existingStrategy, err := tx.Strategy.Query().
			Where(strategy.ID(strategyID)).
			WithBacktest().
			Only(ctx)

		if err != nil {
			return fmt.Errorf("failed to load strategy: %w", err)
		}

		// If strategy already has a backtest, automatically create a new version
		if existingStrategy.Edges.Backtest != nil {
			log.Printf("Strategy %s (v%d) already has a backtest, creating new version for backtest",
				existingStrategy.Name, existingStrategy.VersionNumber)

			// Create new strategy version using helper function
			newVersion, err := createStrategyVersion(ctx, tx, existingStrategy)
			if err != nil {
				return fmt.Errorf("failed to create new strategy version: %w", err)
			}

			// Use the new strategy version for this backtest
			strategyID = newVersion.ID
			log.Printf("Created strategy version %d (ID: %s) for backtest",
				newVersion.VersionNumber, newVersion.ID)
		}

		// Create backtest entity with the (possibly new) strategy ID
		bt, err := tx.Backtest.Create().
			SetStrategyID(strategyID).
			SetRunnerID(input.RunnerID).
			SetNillableStartDate(input.StartDate).
			SetNillableEndDate(input.EndDate).
			SetStatus(enum.TaskStatusPending).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create backtest: %w", err)
		}

		// Load backtest with edges for validation
		bt, err = tx.Backtest.Query().
			Where(backtest.ID(bt.ID)).
			WithRunner().
			WithStrategy().
			Only(ctx)
		if err != nil {
			return fmt.Errorf("failed to reload backtest with edges: %w", err)
		}

		// Validate by building the backtest spec
		// This will fail with "pairs not found in strategy config" if validation fails
		// If this fails, the entire transaction rolls back and no backtest entity is created
		_, err = buildBacktestSpec(bt)
		if err != nil {
			return fmt.Errorf("failed to build backtest spec: %w", err)
		}

		result = bt
		return nil
	})

	if err != nil {
		return nil, err
	}

	// After transaction commits successfully, run the backtest
	// We need to reload with edges since the transaction result is detached
	result, err = r.client.Backtest.Query().
		Where(backtest.ID(result.ID)).
		WithRunner().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to reload backtest for execution: %w", err)
	}

	return r.runBacktestHelper(ctx, result)
}

func (r *mutationResolver) DeleteBacktest(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.client.Backtest.DeleteOneID(id).Exec(ctx)
	return err == nil, err
}

func (r *mutationResolver) RunBacktest(ctx context.Context, id uuid.UUID) (*ent.Backtest, error) {
	// Load the backtest with its runner and strategy
	bt, err := r.client.Backtest.Query().
		Where(backtest.ID(id)).
		WithRunner().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load backtest: %w", err)
	}

	// Use the helper to run the backtest
	return r.runBacktestHelper(ctx, bt)
}

func (r *mutationResolver) StopBacktest(ctx context.Context, id uuid.UUID) (*ent.Backtest, error) {
	// Load the backtest with its runner configuration
	bt, err := r.client.Backtest.Query().
		Where(backtest.ID(id)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load backtest: %w", err)
	}

	// Get the runner
	btRunner := bt.Edges.Runner
	if btRunner == nil {
		return nil, fmt.Errorf("backtest has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	backtestRunner, err := factory.CreateBacktestRunner(ctx, btRunner.Type, btRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create backtest runner client: %w", err)
	}
	defer backtestRunner.Close()

	// Stop the backtest in the runtime
	containerID := bt.ContainerID
	if containerID == "" {
		// No container ID means it was never started or already deleted
		// Just update status to stopped
		bt, err = r.client.Backtest.UpdateOneID(id).
			SetStatus(enum.TaskStatusCompleted).
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to update backtest status: %w", err)
		}
		return bt, nil
	}

	if err := backtestRunner.StopBacktest(ctx, containerID); err != nil {
		// If container not found, just update status - it was manually deleted or completed
		if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "No such container") {
			bt, err = r.client.Backtest.UpdateOneID(id).
				SetStatus(enum.TaskStatusCompleted).
				ClearContainerID().
				Save(ctx)
			if err != nil {
				return nil, fmt.Errorf("failed to update backtest status: %w", err)
			}
			return bt, nil
		}
		return nil, fmt.Errorf("failed to stop backtest in runner: %w", err)
	}

	// Update backtest status
	bt, err = r.client.Backtest.UpdateOneID(id).
		SetStatus(enum.TaskStatusCompleted).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update backtest status: %w", err)
	}

	return bt, nil
}

func (r *mutationResolver) CreateTrade(ctx context.Context, input ent.CreateTradeInput) (*ent.Trade, error) {
	return r.client.Trade.Create().SetInput(input).Save(ctx)
}

func (r *mutationResolver) UpdateTrade(ctx context.Context, id uuid.UUID, input ent.UpdateTradeInput) (*ent.Trade, error) {
	return r.client.Trade.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteTrade(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.client.Trade.DeleteOneID(id).Exec(ctx)
	return err == nil, err
}

func (r *queryResolver) GetBotRunnerStatus(ctx context.Context, id uuid.UUID) (*runner.BotStatus, error) {
	// Load the bot with its runner configuration
	b, err := r.client.Bot.Query().
		Where(bot.ID(id)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Get bot status from runner
	containerID := b.ContainerID
	if containerID == "" {
		return nil, fmt.Errorf("bot has no container ID")
	}

	status, err := rt.GetBotStatus(ctx, containerID)
	if err != nil {
		return nil, fmt.Errorf("failed to get bot status from runner: %w", err)
	}

	return status, nil
}

// StrategyVersions returns all versions of a strategy by name
// Note: This query does NOT filter by owner - authorization should be handled by UMA/Keycloak
// or by the client passing the appropriate ownerID in the where clause of the main strategies query
func (r *queryResolver) StrategyVersions(ctx context.Context, name string) ([]*ent.Strategy, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Get all versions of a strategy by name, ordered by version number
	// No owner filtering here - that's handled at the authorization layer
	return r.client.Strategy.Query().
		Where(strategy.Name(name)).
		Order(ent.Asc(strategy.FieldVersionNumber)).
		All(ctx)
}

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
