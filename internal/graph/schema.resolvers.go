package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"
	"time"
	"volaticloud/internal/alert"
	"volaticloud/internal/auth"
	"volaticloud/internal/authz"
	backtest1 "volaticloud/internal/backtest"
	"volaticloud/internal/billing"
	bot1 "volaticloud/internal/bot"
	"volaticloud/internal/ent"
	"volaticloud/internal/ent/alertevent"
	"volaticloud/internal/ent/backtest"
	"volaticloud/internal/ent/bot"
	"volaticloud/internal/ent/creditbalance"
	"volaticloud/internal/ent/credittransaction"
	"volaticloud/internal/ent/resourceusageaggregation"
	"volaticloud/internal/ent/strategy"
	"volaticloud/internal/ent/stripesubscription"
	"volaticloud/internal/enum"
	"volaticloud/internal/freqtrade"
	"volaticloud/internal/graph/model"
	"volaticloud/internal/keycloak"
	"volaticloud/internal/monitor"
	"volaticloud/internal/organization"
	"volaticloud/internal/pubsub"
	"volaticloud/internal/runner"
	"volaticloud/internal/s3"
	strategy1 "volaticloud/internal/strategy"
	"volaticloud/internal/usage"

	"github.com/google/uuid"
)

func (r *backtestResolver) Summary(ctx context.Context, obj *ent.Backtest) (*backtest1.BacktestSummary, error) {
	// If no summary stored in database, return nil (not an error)
	if len(obj.Summary) == 0 {
		return nil, nil
	}

	// Convert map to BacktestSummary struct via JSON
	// This is safe because the summary was created by backtest1.ExtractSummaryFromResult
	summary := &backtest1.BacktestSummary{}

	// Simple field-by-field extraction would be more efficient,
	// but JSON marshaling is cleaner and safer
	jsonBytes, err := json.Marshal(obj.Summary)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal summary: %w", err)
	}

	if err := json.Unmarshal(jsonBytes, summary); err != nil {
		return nil, fmt.Errorf("failed to unmarshal summary: %w", err)
	}

	return summary, nil
}

// ResourceUsage returns the total usage for a backtest execution.
func (r *backtestResolver) ResourceUsage(ctx context.Context, obj *ent.Backtest) (*ent.ResourceUsageAggregation, error) {
	// Query all aggregations for this backtest
	aggs, err := r.client.ResourceUsageAggregation.Query().
		Where(
			resourceusageaggregation.ResourceTypeEQ(enum.ResourceTypeBacktest),
			resourceusageaggregation.ResourceID(obj.ID),
		).
		All(ctx)
	if err != nil {
		return nil, err
	}

	if len(aggs) == 0 {
		return nil, nil
	}

	if len(aggs) == 1 {
		return aggs[0], nil
	}

	// Combine all aggregations for this backtest
	var minStart, maxEnd time.Time
	for i, agg := range aggs {
		if i == 0 || agg.BucketStart.Before(minStart) {
			minStart = agg.BucketStart
		}
		if i == 0 || agg.BucketEnd.After(maxEnd) {
			maxEnd = agg.BucketEnd
		}
	}

	return usage.CombineAggregationsToEntity(aggs, minStart, maxEnd), nil
}

// RecentUsage returns the last 24 hours of usage for a bot.
func (r *botResolver) RecentUsage(ctx context.Context, obj *ent.Bot) (*ent.ResourceUsageAggregation, error) {
	// Query the most recent daily aggregation for this bot
	end := time.Now()
	start := end.Add(-24 * time.Hour)

	// Query aggregations for the past 24 hours
	aggs, err := r.client.ResourceUsageAggregation.Query().
		Where(
			resourceusageaggregation.ResourceTypeEQ(enum.ResourceTypeBot),
			resourceusageaggregation.ResourceID(obj.ID),
			resourceusageaggregation.BucketStartGTE(start),
			resourceusageaggregation.BucketStartLT(end),
		).
		Order(ent.Desc(resourceusageaggregation.FieldBucketStart)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	if len(aggs) == 0 {
		return nil, nil
	}

	// If we have multiple aggregations, combine them
	if len(aggs) == 1 {
		return aggs[0], nil
	}

	// Combine aggregations for the time period
	return usage.CombineAggregationsToEntity(aggs, start, end), nil
}

func (r *mutationResolver) CreateExchange(ctx context.Context, input ent.CreateExchangeInput) (*ent.Exchange, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Create exchange - ENT hook handles Keycloak resource sync automatically
	// OwnerID comes from the input and represents the selected group/organization
	return r.client.Exchange.Create().SetInput(input).Save(ctx)
}

func (r *mutationResolver) UpdateExchange(ctx context.Context, id uuid.UUID, input ent.UpdateExchangeInput) (*ent.Exchange, error) {
	return r.client.Exchange.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteExchange(ctx context.Context, id uuid.UUID) (bool, error) {
	// Soft-delete exchange by setting deleted_at timestamp
	// ENT hook handles Keycloak resource cleanup automatically
	_, err := r.client.Exchange.UpdateOneID(id).SetDeletedAt(time.Now()).Save(ctx)
	return err == nil, err
}

func (r *mutationResolver) CreateStrategy(ctx context.Context, input ent.CreateStrategyInput) (*ent.Strategy, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Determine builder mode (default to "code" if not specified)
	builderMode := enum.StrategyBuilderModeCode
	if input.BuilderMode != nil {
		builderMode = *input.BuilderMode
	}

	// Create strategy using domain function - handles UI builder code generation
	// ENT hook handles Keycloak resource sync automatically
	return strategy1.Create(ctx, r.client, &strategy1.CreateInput{
		Name:        input.Name,
		Description: input.Description,
		Code:        input.Code,
		Config:      input.Config,
		BuilderMode: builderMode,
		OwnerID:     input.OwnerID,
	})
}

func (r *mutationResolver) UpdateStrategy(ctx context.Context, id uuid.UUID, input ent.UpdateStrategyInput) (*ent.Strategy, error) {
	var result *ent.Strategy

	// Use transaction to ensure atomicity - both operations succeed or both fail
	// ENT hook handles Keycloak resource sync for new version automatically
	err := WithTx(ctx, r.client, func(tx *ent.Tx) error {
		// Load existing strategy (within transaction)
		oldStrategy, err := tx.Strategy.Get(ctx, id)
		if err != nil {
			return fmt.Errorf("failed to load strategy: %w", err)
		}

		// Convert builder mode to string for VersionInput
		var builderModeStr *string
		if input.BuilderMode != nil {
			s := string(*input.BuilderMode)
			builderModeStr = &s
		}

		// Create new version using domain function
		// Domain function handles UI builder code generation automatically
		versionInput := &strategy1.VersionInput{
			Name:        input.Name,
			Description: input.Description,
			Code:        input.Code,
			Config:      input.Config,
			BuilderMode: builderModeStr,
		}

		result, err = strategy1.CreateVersion(ctx, tx, oldStrategy, versionInput)
		if err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

func (r *mutationResolver) DeleteStrategy(ctx context.Context, id uuid.UUID) (bool, error) {
	// Soft-delete strategy and all its versions
	// Uses DeleteOneID which triggers the soft-delete hook
	// ENT hook handles Keycloak resource cleanup automatically
	err := strategy1.DeleteAllVersions(ctx, r.client, id)
	return err == nil, err
}

func (r *mutationResolver) PreviewStrategyCode(ctx context.Context, config map[string]any, className string) (*model.PreviewCodeResult, error) {
	// Convert map[string]any to map[string]interface{} for domain package
	configMap := make(map[string]interface{}, len(config))
	for k, v := range config {
		configMap[k] = v
	}

	// Call domain function (handles validation and code generation)
	result := strategy1.PreviewStrategyCode(configMap, className)

	// Convert domain result to GraphQL model
	var errorPtr *string
	if result.Error != "" {
		errorPtr = &result.Error
	}
	return &model.PreviewCodeResult{
		Success: result.Success,
		Code:    result.Code,
		Error:   errorPtr,
	}, nil
}

func (r *mutationResolver) CreateBot(ctx context.Context, input ent.CreateBotInput) (*ent.Bot, error) {
	// Step 1: Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Step 1.5: Check billing - ensure org is not suspended
	if err := billing.EnsureSufficientCredits(ctx, r.client, input.OwnerID); err != nil {
		return nil, err
	}

	// Step 2: Basic validation - just ensure config is provided
	// Note: Full schema validation is available in validateFreqtradeConfigWithSchema()
	// but requires a complete merged config (Exchange + Strategy + Bot)
	if input.Config == nil {
		return nil, fmt.Errorf("bot config is required for Freqtrade bots")
	}

	// Step 3: Create the bot in the database - ENT hook handles Keycloak resource sync automatically
	createdBot, err := r.client.Bot.Create().SetInput(input).Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create bot: %w", err)
	}

	// Step 4: Generate secure_config and update the bot
	// This config contains system-forced settings that users cannot override
	secureConfig, err := bot1.GenerateSecureConfig()
	if err != nil {
		return nil, fmt.Errorf("failed to generate secure config: %w", err)
	}

	// Update the bot with secure_config
	createdBot, err = r.client.Bot.UpdateOneID(createdBot.ID).
		SetSecureConfig(secureConfig).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot with secure config: %w", err)
	}

	// Step 2: Load the bot with all its relations
	createdBot, err = r.client.Bot.Query().
		Where(bot.IDEQ(createdBot.ID)).
		WithRunner().
		WithExchange().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot with relations: %w", err)
	}

	// Step 3: Create the runner client
	botRunner := createdBot.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Step 4: Build BotSpec from bot data
	spec, err := buildBotSpec(createdBot)
	if err != nil {
		return nil, fmt.Errorf("failed to build bot spec: %w", err)
	}

	// Generate presigned URL for S3 data download
	presignedURL, err := getPresignedDataURL(ctx, botRunner)
	if err != nil {
		return nil, fmt.Errorf("failed to get presigned URL: %w", err)
	}
	spec.DataDownloadURL = presignedURL

	// Step 5: Create the container (name derived from bot ID)
	if err := rt.CreateBot(ctx, *spec); err != nil {
		// Update bot status to error
		r.client.Bot.UpdateOneID(createdBot.ID).
			SetStatus(enum.BotStatusError).
			SetErrorMessage(fmt.Sprintf("Failed to create container: %v", err)).
			Save(ctx)
		return nil, fmt.Errorf("failed to create bot container: %w", err)
	}

	// Step 6: Update bot status to stopped (container created successfully)
	createdBot, err = r.client.Bot.UpdateOneID(createdBot.ID).
		SetStatus(enum.BotStatusStopped).
		ClearErrorMessage().
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot status: %w", err)
	}

	return createdBot, nil
}

func (r *mutationResolver) UpdateBot(ctx context.Context, id uuid.UUID, input ent.UpdateBotInput) (*ent.Bot, error) {
	// Note: Bot config is just one layer of the full Freqtrade config.
	// Exchange config is stored separately in the Exchange entity.
	// Full schema validation requires merging all config layers, which happens
	// at container creation time (StartBot), not at update time.
	// Basic nil check is sufficient here.
	return r.client.Bot.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteBot(ctx context.Context, id uuid.UUID) (bool, error) {
	// Soft-delete bot by setting deleted_at timestamp
	// ENT hook handles Keycloak resource cleanup automatically
	_, err := r.client.Bot.UpdateOneID(id).SetDeletedAt(time.Now()).Save(ctx)
	return err == nil, err
}

func (r *mutationResolver) StartBot(ctx context.Context, id uuid.UUID) (*ent.Bot, error) {
	// Load the bot with its runner, exchange, and strategy
	b, err := r.client.Bot.Query().
		Where(bot.ID(id)).
		WithRunner().
		WithExchange().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Check billing - ensure org is not suspended
	if err := billing.EnsureSufficientCredits(ctx, r.client, b.OwnerID); err != nil {
		return nil, err
	}

	// Check feature gating - ensure subscription includes live trading
	if err := billing.HasFeature(ctx, r.client, b.OwnerID, "live_trading"); err != nil {
		return nil, err
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// If bot is in Error status, delete all resources and recreate
	// This ensures we get a fresh container with updated configs
	if b.Status == enum.BotStatusError {
		log.Printf("Bot %s is in Error status, cleaning up resources before recreation", b.ID.String())
		if err := rt.DeleteBot(ctx, b.ID.String()); err != nil {
			// Log but don't fail - resources might already be gone
			log.Printf("Warning: cleanup of failed bot %s returned error (may be ok): %v", b.ID.String(), err)
		}
		// Clear error message
		b, err = r.client.Bot.UpdateOneID(b.ID).
			ClearErrorMessage().
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to clear error message: %w", err)
		}
		// Reload with edges
		b, err = r.client.Bot.Query().
			Where(bot.ID(b.ID)).
			WithRunner().
			WithExchange().
			WithStrategy().
			Only(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to reload bot: %w", err)
		}
	}

	// Check if container exists by getting status
	_, statusErr := rt.GetBotStatus(ctx, b.ID.String())
	containerExists := statusErr == nil

	if !containerExists {
		// Regenerate secure_config on every start for fresh credentials
		secureConfig, err := bot1.GenerateSecureConfig()
		if err != nil {
			return nil, fmt.Errorf("failed to generate secure config: %w", err)
		}

		// Update bot with new secure_config
		_, err = r.client.Bot.UpdateOneID(b.ID).
			SetSecureConfig(secureConfig).
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to update bot secure config: %w", err)
		}

		// Reload bot with edges since Update().Save() doesn't include them
		b, err = r.client.Bot.Query().
			Where(bot.ID(b.ID)).
			WithRunner().
			WithExchange().
			WithStrategy().
			Only(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to reload bot with edges: %w", err)
		}

		// Build BotSpec from bot data (now with fresh secure_config)
		spec, err := buildBotSpec(b)
		if err != nil {
			return nil, fmt.Errorf("failed to build bot spec: %w", err)
		}

		// Generate presigned URL for S3 data download
		presignedURL, err := getPresignedDataURL(ctx, botRunner)
		if err != nil {
			return nil, fmt.Errorf("failed to get presigned URL: %w", err)
		}
		spec.DataDownloadURL = presignedURL

		// Create the container (name derived from bot ID)
		if err := rt.CreateBot(ctx, *spec); err != nil {
			// Update bot status to error
			r.client.Bot.UpdateOneID(b.ID).
				SetStatus(enum.BotStatusError).
				SetErrorMessage(fmt.Sprintf("Failed to create container: %v", err)).
				Save(ctx)
			return nil, fmt.Errorf("failed to create bot container: %w", err)
		}

		// Clear any error message after successful creation
		b, err = r.client.Bot.UpdateOneID(b.ID).
			ClearErrorMessage().
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to update bot: %w", err)
		}
	}

	// Start the bot in the runtime (using bot ID)
	if err := rt.StartBot(ctx, b.ID.String()); err != nil {
		// If container not found, mark as error and suggest restart
		if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "No such container") {
			r.client.Bot.UpdateOneID(id).
				SetStatus(enum.BotStatusError).
				SetErrorMessage("Container not found - try starting again").
				Save(ctx)
			return nil, fmt.Errorf("container was deleted manually - please try starting again")
		}
		return nil, fmt.Errorf("failed to start bot in runner: %w", err)
	}

	// Update bot status
	b, err = r.client.Bot.UpdateOneID(id).
		SetStatus(enum.BotStatusRunning).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot status: %w", err)
	}

	return b, nil
}

func (r *mutationResolver) StopBot(ctx context.Context, id uuid.UUID) (*ent.Bot, error) {
	// Load the bot with its runner configuration
	b, err := r.client.Bot.Query().
		Where(bot.ID(id)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Stop the bot in the runtime using bot ID
	if err := rt.StopBot(ctx, b.ID.String()); err != nil {
		// If container not found, just update status - it was manually deleted
		if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "No such container") {
			b, err = r.client.Bot.UpdateOneID(id).
				SetStatus(enum.BotStatusStopped).
				Save(ctx)
			if err != nil {
				return nil, fmt.Errorf("failed to update bot status: %w", err)
			}
			return b, nil
		}
		return nil, fmt.Errorf("failed to stop bot in runner: %w", err)
	}

	// Delete all bot resources to ensure fresh configs on next start
	// This enables config reload when bot is updated and restarted
	if err := rt.DeleteBot(ctx, id.String()); err != nil {
		// Log but don't fail - container is stopped, deletion is best-effort
		log.Printf("Warning: failed to delete stopped bot resources %s: %v", id.String(), err)
	}

	// Update bot status
	b, err = r.client.Bot.UpdateOneID(id).
		SetStatus(enum.BotStatusStopped).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update bot status: %w", err)
	}

	return b, nil
}

func (r *mutationResolver) RestartBot(ctx context.Context, id uuid.UUID) (*ent.Bot, error) {
	// RestartBot performs a full stop + start cycle to ensure config files are reloaded
	// This is important when bot config, strategy, or exchange has been updated

	// Step 1: Stop the bot (this also deletes container and clears containerID)
	_, err := r.StopBot(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to stop bot during restart: %w", err)
	}

	// Step 2: Start the bot (this creates a fresh container with current configs)
	return r.StartBot(ctx, id)
}

func (r *mutationResolver) CreateBotRunner(ctx context.Context, input ent.CreateBotRunnerInput) (*ent.BotRunner, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user context not found: %w", err)
	}

	// Check billing - ensure org is not suspended
	if err := billing.EnsureSufficientCredits(ctx, r.client, input.OwnerID); err != nil {
		return nil, err
	}

	// Create bot runner - ENT hook handles Keycloak resource sync automatically
	// OwnerID comes from the input and represents the selected group/organization
	return r.client.BotRunner.Create().SetInput(input).Save(ctx)
}

func (r *mutationResolver) UpdateBotRunner(ctx context.Context, id uuid.UUID, input ent.UpdateBotRunnerInput) (*ent.BotRunner, error) {
	return r.client.BotRunner.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteBotRunner(ctx context.Context, id uuid.UUID) (bool, error) {
	// Soft-delete bot runner by setting deleted_at timestamp
	// ENT hook handles Keycloak resource cleanup automatically
	_, err := r.client.BotRunner.UpdateOneID(id).SetDeletedAt(time.Now()).Save(ctx)
	return err == nil, err
}

func (r *mutationResolver) RefreshRunnerData(ctx context.Context, id uuid.UUID) (*ent.BotRunner, error) {
	// Load the runner
	runner, err := r.client.BotRunner.Get(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to load runner: %w", err)
	}

	// Check if already downloading
	if runner.DataDownloadStatus == enum.DataDownloadStatusDownloading {
		return nil, fmt.Errorf("data download already in progress for runner %s", runner.Name)
	}

	// Update status to downloading and clear any previous errors
	startedAt := time.Now()
	runner, err = r.client.BotRunner.UpdateOneID(id).
		SetDataDownloadStatus(enum.DataDownloadStatusDownloading).
		SetDataDownloadStartedAt(startedAt).
		SetDataDownloadProgress(map[string]interface{}{
			"pairs_completed":  0,
			"pairs_total":      0,
			"current_pair":     "",
			"percent_complete": 0.0,
		}).
		ClearDataErrorMessage().
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update runner status: %w", err)
	}

	// Trigger download in background goroutine
	go func() {
		downloadCtx, cancel := context.WithTimeout(context.Background(), monitor.DefaultDataDownloadTimeout)
		defer cancel()

		if err := monitor.DownloadRunnerData(downloadCtx, r.client, runner); err != nil {
			log.Printf("Runner %s: data download failed: %v", runner.Name, err)

			// Update status to failed
			r.client.BotRunner.UpdateOne(runner).
				SetDataDownloadStatus(enum.DataDownloadStatusFailed).
				SetDataIsReady(false).
				SetDataErrorMessage(err.Error()).
				ClearDataDownloadStartedAt().
				Save(context.Background())
		} else {
			log.Printf("Runner %s: data download completed successfully", runner.Name)

			// Update status to completed
			now := time.Now()
			r.client.BotRunner.UpdateOne(runner).
				SetDataDownloadStatus(enum.DataDownloadStatusCompleted).
				SetDataIsReady(true).
				SetDataLastUpdated(now).
				ClearDataErrorMessage().
				ClearDataDownloadProgress().
				ClearDataDownloadStartedAt().
				Save(context.Background())
		}
	}()

	return runner, nil
}

func (r *mutationResolver) TestRunnerConnection(ctx context.Context, typeArg enum.RunnerType, config model.RunnerConfigInput) (*model.ConnectionTestResult, error) {
	// Convert config input to map format
	configMap, err := convertRunnerConfigInput(config)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Invalid configuration: %v", err),
		}, nil
	}

	// Create runner using factory
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, typeArg, configMap)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to create runner client: %v", err),
		}, nil
	}
	defer rt.Close()

	// For Docker runners, try to ping and get version
	// Ping with timeout
	pingCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	// Use GetBotStatus as a connection test
	// This should return an error if connection fails
	_, err = rt.ListBots(pingCtx)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to connect to runner: %v", err),
		}, nil
	}

	return &model.ConnectionTestResult{
		Success: true,
		Message: fmt.Sprintf("Successfully connected to %s runner", typeArg),
	}, nil
}

func (r *mutationResolver) TestS3Connection(ctx context.Context, config model.S3ConfigInput) (*model.ConnectionTestResult, error) {
	// Convert GraphQL input to S3 config map
	s3ConfigMap := map[string]interface{}{
		"endpoint":        config.Endpoint,
		"bucket":          config.Bucket,
		"accessKeyId":     config.AccessKeyID,
		"secretAccessKey": config.SecretAccessKey,
	}

	// Apply optional fields with defaults
	if config.Region != nil {
		s3ConfigMap["region"] = *config.Region
	}
	if config.ForcePathStyle != nil {
		s3ConfigMap["forcePathStyle"] = *config.ForcePathStyle
	}
	if config.UseSsl != nil {
		s3ConfigMap["useSSL"] = *config.UseSsl
	}

	// Create S3 client
	client, err := s3.NewClientFromMap(s3ConfigMap)
	if err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to create S3 client: %v", err),
		}, nil
	}

	// Test connection by checking bucket existence
	if err := client.TestConnection(ctx); err != nil {
		return &model.ConnectionTestResult{
			Success: false,
			Message: fmt.Sprintf("S3 connection failed: %v", err),
		}, nil
	}

	return &model.ConnectionTestResult{
		Success: true,
		Message: fmt.Sprintf("Successfully connected to S3 bucket: %s", config.Bucket),
	}, nil
}

func (r *mutationResolver) RunBacktest(ctx context.Context, input ent.CreateBacktestInput) (*ent.Backtest, error) {
	var result *ent.Backtest

	// Use transaction to ensure atomicity - entity creation and validation both succeed or both fail
	err := WithTx(ctx, r.client, func(tx *ent.Tx) error {
		strategyID := input.StrategyID

		// Load strategy with backtest relationship to check if it already has one
		existingStrategy, err := tx.Strategy.Query().
			Where(strategy.ID(strategyID)).
			WithBacktest().
			Only(ctx)

		if err != nil {
			return fmt.Errorf("failed to load strategy: %w", err)
		}

		// Check billing - ensure org is not suspended
		if err := billing.EnsureSufficientCredits(ctx, r.client, existingStrategy.OwnerID); err != nil {
			return err
		}

		// Check feature gating - ensure subscription includes backtesting
		if err := billing.HasFeature(ctx, r.client, existingStrategy.OwnerID, "backtesting"); err != nil {
			return err
		}

		// If strategy already has a backtest, automatically create a new version
		if existingStrategy.Edges.Backtest != nil {
			log.Printf("Strategy %s (v%d) already has a backtest, creating new version for backtest",
				existingStrategy.Name, existingStrategy.VersionNumber)

			// Create new strategy version - ENT hook handles Keycloak resource sync automatically
			newVersion, err := createStrategyVersionDB(ctx, tx, existingStrategy)
			if err != nil {
				return fmt.Errorf("failed to create new strategy version: %w", err)
			}

			// Use the new strategy version for this backtest
			strategyID = newVersion.ID
			log.Printf("Created strategy version %d (ID: %s) for backtest",
				newVersion.VersionNumber, newVersion.ID)
		}

		// Validate date range if provided
		var startDate, endDate time.Time
		if input.StartDate != nil {
			startDate = *input.StartDate
		}
		if input.EndDate != nil {
			endDate = *input.EndDate
		}
		if err := backtest1.ValidateDateRange(startDate, endDate); err != nil {
			return fmt.Errorf("invalid date range: %w", err)
		}

		// Create backtest entity with the (possibly new) strategy ID
		btCreate := tx.Backtest.Create().
			SetStrategyID(strategyID).
			SetRunnerID(input.RunnerID).
			SetNillableStartDate(input.StartDate).
			SetNillableEndDate(input.EndDate).
			SetStatus(enum.TaskStatusPending)

		// Validate and set config if provided (contains exchange selection and other backtest-specific overrides)
		if input.Config != nil {
			if err := backtest1.ValidateBacktestConfig(input.Config); err != nil {
				return fmt.Errorf("invalid backtest config: %w", err)
			}
			btCreate = btCreate.SetConfig(input.Config)
		}

		bt, err := btCreate.Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create backtest: %w", err)
		}

		// Load backtest with edges for validation
		bt, err = tx.Backtest.Query().
			Where(backtest.ID(bt.ID)).
			WithRunner().
			WithStrategy().
			Only(ctx)
		if err != nil {
			return fmt.Errorf("failed to reload backtest with edges: %w", err)
		}

		// Validate by building the backtest spec
		// This will fail with "pairs not found in strategy config" if validation fails
		// If this fails, the entire transaction rolls back and no backtest entity is created
		_, err = backtest1.BuildSpec(bt)
		if err != nil {
			return fmt.Errorf("failed to build backtest spec: %w", err)
		}

		result = bt
		return nil
	})

	if err != nil {
		return nil, err
	}

	// After transaction commits successfully, run the backtest
	// We need to reload with edges since the transaction result is detached
	result, err = r.client.Backtest.Query().
		Where(backtest.ID(result.ID)).
		WithRunner().
		WithStrategy().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to reload backtest for execution: %w", err)
	}

	return r.runBacktestHelper(ctx, result)
}

func (r *mutationResolver) StopBacktest(ctx context.Context, id uuid.UUID) (*ent.Backtest, error) {
	// Load backtest with runner
	bt, err := r.client.Backtest.Query().
		Where(backtest.ID(id)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load backtest: %w", err)
	}

	// Only allow stopping running backtests
	if bt.Status != enum.TaskStatusRunning {
		return nil, fmt.Errorf("backtest is not running (status: %s)", bt.Status)
	}

	// Get the runner
	btRunner := bt.Edges.Runner
	if btRunner == nil {
		return nil, fmt.Errorf("backtest has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	backtestRunner, err := factory.CreateBacktestRunner(ctx, btRunner.Type, btRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create backtest runner client: %w", err)
	}
	defer func() {
		_ = backtestRunner.Close()
	}()

	// Stop the backtest container
	if err := backtestRunner.StopBacktest(ctx, id.String()); err != nil {
		return nil, fmt.Errorf("failed to stop backtest: %w", err)
	}

	// Update backtest status to cancelled
	bt, err = bt.Update().
		SetStatus(enum.TaskStatusCancelled).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update backtest status: %w", err)
	}

	return bt, nil
}

func (r *mutationResolver) DeleteBacktest(ctx context.Context, id uuid.UUID) (bool, error) {
	// Soft-delete backtest by setting deleted_at timestamp
	_, err := r.client.Backtest.UpdateOneID(id).SetDeletedAt(time.Now()).Save(ctx)
	return err == nil, err
}

func (r *mutationResolver) CreateTrade(ctx context.Context, input ent.CreateTradeInput) (*ent.Trade, error) {
	return r.client.Trade.Create().SetInput(input).Save(ctx)
}

func (r *mutationResolver) UpdateTrade(ctx context.Context, id uuid.UUID, input ent.UpdateTradeInput) (*ent.Trade, error) {
	return r.client.Trade.UpdateOneID(id).SetInput(input).Save(ctx)
}

func (r *mutationResolver) DeleteTrade(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.client.Trade.DeleteOneID(id).Exec(ctx)
	return err == nil, err
}

func (r *mutationResolver) SetStrategyVisibility(ctx context.Context, id uuid.UUID, public bool) (*ent.Strategy, error) {
	return UpdateStrategyVisibility(ctx, r.client, r.umaClient, id.String(), public)
}

func (r *mutationResolver) SetBotVisibility(ctx context.Context, id uuid.UUID, public bool) (*ent.Bot, error) {
	return UpdateBotVisibility(ctx, r.client, r.umaClient, id.String(), public)
}

func (r *mutationResolver) SetRunnerVisibility(ctx context.Context, id uuid.UUID, public bool) (*ent.BotRunner, error) {
	return UpdateBotRunnerVisibility(ctx, r.client, r.umaClient, id.String(), public)
}

func (r *mutationResolver) GetFreqtradeToken(ctx context.Context, botID uuid.UUID) (*model.FreqtradeToken, error) {
	// Load the bot with its runner configuration
	b, err := r.client.Bot.Query().
		Where(bot.ID(botID)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client to get bot status (for API URL)
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Get bot status from runner using bot ID
	status, err := rt.GetBotStatus(ctx, b.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get bot status (is the bot running?): %w", err)
	}

	// Verify bot is running and healthy
	if status.Status != enum.BotStatusRunning {
		return nil, fmt.Errorf("bot is not running (status: %s)", status.Status)
	}

	// Extract username and password from secure_config
	secureConfig := b.SecureConfig
	if secureConfig == nil {
		return nil, fmt.Errorf("bot has no secure_config")
	}

	apiServer, ok := secureConfig["api_server"].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("secure_config missing api_server")
	}

	username, ok := apiServer["username"].(string)
	if !ok || username == "" {
		return nil, fmt.Errorf("secure_config missing api_server.username")
	}

	password, ok := apiServer["password"].(string)
	if !ok || password == "" {
		return nil, fmt.Errorf("secure_config missing api_server.password")
	}

	// Get the direct API URL from the runtime
	// Each runtime (Docker, Kubernetes) handles this differently
	directAPIURL, err := rt.GetBotAPIURL(ctx, b.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get bot API URL: %w", err)
	}

	// Create Freqtrade client and login using direct URL
	ftClient := freqtrade.NewBotClient(directAPIURL, username, password)
	tokens, err := ftClient.Login(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to login to bot API: %w", err)
	}

	// Return the gateway proxy URL for frontend use
	// Frontend accesses bot via /gateway/v1/bot/{botId}/* which proxies to the bot
	proxyAPIURL := fmt.Sprintf("/gateway/v1/bot/%s", botID.String())

	return &model.FreqtradeToken{
		APIURL:       proxyAPIURL,
		Username:     username,
		AccessToken:  tokens.GetAccessToken(),
		RefreshToken: tokens.GetRefreshToken(),
	}, nil
}

func (r *mutationResolver) CreateAlertRule(ctx context.Context, input ent.CreateAlertRuleInput) (*ent.AlertRule, error) {
	alertSvc := alert.GetServiceFromContext(ctx)
	if alertSvc == nil {
		return nil, fmt.Errorf("alert service not available")
	}

	// Check billing - ensure org is not suspended
	if err := billing.EnsureSufficientCredits(ctx, r.client, input.OwnerID); err != nil {
		return nil, err
	}

	return alertSvc.CreateRule(ctx, input)
}

func (r *mutationResolver) UpdateAlertRule(ctx context.Context, id uuid.UUID, input ent.UpdateAlertRuleInput) (*ent.AlertRule, error) {
	alertSvc := alert.GetServiceFromContext(ctx)
	if alertSvc == nil {
		return nil, fmt.Errorf("alert service not available")
	}

	return alertSvc.UpdateRule(ctx, id, input)
}

func (r *mutationResolver) ToggleAlertRule(ctx context.Context, id uuid.UUID, enabled bool) (*ent.AlertRule, error) {
	alertSvc := alert.GetServiceFromContext(ctx)
	if alertSvc == nil {
		return nil, fmt.Errorf("alert service not available")
	}

	return alertSvc.ToggleRule(ctx, id, enabled)
}

func (r *mutationResolver) DeleteAlertRule(ctx context.Context, id uuid.UUID) (bool, error) {
	alertSvc := alert.GetServiceFromContext(ctx)
	if alertSvc == nil {
		return false, fmt.Errorf("alert service not available")
	}

	if err := alertSvc.DeleteRule(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

func (r *mutationResolver) TestAlertRule(ctx context.Context, id uuid.UUID) (bool, error) {
	alertMgr := alert.GetManagerFromContext(ctx)
	if alertMgr == nil {
		return false, fmt.Errorf("alert system not configured")
	}

	if err := alertMgr.TestRule(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

func (r *mutationResolver) MarkAlertEventAsRead(ctx context.Context, id uuid.UUID, ownerID string) (*ent.AlertEvent, error) {
	// Authorization is handled by @hasScope directive on ownerID
	// Verify the alert belongs to the specified organization
	event, err := r.client.AlertEvent.Get(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("alert event not found: %w", err)
	}

	if event.OwnerID != ownerID {
		return nil, fmt.Errorf("alert event does not belong to this organization")
	}

	// Update read_at timestamp
	now := time.Now()
	return r.client.AlertEvent.UpdateOneID(id).
		SetReadAt(now).
		Save(ctx)
}

func (r *mutationResolver) MarkAllAlertEventsAsRead(ctx context.Context, ownerID string) (int, error) {
	// Authentication is handled by @isAuthenticated directive
	// Update all unread events for this owner
	now := time.Now()
	count, err := r.client.AlertEvent.Update().
		Where(
			alertevent.OwnerID(ownerID),
			alertevent.ReadAtIsNil(),
		).
		SetReadAt(now).
		Save(ctx)
	if err != nil {
		return 0, fmt.Errorf("failed to mark events as read: %w", err)
	}

	return count, nil
}

func (r *mutationResolver) CreateOrganization(ctx context.Context, input model.CreateOrganizationInput) (*model.CreateOrganizationResponse, error) {
	// Get user context (already authenticated via @isAuthenticated directive)
	userCtx, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Get alias from input (optional - will be auto-generated from title if empty)
	alias := ""
	if input.Alias != nil {
		alias = *input.Alias
	}

	// Delegate to organization domain package (DDD compliance)
	response, err := organization.Create(ctx, organization.CreateRequest{
		Title:  input.Title,
		Alias:  alias,
		UserID: userCtx.UserID,
	})
	if err != nil {
		return nil, err
	}

	// Initialize billing: create zero-balance record and assign starter plan if first org
	if r.Resolver != nil && r.client != nil {
		if err := billing.EnsureBalanceExists(ctx, r.client, response.Alias); err != nil {
			log.Printf("Failed to create billing balance for org %s: %v", response.Alias, err)
		}

		stripeClient := billing.GetStripeClientFromContext(ctx)
		if stripeClient != nil {
			if err := billing.AssignStarterPlanIfFirstOrg(ctx, r.client, stripeClient, userCtx.UserID, response.Alias, userCtx.Email); err != nil {
				log.Printf("Failed to assign starter plan for org %s: %v", response.Alias, err)
			}
		}
	}

	return &model.CreateOrganizationResponse{
		ID:    response.Alias, // Alias is the unique identifier
		Title: response.Title,
		Alias: response.Alias,
	}, nil
}

func (r *mutationResolver) InviteOrganizationUser(ctx context.Context, organizationID string, input model.InviteUserInput) (*model.OrganizationInvitation, error) {
	// Authorization is handled by @hasScope directive
	// organizationId is validated by the directive to ensure user has invite-user permission

	// Validate email format
	if !EmailRegex.MatchString(input.Email) {
		return nil, fmt.Errorf("invalid email format: %s", input.Email)
	}

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return nil, fmt.Errorf("admin client not available")
	}

	// Build request
	request := keycloak.InvitationRequest{
		Email:    input.Email,
		ClientID: adminClient.GetDashboardClientID(), // Use configured dashboard client for redirect
	}
	if input.FirstName != nil {
		request.FirstName = *input.FirstName
	}
	if input.LastName != nil {
		request.LastName = *input.LastName
	}
	if input.RedirectURL != nil {
		request.RedirectURL = *input.RedirectURL
	}

	// Create invitation via Keycloak tenant API
	response, err := adminClient.CreateInvitation(ctx, organizationID, request)
	if err != nil {
		// Log detailed error internally for debugging
		log.Printf("ERROR: failed to create invitation for email=%s org=%s: %v", input.Email, organizationID, err)

		// Detect common failures and provide user-friendly messages
		errStr := err.Error()
		switch {
		case strings.Contains(errStr, "already invited") || strings.Contains(errStr, "already exists"):
			return nil, fmt.Errorf("this email address has already been invited to the organization")
		case strings.Contains(errStr, "already a member"):
			return nil, fmt.Errorf("this user is already a member of the organization")
		case strings.Contains(errStr, "Invalid email") || strings.Contains(errStr, "invalid email"):
			return nil, fmt.Errorf("invalid email format: please provide a valid email address")
		case strings.Contains(errStr, "Redirect URL") || strings.Contains(errStr, "redirect"):
			return nil, fmt.Errorf("invalid redirect URL: the provided URL is not allowed")
		case strings.Contains(errStr, "not found") || strings.Contains(errStr, "404"):
			return nil, fmt.Errorf("organization not found or you don't have permission to invite users")
		case strings.Contains(errStr, "email") && strings.Contains(errStr, "send"):
			return nil, fmt.Errorf("failed to send invitation email: please verify the email address and try again")
		default:
			// Generic error for unrecognized failures
			return nil, fmt.Errorf("failed to create invitation: the invitation could not be sent. Please try again or contact support if the issue persists")
		}
	}

	// Parse invitation ID
	invitationID, err := uuid.Parse(response.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid invitation ID: %w", err)
	}

	// Convert to GraphQL model
	result := &model.OrganizationInvitation{
		ID:             invitationID,
		Email:          response.Email,
		OrganizationID: organizationID, // Use the input UUID directly
		Status:         response.Status,
		CreatedAt:      time.UnixMilli(response.CreatedAt),
		ExpiresAt:      time.UnixMilli(response.ExpiresAt),
	}

	// Set optional fields
	if response.FirstName != "" {
		result.FirstName = &response.FirstName
	}
	if response.LastName != "" {
		result.LastName = &response.LastName
	}

	return result, nil
}

func (r *mutationResolver) CancelOrganizationInvitation(ctx context.Context, organizationID string, invitationID string) (bool, error) {
	// Authorization is handled by @hasScope directive

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return false, fmt.Errorf("admin client not available")
	}

	// Delete the invitation via Keycloak tenant API
	err := adminClient.DeleteInvitation(ctx, organizationID, invitationID)
	if err != nil {
		log.Printf("ERROR: failed to cancel invitation id=%s org=%s: %v", invitationID, organizationID, err)

		// Detect common failures
		errStr := err.Error()
		switch {
		case strings.Contains(errStr, "not found") || strings.Contains(errStr, "404"):
			return false, fmt.Errorf("invitation not found or already cancelled")
		default:
			return false, fmt.Errorf("failed to cancel invitation: please try again or contact support")
		}
	}

	return true, nil
}

func (r *mutationResolver) ChangeOrganizationUserRole(ctx context.Context, organizationID string, userID string, newRole string) (bool, error) {
	// Get current user from context
	userCtx, err := auth.GetUserContext(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to get user context: %w", err)
	}

	// Prevent users from changing their own role
	if userCtx.UserID == userID {
		return false, fmt.Errorf("you cannot change your own role")
	}

	// Validate role - check for empty or invalid characters
	if newRole == "" {
		return false, fmt.Errorf("role cannot be empty")
	}

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return false, fmt.Errorf("admin client not available")
	}

	// Validate role against available roles for the organization
	availableRoles, err := adminClient.GetAvailableRoles(ctx, organizationID)
	if err != nil {
		return false, fmt.Errorf("failed to fetch available roles: %w", err)
	}

	roleValid := false
	for _, validRole := range availableRoles {
		if validRole == newRole {
			roleValid = true
			break
		}
	}
	if !roleValid {
		return false, fmt.Errorf("invalid role: %s (available roles: %v)", newRole, availableRoles)
	}

	// Change the user's role
	_, err = adminClient.ChangeUserRole(ctx, organizationID, userID, newRole)
	if err != nil {
		// Detect common failures and provide user-friendly messages
		errStr := err.Error()
		switch {
		case strings.Contains(errStr, "not found") || strings.Contains(errStr, "404"):
			return false, fmt.Errorf("user or organization not found")
		case strings.Contains(errStr, "forbidden") || strings.Contains(errStr, "403"):
			return false, fmt.Errorf("you do not have permission to change roles in this organization")
		default:
			return false, fmt.Errorf("failed to change user role: %w", err)
		}
	}

	// Audit log for role changes
	log.Printf("[AUDIT] User %s changed role for user %s to %s in organization %s",
		userCtx.UserID, userID, newRole, organizationID)

	return true, nil
}

func (r *mutationResolver) DeleteOrganization(ctx context.Context, organizationID string) (bool, error) {
	// Authorization is handled by @hasScope directive

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return false, fmt.Errorf("admin client not available")
	}

	// Disable organization (soft delete) via Keycloak admin API
	err := adminClient.DisableOrganization(ctx, organizationID)
	if err != nil {
		log.Printf("ERROR: failed to delete organization %s: %v", organizationID, err)

		// Detect common failures
		errStr := err.Error()
		switch {
		case strings.Contains(errStr, "not found") || strings.Contains(errStr, "404"):
			return false, fmt.Errorf("organization not found")
		default:
			return false, fmt.Errorf("failed to delete organization: please try again or contact support")
		}
	}

	log.Printf("[AUDIT] Organization %s was soft-deleted (disabled)", organizationID)
	return true, nil
}

func (r *mutationResolver) EnableOrganization(ctx context.Context, organizationID string) (bool, error) {
	// Authorization is handled by @hasScope directive

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return false, fmt.Errorf("admin client not available")
	}

	// Re-enable organization via Keycloak admin API
	err := adminClient.EnableOrganization(ctx, organizationID)
	if err != nil {
		log.Printf("ERROR: failed to enable organization %s: %v", organizationID, err)

		// Detect common failures
		errStr := err.Error()
		switch {
		case strings.Contains(errStr, "not found") || strings.Contains(errStr, "404"):
			return false, fmt.Errorf("organization not found")
		case strings.Contains(errStr, "not an organization") || strings.Contains(errStr, "not organization"):
			return false, fmt.Errorf("resource is not an organization")
		default:
			return false, fmt.Errorf("failed to enable organization: please try again or contact support")
		}
	}

	log.Printf("[AUDIT] Organization %s was re-enabled", organizationID)
	return true, nil
}

func (r *mutationResolver) CreateDepositSession(ctx context.Context, ownerID string, amount float64) (string, error) {
	stripeClient := billing.GetStripeClientFromContext(ctx)
	if stripeClient == nil {
		return "", fmt.Errorf("billing not configured")
	}
	userCtx, err := auth.GetUserContext(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to get user context: %w", err)
	}
	frontendURL := resolveFrontendURL(ctx)
	return billing.CreateDepositCheckoutSession(ctx, r.client, stripeClient, ownerID, amount, frontendURL, userCtx.Email)
}

func (r *mutationResolver) CreateSubscriptionSession(ctx context.Context, ownerID string, priceID string) (string, error) {
	stripeClient := billing.GetStripeClientFromContext(ctx)
	if stripeClient == nil {
		return "", fmt.Errorf("billing not configured")
	}
	userCtx, err := auth.GetUserContext(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to get user context: %w", err)
	}
	frontendURL := resolveFrontendURL(ctx)
	return billing.CreateSubscriptionCheckout(ctx, r.client, stripeClient, ownerID, priceID, frontendURL, userCtx.Email)
}

func (r *mutationResolver) ChangeSubscriptionPlan(ctx context.Context, ownerID string, newPriceID string) (*model.SubscriptionInfo, error) {
	stripeClient := billing.GetStripeClientFromContext(ctx)
	if stripeClient == nil {
		return nil, fmt.Errorf("billing not configured")
	}

	updated, err := billing.ChangeSubscriptionPlan(ctx, r.client, stripeClient, ownerID, newPriceID)
	if err != nil {
		return nil, err
	}

	return &model.SubscriptionInfo{
		PlanName:         &updated.PlanName,
		MonthlyDeposit:   updated.MonthlyDeposit,
		Status:           string(updated.Status),
		CurrentPeriodEnd: updated.CurrentPeriodEnd,
		Features:         updated.Features,
	}, nil
}

func (r *mutationResolver) CancelSubscription(ctx context.Context, ownerID string) (*model.SubscriptionInfo, error) {
	stripeClient := billing.GetStripeClientFromContext(ctx)
	if stripeClient == nil {
		return nil, fmt.Errorf("billing not configured")
	}

	updated, err := billing.CancelSubscriptionAtEnd(ctx, r.client, stripeClient, ownerID)
	if err != nil {
		return nil, err
	}

	return &model.SubscriptionInfo{
		PlanName:         &updated.PlanName,
		MonthlyDeposit:   updated.MonthlyDeposit,
		Status:           string(updated.Status),
		CurrentPeriodEnd: updated.CurrentPeriodEnd,
		Features:         updated.Features,
	}, nil
}

func (r *queryResolver) GetBotRunnerStatus(ctx context.Context, id uuid.UUID) (*runner.BotStatus, error) {
	// Load the bot with its runner configuration
	b, err := r.client.Bot.Query().
		Where(bot.ID(id)).
		WithRunner().
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load bot: %w", err)
	}

	// Get the runner
	botRunner := b.Edges.Runner
	if botRunner == nil {
		return nil, fmt.Errorf("bot has no runner configuration")
	}

	// Create runner client
	factory := runner.NewFactory()
	rt, err := factory.Create(ctx, botRunner.Type, botRunner.Config)
	if err != nil {
		return nil, fmt.Errorf("failed to create runner client: %w", err)
	}
	defer rt.Close()

	// Get bot status from runner using bot ID
	status, err := rt.GetBotStatus(ctx, b.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get bot status from runner: %w", err)
	}

	return status, nil
}

// StrategyVersions returns all versions of a strategy by name
// Note: This query does NOT filter by owner - authorization should be handled by UMA/Keycloak
// or by the client passing the appropriate ownerID in the where clause of the main strategies query
func (r *queryResolver) StrategyVersions(ctx context.Context, name string) ([]*ent.Strategy, error) {
	// Verify user is authenticated (required by @isAuthenticated directive)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Get all versions of a strategy by name, ordered by version number
	// No owner filtering here - that's handled at the authorization layer
	return r.client.Strategy.Query().
		Where(strategy.Name(name)).
		Order(ent.Asc(strategy.FieldVersionNumber)).
		All(ctx)
}

// OrganizationUsage returns total usage for an organization over a time range.
func (r *queryResolver) OrganizationUsage(ctx context.Context, ownerID string, start time.Time, end time.Time) (*ent.ResourceUsageAggregation, error) {
	// Verify user is authenticated
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, err
	}

	// Use the calculator to get organization usage
	calc := usage.NewCalculator(r.client)
	summary, err := calc.GetOrganizationUsage(ctx, ownerID, start, end)
	if err != nil {
		return nil, err
	}

	if summary == nil {
		return nil, nil
	}

	// Convert UsageSummary to ResourceUsageAggregation for GraphQL response
	// Note: This is a synthetic aggregation, not stored in the database
	return &ent.ResourceUsageAggregation{
		ResourceType:    summary.ResourceType,
		ResourceID:      summary.ResourceID,
		OwnerID:         summary.OwnerID,
		RunnerID:        summary.RunnerID,
		Granularity:     enum.AggregationGranularityDaily, // Synthetic aggregation
		BucketStart:     summary.PeriodStart,
		BucketEnd:       summary.PeriodEnd,
		CPUCoreSeconds:  summary.CPUCoreSeconds,
		CPUAvgPercent:   summary.CPUAvgPercent,
		CPUMaxPercent:   summary.CPUMaxPercent,
		MemoryGBSeconds: summary.MemoryGBSeconds,
		MemoryAvgBytes:  summary.MemoryAvgBytes,
		MemoryMaxBytes:  summary.MemoryMaxBytes,
		NetworkRxBytes:  summary.NetworkRxBytes,
		NetworkTxBytes:  summary.NetworkTxBytes,
		BlockReadBytes:  summary.BlockReadBytes,
		BlockWriteBytes: summary.BlockWriteBytes,
		SampleCount:     summary.SampleCount,
	}, nil
}

// EstimatedCost calculates the estimated cost for usage over a time range.
func (r *queryResolver) EstimatedCost(ctx context.Context, ownerID string, start time.Time, end time.Time) (*model.UsageCost, error) {
	// Verify user is authenticated
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, err
	}

	calc := usage.NewCalculator(r.client)

	// Get usage breakdown by resource to calculate costs per-runner
	breakdown, err := calc.GetUsageBreakdown(ctx, ownerID, start, end)
	if err != nil {
		return nil, err
	}

	// Aggregate costs across all resources
	totalCost := &model.UsageCost{Currency: "USD"}

	for _, summary := range breakdown {
		// Get runner rates
		rates, err := calc.GetRunnerRates(ctx, summary.RunnerID)
		if err != nil {
			// Skip if runner not found (may have been deleted)
			continue
		}

		// Calculate cost for this resource
		cost := calc.CalculateCost(&summary, rates)
		if cost != nil {
			totalCost.CPUCost += cost.CPUCost
			totalCost.MemoryCost += cost.MemoryCost
			totalCost.NetworkCost += cost.NetworkCost
			totalCost.StorageCost += cost.StorageCost
			totalCost.TotalCost += cost.TotalCost
		}
	}

	return totalCost, nil
}

// BotUsageHistory returns usage history for a bot over a time range.
// Returns raw aggregation records (not combined) for time-series charting.
func (r *queryResolver) BotUsageHistory(ctx context.Context, botID uuid.UUID, start time.Time, end time.Time) ([]*ent.ResourceUsageAggregation, error) {
	// Verify user is authenticated (directive handles scope check)
	_, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, err
	}

	// Convert times to local timezone to match how data is stored in SQLite
	localStart := start.Local()
	localEnd := end.Local()

	// Query aggregations for the bot within the time range
	// Return raw records sorted by bucket start for time-series charting
	aggs, err := r.client.ResourceUsageAggregation.Query().
		Where(
			resourceusageaggregation.ResourceID(botID),
			resourceusageaggregation.ResourceTypeEQ(enum.ResourceTypeBot),
			resourceusageaggregation.BucketStartGTE(localStart),
			resourceusageaggregation.BucketStartLT(localEnd),
		).
		Order(ent.Asc(resourceusageaggregation.FieldBucketStart)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query bot usage history: %w", err)
	}

	return aggs, nil
}

func (r *queryResolver) AlertTypesForResource(ctx context.Context, resourceType enum.AlertResourceType, resourceID *uuid.UUID) ([]*model.AlertTypeInfo, error) {
	// Get alert types from the alert package
	var resourceIDStr *string
	if resourceID != nil {
		s := resourceID.String()
		resourceIDStr = &s
	}

	alertTypes := alert.GetAlertTypesForResource(resourceType, resourceIDStr)

	// Convert to GraphQL model types
	result := make([]*model.AlertTypeInfo, 0, len(alertTypes))
	for _, at := range alertTypes {
		conditionFields := make([]*model.ConditionField, 0, len(at.ConditionFields))
		for _, cf := range at.ConditionFields {
			options := make([]*model.SelectOption, 0, len(cf.Options))
			for _, opt := range cf.Options {
				options = append(options, &model.SelectOption{
					Value: opt.Value,
					Label: opt.Label,
				})
			}

			var unit *string
			if cf.Unit != "" {
				unit = &cf.Unit
			}

			conditionFields = append(conditionFields, &model.ConditionField{
				Name:        cf.Name,
				Label:       cf.Label,
				Type:        model.ConditionFieldType(cf.Type),
				Required:    cf.Required,
				Description: cf.Description,
				Min:         cf.Min,
				Max:         cf.Max,
				Default:     cf.Default,
				Unit:        unit,
				Options:     options,
			})
		}

		result = append(result, &model.AlertTypeInfo{
			Type:            at.Type,
			Label:           at.Label,
			Description:     at.Description,
			DefaultSeverity: at.DefaultSeverity,
			ConditionFields: conditionFields,
		})
	}

	return result, nil
}

func (r *queryResolver) CheckPermissions(ctx context.Context, permissions []*model.PermissionCheckInput) ([]*model.PermissionCheckResult, error) {
	// Get user context
	userCtx, err := auth.GetUserContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Get UMA client from context
	umaClient := GetUMAClientFromContext(ctx)
	if umaClient == nil {
		return nil, fmt.Errorf("UMA client not available")
	}

	results := make([]*model.PermissionCheckResult, len(permissions))

	for i, perm := range permissions {
		resourceID := perm.ResourceID // Now a string (organization alias or entity UUID)
		scope := perm.Scope

		// Check permission
		granted, err := umaClient.CheckPermission(ctx, userCtx.RawToken, resourceID, scope)

		// If permission denied and might be due to invalid scope, trigger self-healing
		if authz.ShouldTriggerSelfHealing(granted, err) {
			// Try to sync scopes for this resource
			if syncErr := SyncResourceScopes(ctx, r.client, resourceID); syncErr != nil {
				log.Printf("Self-healing failed for resource %s: %v", resourceID, syncErr)
			} else {
				// Re-check permission after sync
				granted, err = umaClient.CheckPermission(ctx, userCtx.RawToken, resourceID, scope)
				if err != nil {
					log.Printf("Permission re-check failed for %s#%s: %v", resourceID, scope, err)
				}
			}
		}

		// Log non-invalid-scope errors but don't fail the whole request
		if err != nil && !authz.IsInvalidScopeError(err) {
			log.Printf("Permission check error for %s#%s: %v", resourceID, scope, err)
		}

		results[i] = &model.PermissionCheckResult{
			ResourceID: perm.ResourceID,
			Scope:      scope,
			Granted:    granted,
		}
	}

	return results, nil
}

func (r *queryResolver) OrganizationUsers(ctx context.Context, organizationID string) ([]*model.OrganizationUser, error) {
	// Authorization is handled by @hasScope directive
	// organizationId is validated by the directive to ensure user has view-users permission

	// Create admin client
	adminClient := keycloak.NewAdminClient(r.auth.GetConfig())

	// Get organization users from Keycloak
	// organizationID is the group UUID in Keycloak
	kcUsers, err := adminClient.GetGroupUsers(ctx, organizationID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch organization users: %w", err)
	}

	// Convert keycloak.OrganizationUser to model.OrganizationUser
	users := make([]*model.OrganizationUser, len(kcUsers))
	for i, kcUser := range kcUsers {
		// Parse Keycloak user ID (UUID string) to uuid.UUID
		userID, err := uuid.Parse(kcUser.ID)
		if err != nil {
			return nil, fmt.Errorf("invalid user ID format for user %s: %w", kcUser.Username, err)
		}

		users[i] = &model.OrganizationUser{
			ID:            userID,
			Username:      kcUser.Username,
			Email:         &kcUser.Email,
			EmailVerified: kcUser.EmailVerified,
			FirstName:     &kcUser.FirstName,
			LastName:      &kcUser.LastName,
			Enabled:       kcUser.Enabled,
			CreatedAt:     time.UnixMilli(kcUser.CreatedAt),
		}
	}

	return users, nil
}

func (r *queryResolver) OrganizationGroupTree(ctx context.Context, organizationID string) (*model.GroupNode, error) {
	// Authorization is handled by @hasScope directive
	// organizationId is validated by the directive to ensure user has view-users permission

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return nil, fmt.Errorf("admin client not available")
	}

	// Delegate to organization package (business logic layer)
	return organization.GetGroupTree(ctx, adminClient, organizationID)
}

func (r *queryResolver) GroupMembers(ctx context.Context, organizationID string, groupID string) ([]*model.OrganizationUser, error) {
	// Authorization is handled by @hasScope directive on organizationId
	// organizationId is validated by the directive to ensure user has view-users permission

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return nil, fmt.Errorf("admin client not available")
	}

	// Delegate to organization package (business logic layer)
	return organization.GetGroupMembers(ctx, adminClient, groupID)
}

func (r *queryResolver) ResourceGroups(ctx context.Context, organizationID string, where *model.ResourceGroupWhereInput, orderBy *model.ResourceGroupOrder, first *int, offset *int) (*model.ResourceGroupConnection, error) {
	// Authorization is handled by @hasScope directive
	// organizationId is validated by the directive to ensure user has view-users permission

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return nil, fmt.Errorf("admin client not available")
	}

	// Set defaults for pagination
	pageSize := 20
	pageOffset := 0
	if first != nil && *first > 0 {
		pageSize = *first
	}
	if offset != nil && *offset > 0 {
		pageOffset = *offset
	}

	// Call organization package (thin wrapper to Keycloak extension)
	return organization.GetResourceGroups(ctx, adminClient, organizationID, where, orderBy, pageSize, pageOffset)
}

func (r *queryResolver) ResourceGroupMembers(ctx context.Context, organizationID string, resourceGroupID string, where *model.ResourceGroupMemberWhereInput, orderBy *model.ResourceGroupMemberOrder, first *int, offset *int) (*model.ResourceGroupMemberConnection, error) {
	// Authorization is handled by @hasScope directive
	// organizationId is validated by the directive to ensure user has view-users permission

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return nil, fmt.Errorf("admin client not available")
	}

	// Set defaults for pagination
	pageSize := 50
	pageOffset := 0
	if first != nil && *first > 0 {
		pageSize = *first
	}
	if offset != nil && *offset > 0 {
		pageOffset = *offset
	}

	// Call organization package (thin wrapper to Keycloak extension)
	return organization.GetResourceGroupMembers(ctx, adminClient, organizationID, resourceGroupID, where, orderBy, pageSize, pageOffset)
}

func (r *queryResolver) OrganizationInvitations(ctx context.Context, organizationID string, first *int, offset *int) (*model.OrganizationInvitationConnection, error) {
	// Authorization is handled by @hasScope directive

	// Get admin client from context
	adminClient := GetAdminClientFromContext(ctx)
	if adminClient == nil {
		return nil, fmt.Errorf("admin client not available")
	}

	// Set defaults for pagination
	pageSize := 20
	pageOffset := 0
	if first != nil && *first > 0 {
		pageSize = *first
	}
	if offset != nil && *offset > 0 {
		pageOffset = *offset
	}

	// List invitations via Keycloak tenant API
	response, err := adminClient.ListInvitations(ctx, organizationID, pageOffset, pageSize)
	if err != nil {
		log.Printf("ERROR: failed to list invitations for org=%s: %v", organizationID, err)
		return nil, fmt.Errorf("failed to list invitations: please try again or contact support")
	}

	// Convert response to GraphQL model
	invitations := make([]*model.OrganizationInvitation, 0, len(response.Invitations))
	for _, inv := range response.Invitations {
		invID, err := uuid.Parse(inv.ID)
		if err != nil {
			log.Printf("WARN: invalid invitation ID %s, skipping", inv.ID)
			continue
		}

		invitation := &model.OrganizationInvitation{
			ID:             invID,
			Email:          inv.Email,
			OrganizationID: organizationID,
			Status:         inv.Status,
			CreatedAt:      time.UnixMilli(inv.CreatedAt),
			ExpiresAt:      time.UnixMilli(inv.ExpiresAt),
		}

		if inv.FirstName != "" {
			invitation.FirstName = &inv.FirstName
		}
		if inv.LastName != "" {
			invitation.LastName = &inv.LastName
		}

		invitations = append(invitations, invitation)
	}

	return &model.OrganizationInvitationConnection{
		Invitations: invitations,
		TotalCount:  response.Total,
	}, nil
}

func (r *queryResolver) AvailablePlans(ctx context.Context) ([]*model.PlanInfo, error) {
	stripeClient := billing.GetStripeClientFromContext(ctx)
	if stripeClient == nil {
		return nil, fmt.Errorf("billing not configured")
	}

	plans, err := stripeClient.ListAvailablePlans()
	if err != nil {
		return nil, fmt.Errorf("failed to list available plans: %w", err)
	}

	result := make([]*model.PlanInfo, len(plans))
	for i, p := range plans {
		result[i] = &model.PlanInfo{
			PriceID:        p.PriceID,
			ProductID:      p.ProductID,
			DisplayName:    p.DisplayName,
			Description:    p.Description,
			PriceAmount:    p.PriceAmount,
			MonthlyDeposit: p.MonthlyDeposit,
			Features:       p.Features,
			DisplayOrder:   p.DisplayOrder,
		}
	}
	return result, nil
}

func (r *queryResolver) CreditBalance(ctx context.Context, ownerID string) (*ent.CreditBalance, error) {
	bal, err := r.client.CreditBalance.Query().
		Where(creditbalance.OwnerID(ownerID)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			// Return zero balance for orgs created before billing
			return &ent.CreditBalance{Balance: 0, Suspended: false}, nil
		}
		return nil, fmt.Errorf("failed to get credit balance: %w", err)
	}
	return bal, nil
}

func (r *queryResolver) CreditTransactions(ctx context.Context, ownerID string, limit *int, offset *int) ([]*ent.CreditTransaction, error) {
	query := r.client.CreditTransaction.Query().
		Where(credittransaction.OwnerID(ownerID)).
		Order(ent.Desc(credittransaction.FieldCreatedAt))

	if offset != nil && *offset > 0 {
		query = query.Offset(*offset)
	}

	queryLimit := 50 // default
	if limit != nil && *limit > 0 && *limit <= 100 {
		queryLimit = *limit
	}
	query = query.Limit(queryLimit)

	return query.All(ctx)
}

func (r *queryResolver) SubscriptionInfo(ctx context.Context, ownerID string) (*model.SubscriptionInfo, error) {
	sub, err := r.client.StripeSubscription.Query().
		Where(stripesubscription.OwnerID(ownerID)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, nil // No subscription
		}
		return nil, fmt.Errorf("failed to get subscription: %w", err)
	}

	return &model.SubscriptionInfo{
		PlanName:         &sub.PlanName,
		MonthlyDeposit:   sub.MonthlyDeposit,
		Status:           string(sub.Status),
		CurrentPeriodEnd: sub.CurrentPeriodEnd,
		Features:         sub.Features,
	}, nil
}

func (r *queryResolver) PaymentHistory(ctx context.Context, ownerID string, limit *int) ([]*model.StripeInvoice, error) {
	stripeClient := billing.GetStripeClientFromContext(ctx)
	if stripeClient == nil {
		return nil, fmt.Errorf("billing is not configured")
	}

	// Look up the Stripe customer ID from the subscription record
	sub, err := r.client.StripeSubscription.Query().
		Where(stripesubscription.OwnerID(ownerID)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return []*model.StripeInvoice{}, nil
		}
		return nil, fmt.Errorf("failed to get subscription: %w", err)
	}

	invoiceLimit := int64(20)
	if limit != nil && *limit > 0 && *limit <= 100 {
		invoiceLimit = int64(*limit)
	}

	invoices, err := stripeClient.ListInvoices(sub.StripeCustomerID, invoiceLimit)
	if err != nil {
		return nil, fmt.Errorf("failed to list invoices: %w", err)
	}

	result := make([]*model.StripeInvoice, 0, len(invoices))
	for _, inv := range invoices {
		si := &model.StripeInvoice{
			ID:          inv.ID,
			AmountPaid:  float64(inv.AmountPaid) / 100.0,
			Status:      string(inv.Status),
			Created:     time.Unix(inv.Created, 0),
			PeriodStart: time.Unix(inv.PeriodStart, 0),
			PeriodEnd:   time.Unix(inv.PeriodEnd, 0),
		}
		if inv.Number != "" {
			si.Number = &inv.Number
		}
		if inv.HostedInvoiceURL != "" {
			si.HostedInvoiceURL = &inv.HostedInvoiceURL
		}
		if inv.InvoicePDF != "" {
			si.InvoicePDF = &inv.InvoicePDF
		}
		if inv.BillingReason != "" {
			reason := string(inv.BillingReason)
			si.BillingReason = &reason
		}
		result = append(result, si)
	}
	return result, nil
}

func (r *subscriptionResolver) BotStatusChanged(ctx context.Context, botID uuid.UUID) (<-chan *ent.Bot, error) {
	// Authorization is already checked by @hasScope directive on initial subscribe
	if r.pubsub == nil {
		return nil, fmt.Errorf("subscriptions not available: pub/sub not configured")
	}

	topic := pubsub.BotTopic(botID.String())
	eventCh, unsub := r.pubsub.Subscribe(ctx, topic)

	botCh := make(chan *ent.Bot)
	go func() {
		defer func() {
			if r := recover(); r != nil {
				log.Printf("subscription panic recovered in BotStatusChanged: %v", r)
			}
			close(botCh)
			unsub()
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case _, ok := <-eventCh:
				if !ok {
					return
				}
				// Fetch the latest bot state from the database
				bot, err := r.client.Bot.Get(ctx, botID)
				if err != nil {
					if ent.IsNotFound(err) {
						// Bot was deleted, close subscription
						log.Printf("subscription: bot %s was deleted, closing subscription", botID)
						return
					}
					log.Printf("subscription: failed to fetch bot %s: %v", botID, err)
					continue
				}
				select {
				case botCh <- bot:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return botCh, nil
}

func (r *subscriptionResolver) BacktestProgress(ctx context.Context, backtestID uuid.UUID) (<-chan *ent.Backtest, error) {
	// Authorization is already checked by @hasScope directive on initial subscribe
	if r.pubsub == nil {
		return nil, fmt.Errorf("subscriptions not available: pub/sub not configured")
	}

	topic := pubsub.BacktestTopic(backtestID.String())
	eventCh, unsub := r.pubsub.Subscribe(ctx, topic)

	backtestCh := make(chan *ent.Backtest)
	go func() {
		defer func() {
			if r := recover(); r != nil {
				log.Printf("subscription panic recovered in BacktestProgress: %v", r)
			}
			close(backtestCh)
			unsub()
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case _, ok := <-eventCh:
				if !ok {
					return
				}
				// Fetch the latest backtest state from the database
				backtest, err := r.client.Backtest.Get(ctx, backtestID)
				if err != nil {
					if ent.IsNotFound(err) {
						// Backtest was deleted, close subscription
						log.Printf("subscription: backtest %s was deleted, closing subscription", backtestID)
						return
					}
					log.Printf("subscription: failed to fetch backtest %s: %v", backtestID, err)
					continue
				}
				select {
				case backtestCh <- backtest:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return backtestCh, nil
}

func (r *subscriptionResolver) AlertEventCreated(ctx context.Context, ownerID string) (<-chan *ent.AlertEvent, error) {
	// Authorization is already checked by @hasScope directive on initial subscribe
	if r.pubsub == nil {
		return nil, fmt.Errorf("subscriptions not available: pub/sub not configured")
	}

	topic := pubsub.AlertTopic(ownerID)
	eventCh, unsub := r.pubsub.Subscribe(ctx, topic)

	alertCh := make(chan *ent.AlertEvent)
	go func() {
		defer func() {
			if r := recover(); r != nil {
				log.Printf("subscription panic recovered in AlertEventCreated: %v", r)
			}
			close(alertCh)
			unsub()
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case eventData, ok := <-eventCh:
				if !ok {
					return
				}
				// Parse the event to get the alert ID
				var event pubsub.AlertEvent
				if err := json.Unmarshal(eventData, &event); err != nil {
					log.Printf("subscription: failed to parse alert event: %v", err)
					continue
				}
				// Fetch the alert from the database
				alertID, err := uuid.Parse(event.AlertID)
				if err != nil {
					log.Printf("subscription: invalid alert ID %s: %v", event.AlertID, err)
					continue
				}
				alertEvent, err := r.client.AlertEvent.Get(ctx, alertID)
				if err != nil {
					if ent.IsNotFound(err) {
						// Alert was deleted, skip (don't close subscription - other alerts may come)
						log.Printf("subscription: alert %s was deleted, skipping", alertID)
						continue
					}
					log.Printf("subscription: failed to fetch alert %s: %v", event.AlertID, err)
					continue
				}
				select {
				case alertCh <- alertEvent:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return alertCh, nil
}

func (r *subscriptionResolver) TradeUpdated(ctx context.Context, botID uuid.UUID) (<-chan *ent.Trade, error) {
	// Authorization is already checked by @hasScope directive on initial subscribe
	if r.pubsub == nil {
		return nil, fmt.Errorf("subscriptions not available: pub/sub not configured")
	}

	topic := pubsub.TradeTopic(botID.String())
	eventCh, unsub := r.pubsub.Subscribe(ctx, topic)

	tradeCh := make(chan *ent.Trade)
	go func() {
		defer func() {
			if r := recover(); r != nil {
				log.Printf("subscription panic recovered in TradeUpdated: %v", r)
			}
			close(tradeCh)
			unsub()
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case eventData, ok := <-eventCh:
				if !ok {
					return
				}
				// Parse the event to get the trade ID
				var event pubsub.TradeEvent
				if err := json.Unmarshal(eventData, &event); err != nil {
					log.Printf("subscription: failed to parse trade event: %v", err)
					continue
				}
				// Fetch the trade from the database
				tradeID, err := uuid.Parse(event.TradeID)
				if err != nil {
					log.Printf("subscription: invalid trade ID %s: %v", event.TradeID, err)
					continue
				}
				trade, err := r.client.Trade.Get(ctx, tradeID)
				if err != nil {
					if ent.IsNotFound(err) {
						// Trade was deleted, skip
						continue
					}
					log.Printf("subscription: failed to fetch trade %s: %v", event.TradeID, err)
					continue
				}
				select {
				case tradeCh <- trade:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return tradeCh, nil
}

func (r *subscriptionResolver) RunnerStatusChanged(ctx context.Context, runnerID uuid.UUID) (<-chan *ent.BotRunner, error) {
	// Authorization is already checked by @hasScope directive on initial subscribe
	if r.pubsub == nil {
		return nil, fmt.Errorf("subscriptions not available: pub/sub not configured")
	}

	topic := pubsub.RunnerTopic(runnerID.String())
	eventCh, unsub := r.pubsub.Subscribe(ctx, topic)

	runnerCh := make(chan *ent.BotRunner)
	go func() {
		defer func() {
			if r := recover(); r != nil {
				log.Printf("subscription panic recovered in RunnerStatusChanged: %v", r)
			}
			close(runnerCh)
			unsub()
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case _, ok := <-eventCh:
				if !ok {
					return
				}
				// Fetch the latest runner state from the database
				runner, err := r.client.BotRunner.Get(ctx, runnerID)
				if err != nil {
					if ent.IsNotFound(err) {
						// Runner was deleted, close subscription
						log.Printf("subscription: runner %s was deleted, closing subscription", runnerID)
						return
					}
					log.Printf("subscription: failed to fetch runner %s: %v", runnerID, err)
					continue
				}
				select {
				case runnerCh <- runner:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return runnerCh, nil
}

func (r *subscriptionResolver) BotChanged(ctx context.Context, ownerID string) (<-chan *ent.Bot, error) {
	// Authorization is already checked by @hasScope directive on initial subscribe
	if r.pubsub == nil {
		return nil, fmt.Errorf("subscriptions not available: pub/sub not configured")
	}

	topic := pubsub.OrgBotsTopic(ownerID)
	eventCh, unsub := r.pubsub.Subscribe(ctx, topic)

	botCh := make(chan *ent.Bot)
	go func() {
		defer func() {
			if r := recover(); r != nil {
				log.Printf("subscription panic recovered in BotChanged: %v", r)
			}
			close(botCh)
			unsub()
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case data, ok := <-eventCh:
				if !ok {
					return
				}
				// Parse bot ID from event and fetch latest state
				var event pubsub.BotEvent
				if err := json.Unmarshal(data, &event); err != nil {
					log.Printf("subscription: failed to unmarshal bot event: %v", err)
					continue
				}
				botID, err := uuid.Parse(event.BotID)
				if err != nil {
					log.Printf("subscription: invalid bot ID in event: %v", err)
					continue
				}
				bot, err := r.client.Bot.Get(ctx, botID)
				if err != nil {
					if ent.IsNotFound(err) {
						// Bot was deleted, skip (don't close - other bots may update)
						continue
					}
					log.Printf("subscription: failed to fetch bot %s: %v", botID, err)
					continue
				}
				select {
				case botCh <- bot:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return botCh, nil
}

func (r *subscriptionResolver) TradeChanged(ctx context.Context, ownerID string) (<-chan *ent.Trade, error) {
	// Authorization is already checked by @hasScope directive on initial subscribe
	if r.pubsub == nil {
		return nil, fmt.Errorf("subscriptions not available: pub/sub not configured")
	}

	topic := pubsub.OrgTradesTopic(ownerID)
	eventCh, unsub := r.pubsub.Subscribe(ctx, topic)

	tradeCh := make(chan *ent.Trade)
	go func() {
		defer func() {
			if r := recover(); r != nil {
				log.Printf("subscription panic recovered in TradeChanged: %v", r)
			}
			close(tradeCh)
			unsub()
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case data, ok := <-eventCh:
				if !ok {
					return
				}
				// Parse trade ID from event and fetch latest state
				var event pubsub.TradeEvent
				if err := json.Unmarshal(data, &event); err != nil {
					log.Printf("subscription: failed to unmarshal trade event: %v", err)
					continue
				}
				tradeID, err := uuid.Parse(event.TradeID)
				if err != nil {
					log.Printf("subscription: invalid trade ID in event: %v", err)
					continue
				}
				trade, err := r.client.Trade.Get(ctx, tradeID)
				if err != nil {
					if ent.IsNotFound(err) {
						// Trade was deleted, skip
						continue
					}
					log.Printf("subscription: failed to fetch trade %s: %v", tradeID, err)
					continue
				}
				select {
				case tradeCh <- trade:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return tradeCh, nil
}

func (r *subscriptionResolver) RunnerChanged(ctx context.Context, ownerID string) (<-chan *ent.BotRunner, error) {
	// Authorization is already checked by @hasScope directive on initial subscribe
	if r.pubsub == nil {
		return nil, fmt.Errorf("subscriptions not available: pub/sub not configured")
	}

	topic := pubsub.OrgRunnersTopic(ownerID)
	eventCh, unsub := r.pubsub.Subscribe(ctx, topic)

	runnerCh := make(chan *ent.BotRunner)
	go func() {
		defer func() {
			if r := recover(); r != nil {
				log.Printf("subscription panic recovered in RunnerChanged: %v", r)
			}
			close(runnerCh)
			unsub()
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case data, ok := <-eventCh:
				if !ok {
					return
				}
				// Parse runner ID from event and fetch latest state
				var event pubsub.RunnerEvent
				if err := json.Unmarshal(data, &event); err != nil {
					log.Printf("subscription: failed to unmarshal runner event: %v", err)
					continue
				}
				runnerID, err := uuid.Parse(event.RunnerID)
				if err != nil {
					log.Printf("subscription: invalid runner ID in event: %v", err)
					continue
				}
				runner, err := r.client.BotRunner.Get(ctx, runnerID)
				if err != nil {
					if ent.IsNotFound(err) {
						// Runner was deleted, skip
						continue
					}
					log.Printf("subscription: failed to fetch runner %s: %v", runnerID, err)
					continue
				}
				select {
				case runnerCh <- runner:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return runnerCh, nil
}

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
