package graph

import (
	"volaticloud/internal/ent"
	"volaticloud/internal/enum"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestExchangeSecretMutations(t *testing.T) {
	resolver := setupTestResolver(t)
	mutationResolver := resolver.Mutation()

	// Create an exchange first (required for foreign key)
	exchange, err := mutationResolver.CreateExchange(ctx(), ent.CreateExchangeInput{
		Name:     enum.ExchangeBinance,
		TestMode: ptr(false),
	})
	require.NoError(t, err)

	t.Run("CreateExchangeSecret", func(t *testing.T) {
		input := ent.CreateExchangeSecretInput{
			Name:       "api_key",
			Value:      "test-api-key-value",
			ExchangeID: exchange.ID,
		}

		secret, err := mutationResolver.CreateExchangeSecret(ctx(), input)
		require.NoError(t, err)
		assert.NotNil(t, secret)
		assert.Equal(t, "api_key", secret.Name)
		assert.Equal(t, "test-api-key-value", secret.Value)
		assert.Equal(t, exchange.ID, secret.ExchangeID)
	})

	t.Run("UpdateExchangeSecret", func(t *testing.T) {
		// Create secret first
		input := ent.CreateExchangeSecretInput{
			Name:       "api_secret",
			Value:      "old-secret-value",
			ExchangeID: exchange.ID,
		}
		secret, err := mutationResolver.CreateExchangeSecret(ctx(), input)
		require.NoError(t, err)

		// Update it
		newValue := "new-secret-value"
		updateInput := ent.UpdateExchangeSecretInput{
			Value: &newValue,
		}
		updated, err := mutationResolver.UpdateExchangeSecret(ctx(), secret.ID, updateInput)
		require.NoError(t, err)
		assert.Equal(t, "new-secret-value", updated.Value)
		assert.Equal(t, secret.ID, updated.ID)
	})

	t.Run("DeleteExchangeSecret", func(t *testing.T) {
		// Create secret first
		input := ent.CreateExchangeSecretInput{
			Name:       "delete_me",
			Value:      "delete-secret",
			ExchangeID: exchange.ID,
		}
		secret, err := mutationResolver.CreateExchangeSecret(ctx(), input)
		require.NoError(t, err)

		// Delete it
		deleted, err := mutationResolver.DeleteExchangeSecret(ctx(), secret.ID)
		require.NoError(t, err)
		assert.True(t, deleted)
	})
}

func TestExchangeSecretQueries(t *testing.T) {
	resolver := setupTestResolver(t)
	mutationResolver := resolver.Mutation()
	queryResolver := resolver.Query()

	// Create an exchange
	exchange, err := mutationResolver.CreateExchange(ctx(), ent.CreateExchangeInput{
		Name:     enum.ExchangeKraken,
		TestMode: ptr(false),
	})
	require.NoError(t, err)

	// Create test data
	secrets := []ent.CreateExchangeSecretInput{
		{Name: "key1", Value: "secret1", ExchangeID: exchange.ID},
		{Name: "key2", Value: "secret2", ExchangeID: exchange.ID},
		{Name: "key3", Value: "secret3", ExchangeID: exchange.ID},
	}

	for _, input := range secrets {
		_, err := mutationResolver.CreateExchangeSecret(ctx(), input)
		require.NoError(t, err)
	}

	t.Run("QueryExchangeSecrets", func(t *testing.T) {
		first := 10
		result, err := queryResolver.ExchangeSecrets(ctx(), nil, &first, nil, nil)
		require.NoError(t, err)
		assert.NotNil(t, result)
		assert.GreaterOrEqual(t, result.TotalCount, 3)
		assert.GreaterOrEqual(t, len(result.Edges), 3)
	})

	t.Run("QueryExchangeSecretsWithPagination", func(t *testing.T) {
		first := 2
		result, err := queryResolver.ExchangeSecrets(ctx(), nil, &first, nil, nil)
		require.NoError(t, err)
		assert.Equal(t, 2, len(result.Edges))
		assert.True(t, result.PageInfo.HasNextPage)

		// Get next page
		cursor := result.PageInfo.EndCursor
		result2, err := queryResolver.ExchangeSecrets(ctx(), cursor, &first, nil, nil)
		require.NoError(t, err)
		assert.NotNil(t, result2)
	})
}
