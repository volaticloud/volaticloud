// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"volaticloud/internal/enum"

	"github.com/google/uuid"
)

// Metadata about an alert type including available condition fields
type AlertTypeInfo struct {
	Type            enum.AlertType     `json:"type"`
	Label           string             `json:"label"`
	Description     string             `json:"description"`
	DefaultSeverity enum.AlertSeverity `json:"defaultSeverity"`
	ConditionFields []*ConditionField  `json:"conditionFields"`
}

type BinanceConfigInput struct {
	APIKey    string `json:"apiKey"`
	APISecret string `json:"apiSecret"`
}

type BitfinexConfigInput struct {
	APIKey    string `json:"apiKey"`
	APISecret string `json:"apiSecret"`
}

type BybitConfigInput struct {
	APIKey    string `json:"apiKey"`
	APISecret string `json:"apiSecret"`
}

// Describes a configurable condition field for an alert type
type ConditionField struct {
	Name        string             `json:"name"`
	Label       string             `json:"label"`
	Type        ConditionFieldType `json:"type"`
	Required    bool               `json:"required"`
	Description string             `json:"description"`
	// For number fields: minimum value
	Min *float64 `json:"min,omitempty"`
	// For number fields: maximum value
	Max *float64 `json:"max,omitempty"`
	// For number fields: default value
	Default *float64 `json:"default,omitempty"`
	// For number fields: unit label (e.g., "%", "minutes")
	Unit *string `json:"unit,omitempty"`
	// For select/multi_select fields: available options
	Options []*SelectOption `json:"options,omitempty"`
}

type ConnectionTestResult struct {
	Success bool    `json:"success"`
	Message string  `json:"message"`
	Version *string `json:"version,omitempty"`
}

type DataDownloadConfigInput struct {
	Exchanges []*DataDownloadExchangeConfigInput `json:"exchanges"`
}

type DataDownloadExchangeConfigInput struct {
	Name         string   `json:"name"`
	Enabled      bool     `json:"enabled"`
	Timeframes   []string `json:"timeframes,omitempty"`
	PairsPattern *string  `json:"pairsPattern,omitempty"`
	Days         *int     `json:"days,omitempty"`
	TradingMode  *string  `json:"tradingMode,omitempty"`
}

type DockerConfigInput struct {
	Host         string             `json:"host"`
	TLSVerify    *bool              `json:"tlsVerify,omitempty"`
	CertPem      *string            `json:"certPEM,omitempty"`
	KeyPem       *string            `json:"keyPEM,omitempty"`
	CaPem        *string            `json:"caPEM,omitempty"`
	APIVersion   *string            `json:"apiVersion,omitempty"`
	Network      *string            `json:"network,omitempty"`
	RegistryAuth *RegistryAuthInput `json:"registryAuth,omitempty"`
}

type ExchangeConfigInput struct {
	Binance   *BinanceConfigInput            `json:"binance,omitempty"`
	Binanceus *BinanceConfigInput            `json:"binanceus,omitempty"`
	Coinbase  *PassphraseExchangeConfigInput `json:"coinbase,omitempty"`
	Kraken    *KrakenConfigInput             `json:"kraken,omitempty"`
	Kucoin    *PassphraseExchangeConfigInput `json:"kucoin,omitempty"`
	Bybit     *BybitConfigInput              `json:"bybit,omitempty"`
	Okx       *PassphraseExchangeConfigInput `json:"okx,omitempty"`
	Bitfinex  *BitfinexConfigInput           `json:"bitfinex,omitempty"`
}

type FreqtradeToken struct {
	// The bot API URL to connect to
	APIURL string `json:"apiUrl"`
	// Username for the bot API
	Username string `json:"username"`
	// JWT access token for bot API authentication
	AccessToken string `json:"accessToken"`
	// JWT refresh token for renewing access
	RefreshToken string `json:"refreshToken"`
}

type KrakenConfigInput struct {
	APIKey    string `json:"apiKey"`
	APISecret string `json:"apiSecret"`
}

type KubernetesConfigInput struct {
	Kubeconfig       *string `json:"kubeconfig,omitempty"`
	Context          *string `json:"context,omitempty"`
	Namespace        string  `json:"namespace"`
	IngressHost      *string `json:"ingressHost,omitempty"`
	IngressClass     *string `json:"ingressClass,omitempty"`
	IngressTLS       *bool   `json:"ingressTls,omitempty"`
	StorageClassName *string `json:"storageClassName,omitempty"`
	SharedDataPvc    *string `json:"sharedDataPVC,omitempty"`
	FreqtradeImage   *string `json:"freqtradeImage,omitempty"`
	PrometheusURL    *string `json:"prometheusUrl,omitempty"`
}

type LocalConfigInput struct {
	BasePath *string `json:"basePath,omitempty"`
}

type PassphraseExchangeConfigInput struct {
	APIKey     string `json:"apiKey"`
	APISecret  string `json:"apiSecret"`
	Passphrase string `json:"passphrase"`
}

// Input for checking a single permission
type PermissionCheckInput struct {
	// The resource ID (UUID) to check permission for
	ResourceID uuid.UUID `json:"resourceId"`
	// The scope to check (e.g., "edit", "delete", "run")
	Scope string `json:"scope"`
}

// Result of a permission check
type PermissionCheckResult struct {
	// The resource ID that was checked
	ResourceID uuid.UUID `json:"resourceId"`
	// The scope that was checked
	Scope string `json:"scope"`
	// Whether the permission is granted
	Granted bool `json:"granted"`
}

type RegistryAuthInput struct {
	Username      string  `json:"username"`
	Password      string  `json:"password"`
	ServerAddress *string `json:"serverAddress,omitempty"`
}

type RunnerConfigInput struct {
	Docker     *DockerConfigInput     `json:"docker,omitempty"`
	Kubernetes *KubernetesConfigInput `json:"kubernetes,omitempty"`
	Local      *LocalConfigInput      `json:"local,omitempty"`
	S3         *S3ConfigInput         `json:"s3,omitempty"`
}

// S3 storage configuration for runner data distribution
// Supports AWS S3, MinIO, Backblaze B2, and other S3-compatible storage
type S3ConfigInput struct {
	// S3 endpoint URL (e.g., "s3.amazonaws.com" or "minio.local:9000")
	Endpoint string `json:"endpoint"`
	// S3 bucket name
	Bucket string `json:"bucket"`
	// AWS/S3 access key ID
	AccessKeyID string `json:"accessKeyId"`
	// AWS/S3 secret access key
	SecretAccessKey string `json:"secretAccessKey"`
	// AWS region (default: us-east-1)
	Region *string `json:"region,omitempty"`
	// Force path-style addressing (required for MinIO, optional for AWS)
	// When true: http://endpoint/bucket/key
	// When false: http://bucket.endpoint/key
	ForcePathStyle *bool `json:"forcePathStyle,omitempty"`
	// Enable HTTPS connections (default: true)
	UseSsl *bool `json:"useSSL,omitempty"`
}

// Option for select/multi_select condition fields
type SelectOption struct {
	Value string `json:"value"`
	Label string `json:"label"`
}

// Estimated cost breakdown for resource usage
// Uses runner-specific pricing rates
type UsageCost struct {
	// Cost for CPU usage (core-hours * rate)
	CPUCost float64 `json:"cpuCost"`
	// Cost for memory usage (GB-hours * rate)
	MemoryCost float64 `json:"memoryCost"`
	// Cost for network transfer (GB * rate)
	NetworkCost float64 `json:"networkCost"`
	// Cost for disk I/O (GB * rate)
	StorageCost float64 `json:"storageCost"`
	// Total estimated cost
	TotalCost float64 `json:"totalCost"`
	// Currency for the cost
	Currency string `json:"currency"`
}

// Type of condition field for alert configuration
type ConditionFieldType string

const (
	ConditionFieldTypeNumber      ConditionFieldType = "number"
	ConditionFieldTypeSelect      ConditionFieldType = "select"
	ConditionFieldTypeMultiSelect ConditionFieldType = "multi_select"
)

var AllConditionFieldType = []ConditionFieldType{
	ConditionFieldTypeNumber,
	ConditionFieldTypeSelect,
	ConditionFieldTypeMultiSelect,
}

func (e ConditionFieldType) IsValid() bool {
	switch e {
	case ConditionFieldTypeNumber, ConditionFieldTypeSelect, ConditionFieldTypeMultiSelect:
		return true
	}
	return false
}

func (e ConditionFieldType) String() string {
	return string(e)
}

func (e *ConditionFieldType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionFieldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionFieldType", str)
	}
	return nil
}

func (e ConditionFieldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConditionFieldType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConditionFieldType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
