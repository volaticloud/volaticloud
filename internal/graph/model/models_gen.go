// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
	"volaticloud/internal/enum"

	"entgo.io/contrib/entgql"
	"github.com/google/uuid"
)

// Metadata about an alert type including available condition fields
type AlertTypeInfo struct {
	Type            enum.AlertType     `json:"type"`
	Label           string             `json:"label"`
	Description     string             `json:"description"`
	DefaultSeverity enum.AlertSeverity `json:"defaultSeverity"`
	ConditionFields []*ConditionField  `json:"conditionFields"`
}

type BinanceConfigInput struct {
	APIKey    string `json:"apiKey"`
	APISecret string `json:"apiSecret"`
}

type BitfinexConfigInput struct {
	APIKey    string `json:"apiKey"`
	APISecret string `json:"apiSecret"`
}

type BybitConfigInput struct {
	APIKey    string `json:"apiKey"`
	APISecret string `json:"apiSecret"`
}

// Describes a configurable condition field for an alert type
type ConditionField struct {
	Name        string             `json:"name"`
	Label       string             `json:"label"`
	Type        ConditionFieldType `json:"type"`
	Required    bool               `json:"required"`
	Description string             `json:"description"`
	// For number fields: minimum value
	Min *float64 `json:"min,omitempty"`
	// For number fields: maximum value
	Max *float64 `json:"max,omitempty"`
	// For number fields: default value
	Default *float64 `json:"default,omitempty"`
	// For number fields: unit label (e.g., "%", "minutes")
	Unit *string `json:"unit,omitempty"`
	// For select/multi_select fields: available options
	Options []*SelectOption `json:"options,omitempty"`
}

type ConnectionTestResult struct {
	Success bool    `json:"success"`
	Message string  `json:"message"`
	Version *string `json:"version,omitempty"`
}

// Input for creating an organization
type CreateOrganizationInput struct {
	// The display title of the organization
	Title string `json:"title"`
	// The unique alias for the organization (URL-friendly identifier).
	// If not provided, will be auto-generated from the title.
	// IMPORTANT: Alias cannot be changed after creation.
	// Must be lowercase, alphanumeric with hyphens, 3-50 characters.
	Alias *string `json:"alias,omitempty"`
}

// Response from creating an organization
type CreateOrganizationResponse struct {
	// The unique alias of the organization (immutable identifier).
	// This is the same as the alias field.
	ID string `json:"id"`
	// The display title of the organization
	Title string `json:"title"`
	// The unique alias (same as id, included for clarity).
	// Human-readable URL-friendly identifier that cannot be changed.
	Alias string `json:"alias"`
}

type DataDownloadConfigInput struct {
	Exchanges []*DataDownloadExchangeConfigInput `json:"exchanges"`
}

type DataDownloadExchangeConfigInput struct {
	Name         string   `json:"name"`
	Enabled      bool     `json:"enabled"`
	Timeframes   []string `json:"timeframes,omitempty"`
	PairsPattern *string  `json:"pairsPattern,omitempty"`
	Days         *int     `json:"days,omitempty"`
	TradingMode  *string  `json:"tradingMode,omitempty"`
}

type DockerConfigInput struct {
	Host         string             `json:"host"`
	TLSVerify    *bool              `json:"tlsVerify,omitempty"`
	CertPem      *string            `json:"certPEM,omitempty"`
	KeyPem       *string            `json:"keyPEM,omitempty"`
	CaPem        *string            `json:"caPEM,omitempty"`
	APIVersion   *string            `json:"apiVersion,omitempty"`
	Network      *string            `json:"network,omitempty"`
	RegistryAuth *RegistryAuthInput `json:"registryAuth,omitempty"`
}

type ExchangeConfigInput struct {
	Binance   *BinanceConfigInput            `json:"binance,omitempty"`
	Binanceus *BinanceConfigInput            `json:"binanceus,omitempty"`
	Coinbase  *PassphraseExchangeConfigInput `json:"coinbase,omitempty"`
	Kraken    *KrakenConfigInput             `json:"kraken,omitempty"`
	Kucoin    *PassphraseExchangeConfigInput `json:"kucoin,omitempty"`
	Bybit     *BybitConfigInput              `json:"bybit,omitempty"`
	Okx       *PassphraseExchangeConfigInput `json:"okx,omitempty"`
	Bitfinex  *BitfinexConfigInput           `json:"bitfinex,omitempty"`
}

type FreqtradeToken struct {
	// The bot API URL to connect to
	APIURL string `json:"apiUrl"`
	// Username for the bot API
	Username string `json:"username"`
	// JWT access token for bot API authentication
	AccessToken string `json:"accessToken"`
	// JWT refresh token for renewing access
	RefreshToken string `json:"refreshToken"`
}

type GroupNode struct {
	ID       uuid.UUID    `json:"id"`
	Name     string       `json:"name"`
	Path     string       `json:"path"`
	Type     string       `json:"type"`
	Title    string       `json:"title"`
	Children []*GroupNode `json:"children"`
}

// Input for inviting a user to an organization
type InviteUserInput struct {
	// Email address of the user to invite
	Email string `json:"email"`
	// First name of the user (optional, used in invitation email)
	FirstName *string `json:"firstName,omitempty"`
	// Last name of the user (optional, used in invitation email)
	LastName *string `json:"lastName,omitempty"`
	// URL to redirect to after invitation acceptance (optional).
	// Should include the organization path, e.g., "http://localhost:5173/organizations/{orgId}"
	RedirectURL *string `json:"redirectUrl,omitempty"`
}

type KrakenConfigInput struct {
	APIKey    string `json:"apiKey"`
	APISecret string `json:"apiSecret"`
}

type KubernetesConfigInput struct {
	Kubeconfig       *string `json:"kubeconfig,omitempty"`
	Context          *string `json:"context,omitempty"`
	Namespace        string  `json:"namespace"`
	IngressHost      *string `json:"ingressHost,omitempty"`
	IngressClass     *string `json:"ingressClass,omitempty"`
	IngressTLS       *bool   `json:"ingressTls,omitempty"`
	StorageClassName *string `json:"storageClassName,omitempty"`
	SharedDataPvc    *string `json:"sharedDataPVC,omitempty"`
	FreqtradeImage   *string `json:"freqtradeImage,omitempty"`
	PrometheusURL    *string `json:"prometheusUrl,omitempty"`
}

type LocalConfigInput struct {
	BasePath *string `json:"basePath,omitempty"`
}

// User information for resource group members
type MemberUser struct {
	// User ID (Keycloak UUID)
	ID uuid.UUID `json:"id"`
	// Username
	Username string `json:"username"`
	// Email address
	Email *string `json:"email,omitempty"`
	// Whether the email is verified
	EmailVerified bool `json:"emailVerified"`
	// First name
	FirstName *string `json:"firstName,omitempty"`
	// Last name
	LastName *string `json:"lastName,omitempty"`
	// Whether the user account is enabled
	Enabled bool `json:"enabled"`
	// User creation timestamp
	CreatedAt time.Time `json:"createdAt"`
}

// Response from invitation operations
type OrganizationInvitation struct {
	// Invitation ID (UUID)
	ID uuid.UUID `json:"id"`
	// Email address of the invited user
	Email string `json:"email"`
	// First name of the invited user
	FirstName *string `json:"firstName,omitempty"`
	// Last name of the invited user
	LastName *string `json:"lastName,omitempty"`
	// Organization alias (resource ID)
	OrganizationID string `json:"organizationId"`
	// Invitation status (PENDING, EXPIRED)
	Status string `json:"status"`
	// Timestamp when invitation was created (Unix milliseconds)
	CreatedAt time.Time `json:"createdAt"`
	// Timestamp when invitation expires (Unix milliseconds)
	ExpiresAt time.Time `json:"expiresAt"`
}

// Connection type for paginated invitation list
type OrganizationInvitationConnection struct {
	// List of invitations
	Invitations []*OrganizationInvitation `json:"invitations"`
	// Total count of invitations
	TotalCount int `json:"totalCount"`
}

// User in the organization (from Keycloak)
type OrganizationUser struct {
	// User ID (Keycloak UUID)
	ID uuid.UUID `json:"id"`
	// Username
	Username string `json:"username"`
	// Email address
	Email *string `json:"email,omitempty"`
	// Whether the email is verified
	EmailVerified bool `json:"emailVerified"`
	// First name
	FirstName *string `json:"firstName,omitempty"`
	// Last name
	LastName *string `json:"lastName,omitempty"`
	// Whether the user account is enabled
	Enabled bool `json:"enabled"`
	// User creation timestamp (Unix milliseconds)
	CreatedAt time.Time `json:"createdAt"`
}

type PassphraseExchangeConfigInput struct {
	APIKey     string `json:"apiKey"`
	APISecret  string `json:"apiSecret"`
	Passphrase string `json:"passphrase"`
}

// Input for checking a single permission
type PermissionCheckInput struct {
	// The resource ID (UUID) to check permission for
	ResourceID uuid.UUID `json:"resourceId"`
	// The scope to check (e.g., "edit", "delete", "run")
	Scope string `json:"scope"`
}

// Result of a permission check
type PermissionCheckResult struct {
	// The resource ID that was checked
	ResourceID uuid.UUID `json:"resourceId"`
	// The scope that was checked
	Scope string `json:"scope"`
	// Whether the permission is granted
	Granted bool `json:"granted"`
}

// Result of strategy code preview generation
type PreviewCodeResult struct {
	// Whether the code generation was successful
	Success bool `json:"success"`
	// Generated Python code (empty if success is false)
	Code string `json:"code"`
	// Error message if generation failed
	Error *string `json:"error,omitempty"`
}

type RegistryAuthInput struct {
	Username      string  `json:"username"`
	Password      string  `json:"password"`
	ServerAddress *string `json:"serverAddress,omitempty"`
}

// Resource group with normalized role data
// Represents strategies, bots, and other resources under an organization
type ResourceGroup struct {
	// Resource group name (our resource UUID)
	Name string `json:"name"`
	// Resource group path (hierarchical)
	Path string `json:"path"`
	// Display title (from GROUP_TITLE attribute)
	Title string `json:"title"`
	// Resource type (from GROUP_TYPE attribute)
	// Values: "strategy", "bot", "exchange", "runner", "organization", "none"
	Type string `json:"type"`
	// List of roles with member counts
	Roles []*RoleInfo `json:"roles"`
	// Total number of members across all roles
	TotalMembers int `json:"totalMembers"`
	// Whether this resource group has child resource groups
	HasChildren bool `json:"hasChildren"`
}

// Paginated resource group connection
type ResourceGroupConnection struct {
	// Resource group edges
	Edges []*ResourceGroupEdge `json:"edges"`
	// Total count of resource groups (before pagination)
	TotalCount int `json:"totalCount"`
	// Pagination info
	PageInfo *entgql.PageInfo[uuid.UUID] `json:"pageInfo"`
}

// Edge for resource group connection
type ResourceGroupEdge struct {
	// Resource group node
	Node *ResourceGroup `json:"node"`
	// Cursor for pagination
	Cursor string `json:"cursor"`
}

// Resource group member with role information
type ResourceGroupMember struct {
	// User information
	User *MemberUser `json:"user"`
	// All roles the user has in this resource group
	Roles []string `json:"roles"`
	// Primary role (highest priority: owner > admin > editor > viewer)
	PrimaryRole string `json:"primaryRole"`
}

// Paginated resource group member connection
type ResourceGroupMemberConnection struct {
	// Resource group member edges
	Edges []*ResourceGroupMemberEdge `json:"edges"`
	// Total count of members (before pagination)
	TotalCount int `json:"totalCount"`
	// Pagination info
	PageInfo *entgql.PageInfo[uuid.UUID] `json:"pageInfo"`
	// Available roles for this resource group (e.g., ["admin", "viewer"])
	// Used to populate role selection dropdowns
	AvailableRoles []string `json:"availableRoles"`
}

// Edge for resource group member connection
type ResourceGroupMemberEdge struct {
	// Resource group member node
	Node *ResourceGroupMember `json:"node"`
	// Cursor for pagination
	Cursor string `json:"cursor"`
}

// Order input for resource group members
type ResourceGroupMemberOrder struct {
	// Field to order by
	Field ResourceGroupMemberOrderField `json:"field"`
	// Order direction
	Direction entgql.OrderDirection `json:"direction"`
}

// Filter input for resource group members
type ResourceGroupMemberWhereInput struct {
	// Filter by roles (user must have at least one of these roles)
	RoleIn []string `json:"roleIn,omitempty"`
	// Search by username, email, firstName, lastName (case-insensitive)
	SearchContainsFold *string `json:"searchContainsFold,omitempty"`
	// Filter by enabled status
	Enabled *bool `json:"enabled,omitempty"`
	// Filter by email verified status
	EmailVerified *bool `json:"emailVerified,omitempty"`
}

// Order input for resource groups
type ResourceGroupOrder struct {
	// Field to order by
	Field ResourceGroupOrderField `json:"field"`
	// Order direction
	Direction entgql.OrderDirection `json:"direction"`
}

// Filter input for resource groups
type ResourceGroupWhereInput struct {
	// Search by title (case-insensitive substring match)
	TitleContainsFold *string `json:"titleContainsFold,omitempty"`
}

// Role information with member count
type RoleInfo struct {
	// Role name (e.g., "admin", "viewer")
	Name string `json:"name"`
	// Number of members with this role
	MemberCount int `json:"memberCount"`
}

type RunnerConfigInput struct {
	Docker     *DockerConfigInput     `json:"docker,omitempty"`
	Kubernetes *KubernetesConfigInput `json:"kubernetes,omitempty"`
	Local      *LocalConfigInput      `json:"local,omitempty"`
	S3         *S3ConfigInput         `json:"s3,omitempty"`
}

// S3 storage configuration for runner data distribution
// Supports AWS S3, MinIO, Backblaze B2, and other S3-compatible storage
type S3ConfigInput struct {
	// S3 endpoint URL (e.g., "s3.amazonaws.com" or "minio.local:9000")
	Endpoint string `json:"endpoint"`
	// S3 bucket name
	Bucket string `json:"bucket"`
	// AWS/S3 access key ID
	AccessKeyID string `json:"accessKeyId"`
	// AWS/S3 secret access key
	SecretAccessKey string `json:"secretAccessKey"`
	// AWS region (default: us-east-1)
	Region *string `json:"region,omitempty"`
	// Force path-style addressing (required for MinIO, optional for AWS)
	// When true: http://endpoint/bucket/key
	// When false: http://bucket.endpoint/key
	ForcePathStyle *bool `json:"forcePathStyle,omitempty"`
	// Enable HTTPS connections (default: true)
	UseSsl *bool `json:"useSSL,omitempty"`
}

// Option for select/multi_select condition fields
type SelectOption struct {
	Value string `json:"value"`
	Label string `json:"label"`
}

// Estimated cost breakdown for resource usage
// Uses runner-specific pricing rates
type UsageCost struct {
	// Cost for CPU usage (core-hours * rate)
	CPUCost float64 `json:"cpuCost"`
	// Cost for memory usage (GB-hours * rate)
	MemoryCost float64 `json:"memoryCost"`
	// Cost for network transfer (GB * rate)
	NetworkCost float64 `json:"networkCost"`
	// Cost for disk I/O (GB * rate)
	StorageCost float64 `json:"storageCost"`
	// Total estimated cost
	TotalCost float64 `json:"totalCost"`
	// Currency for the cost
	Currency string `json:"currency"`
}

// Comparison operators for COMPARE nodes
type ComparisonOperator string

const (
	ComparisonOperatorEq    ComparisonOperator = "eq"
	ComparisonOperatorNeq   ComparisonOperator = "neq"
	ComparisonOperatorGt    ComparisonOperator = "gt"
	ComparisonOperatorGte   ComparisonOperator = "gte"
	ComparisonOperatorLt    ComparisonOperator = "lt"
	ComparisonOperatorLte   ComparisonOperator = "lte"
	ComparisonOperatorIn    ComparisonOperator = "in"
	ComparisonOperatorNotIn ComparisonOperator = "not_in"
)

var AllComparisonOperator = []ComparisonOperator{
	ComparisonOperatorEq,
	ComparisonOperatorNeq,
	ComparisonOperatorGt,
	ComparisonOperatorGte,
	ComparisonOperatorLt,
	ComparisonOperatorLte,
	ComparisonOperatorIn,
	ComparisonOperatorNotIn,
}

func (e ComparisonOperator) IsValid() bool {
	switch e {
	case ComparisonOperatorEq, ComparisonOperatorNeq, ComparisonOperatorGt, ComparisonOperatorGte, ComparisonOperatorLt, ComparisonOperatorLte, ComparisonOperatorIn, ComparisonOperatorNotIn:
		return true
	}
	return false
}

func (e ComparisonOperator) String() string {
	return string(e)
}

func (e *ComparisonOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComparisonOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComparisonOperator", str)
	}
	return nil
}

func (e ComparisonOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ComparisonOperator) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ComparisonOperator) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Arithmetic operations for COMPUTED operands
type ComputedOperation string

const (
	ComputedOperationAdd           ComputedOperation = "add"
	ComputedOperationSubtract      ComputedOperation = "subtract"
	ComputedOperationMultiply      ComputedOperation = "multiply"
	ComputedOperationDivide        ComputedOperation = "divide"
	ComputedOperationMin           ComputedOperation = "min"
	ComputedOperationMax           ComputedOperation = "max"
	ComputedOperationAbs           ComputedOperation = "abs"
	ComputedOperationRound         ComputedOperation = "round"
	ComputedOperationFloor         ComputedOperation = "floor"
	ComputedOperationCeil          ComputedOperation = "ceil"
	ComputedOperationPercentChange ComputedOperation = "percent_change"
	ComputedOperationAverage       ComputedOperation = "average"
	ComputedOperationSum           ComputedOperation = "sum"
)

var AllComputedOperation = []ComputedOperation{
	ComputedOperationAdd,
	ComputedOperationSubtract,
	ComputedOperationMultiply,
	ComputedOperationDivide,
	ComputedOperationMin,
	ComputedOperationMax,
	ComputedOperationAbs,
	ComputedOperationRound,
	ComputedOperationFloor,
	ComputedOperationCeil,
	ComputedOperationPercentChange,
	ComputedOperationAverage,
	ComputedOperationSum,
}

func (e ComputedOperation) IsValid() bool {
	switch e {
	case ComputedOperationAdd, ComputedOperationSubtract, ComputedOperationMultiply, ComputedOperationDivide, ComputedOperationMin, ComputedOperationMax, ComputedOperationAbs, ComputedOperationRound, ComputedOperationFloor, ComputedOperationCeil, ComputedOperationPercentChange, ComputedOperationAverage, ComputedOperationSum:
		return true
	}
	return false
}

func (e ComputedOperation) String() string {
	return string(e)
}

func (e *ComputedOperation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComputedOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComputedOperation", str)
	}
	return nil
}

func (e ComputedOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ComputedOperation) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ComputedOperation) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of condition field for alert configuration
type ConditionFieldType string

const (
	ConditionFieldTypeNumber      ConditionFieldType = "number"
	ConditionFieldTypeSelect      ConditionFieldType = "select"
	ConditionFieldTypeMultiSelect ConditionFieldType = "multi_select"
)

var AllConditionFieldType = []ConditionFieldType{
	ConditionFieldTypeNumber,
	ConditionFieldTypeSelect,
	ConditionFieldTypeMultiSelect,
}

func (e ConditionFieldType) IsValid() bool {
	switch e {
	case ConditionFieldTypeNumber, ConditionFieldTypeSelect, ConditionFieldTypeMultiSelect:
		return true
	}
	return false
}

func (e ConditionFieldType) String() string {
	return string(e)
}

func (e *ConditionFieldType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionFieldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionFieldType", str)
	}
	return nil
}

func (e ConditionFieldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConditionFieldType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConditionFieldType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of condition node in the strategy builder tree
type ConditionNodeType string

const (
	ConditionNodeTypeAnd        ConditionNodeType = "AND"
	ConditionNodeTypeOr         ConditionNodeType = "OR"
	ConditionNodeTypeNot        ConditionNodeType = "NOT"
	ConditionNodeTypeIfThenElse ConditionNodeType = "IF_THEN_ELSE"
	ConditionNodeTypeCompare    ConditionNodeType = "COMPARE"
	ConditionNodeTypeCrossover  ConditionNodeType = "CROSSOVER"
	ConditionNodeTypeCrossunder ConditionNodeType = "CROSSUNDER"
	ConditionNodeTypeInRange    ConditionNodeType = "IN_RANGE"
)

var AllConditionNodeType = []ConditionNodeType{
	ConditionNodeTypeAnd,
	ConditionNodeTypeOr,
	ConditionNodeTypeNot,
	ConditionNodeTypeIfThenElse,
	ConditionNodeTypeCompare,
	ConditionNodeTypeCrossover,
	ConditionNodeTypeCrossunder,
	ConditionNodeTypeInRange,
}

func (e ConditionNodeType) IsValid() bool {
	switch e {
	case ConditionNodeTypeAnd, ConditionNodeTypeOr, ConditionNodeTypeNot, ConditionNodeTypeIfThenElse, ConditionNodeTypeCompare, ConditionNodeTypeCrossover, ConditionNodeTypeCrossunder, ConditionNodeTypeInRange:
		return true
	}
	return false
}

func (e ConditionNodeType) String() string {
	return string(e)
}

func (e *ConditionNodeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionNodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionNodeType", str)
	}
	return nil
}

func (e ConditionNodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConditionNodeType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConditionNodeType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Built-in indicator types
type IndicatorType string

const (
	IndicatorTypeRsi        IndicatorType = "RSI"
	IndicatorTypeSma        IndicatorType = "SMA"
	IndicatorTypeEma        IndicatorType = "EMA"
	IndicatorTypeWma        IndicatorType = "WMA"
	IndicatorTypeDema       IndicatorType = "DEMA"
	IndicatorTypeTema       IndicatorType = "TEMA"
	IndicatorTypeKama       IndicatorType = "KAMA"
	IndicatorTypeMacd       IndicatorType = "MACD"
	IndicatorTypeBb         IndicatorType = "BB"
	IndicatorTypeKc         IndicatorType = "KC"
	IndicatorTypeStoch      IndicatorType = "STOCH"
	IndicatorTypeStochRsi   IndicatorType = "STOCH_RSI"
	IndicatorTypeAtr        IndicatorType = "ATR"
	IndicatorTypeAdx        IndicatorType = "ADX"
	IndicatorTypeCci        IndicatorType = "CCI"
	IndicatorTypeWillr      IndicatorType = "WILLR"
	IndicatorTypeMom        IndicatorType = "MOM"
	IndicatorTypeRoc        IndicatorType = "ROC"
	IndicatorTypeObv        IndicatorType = "OBV"
	IndicatorTypeMfi        IndicatorType = "MFI"
	IndicatorTypeVwap       IndicatorType = "VWAP"
	IndicatorTypeCmf        IndicatorType = "CMF"
	IndicatorTypeAd         IndicatorType = "AD"
	IndicatorTypeIchimoku   IndicatorType = "ICHIMOKU"
	IndicatorTypeSar        IndicatorType = "SAR"
	IndicatorTypePivot      IndicatorType = "PIVOT"
	IndicatorTypeSupertrend IndicatorType = "SUPERTREND"
	IndicatorTypeCustom     IndicatorType = "CUSTOM"
)

var AllIndicatorType = []IndicatorType{
	IndicatorTypeRsi,
	IndicatorTypeSma,
	IndicatorTypeEma,
	IndicatorTypeWma,
	IndicatorTypeDema,
	IndicatorTypeTema,
	IndicatorTypeKama,
	IndicatorTypeMacd,
	IndicatorTypeBb,
	IndicatorTypeKc,
	IndicatorTypeStoch,
	IndicatorTypeStochRsi,
	IndicatorTypeAtr,
	IndicatorTypeAdx,
	IndicatorTypeCci,
	IndicatorTypeWillr,
	IndicatorTypeMom,
	IndicatorTypeRoc,
	IndicatorTypeObv,
	IndicatorTypeMfi,
	IndicatorTypeVwap,
	IndicatorTypeCmf,
	IndicatorTypeAd,
	IndicatorTypeIchimoku,
	IndicatorTypeSar,
	IndicatorTypePivot,
	IndicatorTypeSupertrend,
	IndicatorTypeCustom,
}

func (e IndicatorType) IsValid() bool {
	switch e {
	case IndicatorTypeRsi, IndicatorTypeSma, IndicatorTypeEma, IndicatorTypeWma, IndicatorTypeDema, IndicatorTypeTema, IndicatorTypeKama, IndicatorTypeMacd, IndicatorTypeBb, IndicatorTypeKc, IndicatorTypeStoch, IndicatorTypeStochRsi, IndicatorTypeAtr, IndicatorTypeAdx, IndicatorTypeCci, IndicatorTypeWillr, IndicatorTypeMom, IndicatorTypeRoc, IndicatorTypeObv, IndicatorTypeMfi, IndicatorTypeVwap, IndicatorTypeCmf, IndicatorTypeAd, IndicatorTypeIchimoku, IndicatorTypeSar, IndicatorTypePivot, IndicatorTypeSupertrend, IndicatorTypeCustom:
		return true
	}
	return false
}

func (e IndicatorType) String() string {
	return string(e)
}

func (e *IndicatorType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IndicatorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IndicatorType", str)
	}
	return nil
}

func (e IndicatorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IndicatorType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IndicatorType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Category of operand for UI organization
type OperandCategory string

const (
	OperandCategoryConstant  OperandCategory = "constant"
	OperandCategoryIndicator OperandCategory = "indicator"
	OperandCategoryPrice     OperandCategory = "price"
	OperandCategoryTrade     OperandCategory = "trade"
	OperandCategoryTime      OperandCategory = "time"
	OperandCategoryExternal  OperandCategory = "external"
	OperandCategoryComputed  OperandCategory = "computed"
	OperandCategoryCustom    OperandCategory = "custom"
)

var AllOperandCategory = []OperandCategory{
	OperandCategoryConstant,
	OperandCategoryIndicator,
	OperandCategoryPrice,
	OperandCategoryTrade,
	OperandCategoryTime,
	OperandCategoryExternal,
	OperandCategoryComputed,
	OperandCategoryCustom,
}

func (e OperandCategory) IsValid() bool {
	switch e {
	case OperandCategoryConstant, OperandCategoryIndicator, OperandCategoryPrice, OperandCategoryTrade, OperandCategoryTime, OperandCategoryExternal, OperandCategoryComputed, OperandCategoryCustom:
		return true
	}
	return false
}

func (e OperandCategory) String() string {
	return string(e)
}

func (e *OperandCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperandCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperandCategory", str)
	}
	return nil
}

func (e OperandCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OperandCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OperandCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of operand in a condition
type OperandType string

const (
	OperandTypeConstant     OperandType = "CONSTANT"
	OperandTypeIndicator    OperandType = "INDICATOR"
	OperandTypePrice        OperandType = "PRICE"
	OperandTypeTradeContext OperandType = "TRADE_CONTEXT"
	OperandTypeTime         OperandType = "TIME"
	OperandTypeExternal     OperandType = "EXTERNAL"
	OperandTypeComputed     OperandType = "COMPUTED"
	OperandTypeCustom       OperandType = "CUSTOM"
)

var AllOperandType = []OperandType{
	OperandTypeConstant,
	OperandTypeIndicator,
	OperandTypePrice,
	OperandTypeTradeContext,
	OperandTypeTime,
	OperandTypeExternal,
	OperandTypeComputed,
	OperandTypeCustom,
}

func (e OperandType) IsValid() bool {
	switch e {
	case OperandTypeConstant, OperandTypeIndicator, OperandTypePrice, OperandTypeTradeContext, OperandTypeTime, OperandTypeExternal, OperandTypeComputed, OperandTypeCustom:
		return true
	}
	return false
}

func (e OperandType) String() string {
	return string(e)
}

func (e *OperandType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperandType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperandType", str)
	}
	return nil
}

func (e OperandType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OperandType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OperandType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Price field options for PRICE operands
type PriceField string

const (
	PriceFieldOpen   PriceField = "open"
	PriceFieldHigh   PriceField = "high"
	PriceFieldLow    PriceField = "low"
	PriceFieldClose  PriceField = "close"
	PriceFieldVolume PriceField = "volume"
	PriceFieldOhlc4  PriceField = "ohlc4"
	PriceFieldHlc3   PriceField = "hlc3"
	PriceFieldHl2    PriceField = "hl2"
)

var AllPriceField = []PriceField{
	PriceFieldOpen,
	PriceFieldHigh,
	PriceFieldLow,
	PriceFieldClose,
	PriceFieldVolume,
	PriceFieldOhlc4,
	PriceFieldHlc3,
	PriceFieldHl2,
}

func (e PriceField) IsValid() bool {
	switch e {
	case PriceFieldOpen, PriceFieldHigh, PriceFieldLow, PriceFieldClose, PriceFieldVolume, PriceFieldOhlc4, PriceFieldHlc3, PriceFieldHl2:
		return true
	}
	return false
}

func (e PriceField) String() string {
	return string(e)
}

func (e *PriceField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceField", str)
	}
	return nil
}

func (e PriceField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PriceField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PriceField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Resource group member order fields
type ResourceGroupMemberOrderField string

const (
	ResourceGroupMemberOrderFieldUsername    ResourceGroupMemberOrderField = "USERNAME"
	ResourceGroupMemberOrderFieldEmail       ResourceGroupMemberOrderField = "EMAIL"
	ResourceGroupMemberOrderFieldFirstName   ResourceGroupMemberOrderField = "FIRST_NAME"
	ResourceGroupMemberOrderFieldLastName    ResourceGroupMemberOrderField = "LAST_NAME"
	ResourceGroupMemberOrderFieldCreatedAt   ResourceGroupMemberOrderField = "CREATED_AT"
	ResourceGroupMemberOrderFieldPrimaryRole ResourceGroupMemberOrderField = "PRIMARY_ROLE"
)

var AllResourceGroupMemberOrderField = []ResourceGroupMemberOrderField{
	ResourceGroupMemberOrderFieldUsername,
	ResourceGroupMemberOrderFieldEmail,
	ResourceGroupMemberOrderFieldFirstName,
	ResourceGroupMemberOrderFieldLastName,
	ResourceGroupMemberOrderFieldCreatedAt,
	ResourceGroupMemberOrderFieldPrimaryRole,
}

func (e ResourceGroupMemberOrderField) IsValid() bool {
	switch e {
	case ResourceGroupMemberOrderFieldUsername, ResourceGroupMemberOrderFieldEmail, ResourceGroupMemberOrderFieldFirstName, ResourceGroupMemberOrderFieldLastName, ResourceGroupMemberOrderFieldCreatedAt, ResourceGroupMemberOrderFieldPrimaryRole:
		return true
	}
	return false
}

func (e ResourceGroupMemberOrderField) String() string {
	return string(e)
}

func (e *ResourceGroupMemberOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceGroupMemberOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceGroupMemberOrderField", str)
	}
	return nil
}

func (e ResourceGroupMemberOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceGroupMemberOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceGroupMemberOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Resource group order fields
type ResourceGroupOrderField string

const (
	ResourceGroupOrderFieldTitle        ResourceGroupOrderField = "TITLE"
	ResourceGroupOrderFieldTotalMembers ResourceGroupOrderField = "TOTAL_MEMBERS"
)

var AllResourceGroupOrderField = []ResourceGroupOrderField{
	ResourceGroupOrderFieldTitle,
	ResourceGroupOrderFieldTotalMembers,
}

func (e ResourceGroupOrderField) IsValid() bool {
	switch e {
	case ResourceGroupOrderFieldTitle, ResourceGroupOrderFieldTotalMembers:
		return true
	}
	return false
}

func (e ResourceGroupOrderField) String() string {
	return string(e)
}

func (e *ResourceGroupOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceGroupOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceGroupOrderField", str)
	}
	return nil
}

func (e ResourceGroupOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceGroupOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceGroupOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Time field options for TIME operands
type TimeField string

const (
	TimeFieldHour       TimeField = "hour"
	TimeFieldMinute     TimeField = "minute"
	TimeFieldDayOfWeek  TimeField = "day_of_week"
	TimeFieldDayOfMonth TimeField = "day_of_month"
	TimeFieldMonth      TimeField = "month"
	TimeFieldTimestamp  TimeField = "timestamp"
	TimeFieldIsWeekend  TimeField = "is_weekend"
)

var AllTimeField = []TimeField{
	TimeFieldHour,
	TimeFieldMinute,
	TimeFieldDayOfWeek,
	TimeFieldDayOfMonth,
	TimeFieldMonth,
	TimeFieldTimestamp,
	TimeFieldIsWeekend,
}

func (e TimeField) IsValid() bool {
	switch e {
	case TimeFieldHour, TimeFieldMinute, TimeFieldDayOfWeek, TimeFieldDayOfMonth, TimeFieldMonth, TimeFieldTimestamp, TimeFieldIsWeekend:
		return true
	}
	return false
}

func (e TimeField) String() string {
	return string(e)
}

func (e *TimeField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeField", str)
	}
	return nil
}

func (e TimeField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TimeField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TimeField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Trade context field options for TRADE_CONTEXT operands
type TradeContextField string

const (
	TradeContextFieldCurrentProfit    TradeContextField = "current_profit"
	TradeContextFieldCurrentProfitPct TradeContextField = "current_profit_pct"
	TradeContextFieldEntryRate        TradeContextField = "entry_rate"
	TradeContextFieldCurrentRate      TradeContextField = "current_rate"
	TradeContextFieldTradeDuration    TradeContextField = "trade_duration"
	TradeContextFieldNrOfEntries      TradeContextField = "nr_of_entries"
	TradeContextFieldStakeAmount      TradeContextField = "stake_amount"
	TradeContextFieldPair             TradeContextField = "pair"
	TradeContextFieldIsShort          TradeContextField = "is_short"
)

var AllTradeContextField = []TradeContextField{
	TradeContextFieldCurrentProfit,
	TradeContextFieldCurrentProfitPct,
	TradeContextFieldEntryRate,
	TradeContextFieldCurrentRate,
	TradeContextFieldTradeDuration,
	TradeContextFieldNrOfEntries,
	TradeContextFieldStakeAmount,
	TradeContextFieldPair,
	TradeContextFieldIsShort,
}

func (e TradeContextField) IsValid() bool {
	switch e {
	case TradeContextFieldCurrentProfit, TradeContextFieldCurrentProfitPct, TradeContextFieldEntryRate, TradeContextFieldCurrentRate, TradeContextFieldTradeDuration, TradeContextFieldNrOfEntries, TradeContextFieldStakeAmount, TradeContextFieldPair, TradeContextFieldIsShort:
		return true
	}
	return false
}

func (e TradeContextField) String() string {
	return string(e)
}

func (e *TradeContextField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TradeContextField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TradeContextField", str)
	}
	return nil
}

func (e TradeContextField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TradeContextField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TradeContextField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
