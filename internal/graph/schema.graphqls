# Custom GraphQL schema
# Note: Scalar declarations (Time, Map, Cursor) are in scalars.graphql
# which must be loaded first in gqlgen.yml

# Authorization directives

"""
Requires the request to be authenticated (valid JWT token)
Ensures user context is available in resolver
"""
directive @isAuthenticated on FIELD_DEFINITION

"""
Requires the user to have a specific permission scope on a resource
Uses Keycloak UMA 2.0 for fine-grained authorization
"""
directive @hasScope(
  """
  The resource ID argument name (e.g., "id" for mutations that take an ID)
  """
  resource: String!

  """
  The permission scope to check (e.g., "edit", "delete", "view", "backtest")
  """
  scope: String!
) on FIELD_DEFINITION

"""
Requires the user to have a specific permission scope on the parent node/object
Uses Keycloak UMA 2.0 for node-level field authorization
This directive inspects the parent object to get the resource ID and checks permission
"""
directive @requiresPermission(
  """
  The permission scope to check (e.g., "view", "view:code", "edit")
  """
  scope: String!

  """
  The field name containing the resource ID in the parent object (defaults to "id")
  """
  idField: String = "id"
) on FIELD_DEFINITION

# Runner configuration inputs

input RegistryAuthInput {
  username: String!
  password: String!
  serverAddress: String
}

input DockerConfigInput {
  host: String!
  tlsVerify: Boolean
  certPEM: String
  keyPEM: String
  caPEM: String
  apiVersion: String
  network: String
  registryAuth: RegistryAuthInput
}

input KubernetesConfigInput {
  kubeconfig: String          # Kubeconfig YAML content (paste full config, empty = in-cluster)
  context: String             # Kubernetes context to use
  namespace: String!          # Kubernetes namespace (required)
  ingressHost: String         # Ingress hostname for path-based bot access (e.g., "bots.example.com")
  ingressClass: String        # Ingress class to use (e.g., "nginx", "traefik")
  ingressTls: Boolean         # Enable TLS for ingress (requires cert-manager or pre-created secret)
  storageClassName: String    # Storage class for PVCs (RWX required for shared data)
  sharedDataPVC: String       # PVC name for shared OHLCV data (default: volaticloud-freqtrade-data)
  freqtradeImage: String      # Default freqtrade image (default: freqtradeorg/freqtrade:stable)
  prometheusUrl: String       # Prometheus URL for network/disk I/O metrics
}

input LocalConfigInput {
  basePath: String
}

"""
S3 storage configuration for runner data distribution
Supports AWS S3, MinIO, Backblaze B2, and other S3-compatible storage
"""
input S3ConfigInput {
  """
  S3 endpoint URL (e.g., "s3.amazonaws.com" or "minio.local:9000")
  """
  endpoint: String!
  """
  S3 bucket name
  """
  bucket: String!
  """
  AWS/S3 access key ID
  """
  accessKeyId: String!
  """
  AWS/S3 secret access key
  """
  secretAccessKey: String!
  """
  AWS region (default: us-east-1)
  """
  region: String
  """
  Force path-style addressing (required for MinIO, optional for AWS)
  When true: http://endpoint/bucket/key
  When false: http://bucket.endpoint/key
  """
  forcePathStyle: Boolean
  """
  Enable HTTPS connections (default: true)
  """
  useSSL: Boolean
}

# Union-like input for runner configuration
input RunnerConfigInput {
  docker: DockerConfigInput
  kubernetes: KubernetesConfigInput
  local: LocalConfigInput
  s3: S3ConfigInput
}

# Runner data download configuration

input DataDownloadExchangeConfigInput {
  name: String!
  enabled: Boolean!
  timeframes: [String!]
  pairsPattern: String
  days: Int
  tradingMode: String
}

input DataDownloadConfigInput {
  exchanges: [DataDownloadExchangeConfigInput!]!
}

# Exchange configuration inputs

input BinanceConfigInput {
  apiKey: String!
  apiSecret: String!
}

input KrakenConfigInput {
  apiKey: String!
  apiSecret: String!
}

input PassphraseExchangeConfigInput {
  apiKey: String!
  apiSecret: String!
  passphrase: String!
}

input BybitConfigInput {
  apiKey: String!
  apiSecret: String!
}

input BitfinexConfigInput {
  apiKey: String!
  apiSecret: String!
}

# Union-like input for exchange configuration
input ExchangeConfigInput {
  binance: BinanceConfigInput
  binanceus: BinanceConfigInput
  coinbase: PassphraseExchangeConfigInput
  kraken: KrakenConfigInput
  kucoin: PassphraseExchangeConfigInput
  bybit: BybitConfigInput
  okx: PassphraseExchangeConfigInput
  bitfinex: BitfinexConfigInput
}

# Bot runner status from the runner
type BotStatus {
  botID: String!
  status: BotBotStatus!
  healthy: Boolean!
  lastSeenAt: Time
  cpuUsage: Float!
  memoryUsage: Int!
  ipAddress: String!
  hostPort: Int!
  errorMessage: String!
  createdAt: Time!
  startedAt: Time
  stoppedAt: Time
}

# Type extensions

# Backtest result summary for type-safe access to common metrics
# Mapped to internal/backtest.BacktestSummary via gqlgen autobind
type BacktestSummary {
  strategyName: String!
  totalTrades: Int!
  wins: Int!
  losses: Int!
  profitTotalAbs: Float!
  profitTotal: Float!
  profitMean: Float
  winRate: Float
  maxDrawdown: Float
  profitFactor: Float
  expectancy: Float
  sharpe: Float
  sortino: Float
  calmar: Float
  avgStakeAmount: Float
  stakeCurrency: String!
  backtestStart: Time
  backtestEnd: Time
  backtestDays: Int
}

# Extend Backtest with typed summary field
extend type Backtest {
  """
  Typed summary of key backtest metrics extracted from result
  """
  summary: BacktestSummary
}

# Note: Strategy field-level authorization is applied via ENT schema annotations
# See: internal/ent/schema/strategy.go - code and config fields use RequiresPermission("view")

# Connection test result
type ConnectionTestResult {
  success: Boolean!
  message: String!
  version: String
}

# Freqtrade API token for FreqUI authentication
# Used to pre-authenticate FreqUI iframe without exposing credentials
type FreqtradeToken {
  """
  The bot API URL to connect to
  """
  apiUrl: String!
  """
  Username for the bot API
  """
  username: String!
  """
  JWT access token for bot API authentication
  """
  accessToken: String!
  """
  JWT refresh token for renewing access
  """
  refreshToken: String!
}

# Query extensions
# Note: ENT-generated list queries (exchanges, strategies, bots, botRunners, backtests) are defined in ent.graphql
# Those queries already have @isAuthenticated checks in resolvers and require ownerID in where clause for authorization

extend type Query {
  # Get runner status for a bot
  getBotRunnerStatus(id: ID!): BotStatus @hasScope(resource: "id", scope: "view")

  # Strategy versioning queries
  """
  Get all versions of a strategy by name (for version history view)
  """
  strategyVersions(name: String!): [Strategy!]! @isAuthenticated
}

# Mutations for managing entities
type Mutation {
  # Exchange mutations
  createExchange(input: CreateExchangeInput!): Exchange! @isAuthenticated
  updateExchange(id: ID!, input: UpdateExchangeInput!): Exchange! @hasScope(resource: "id", scope: "edit")
  deleteExchange(id: ID!): Boolean! @hasScope(resource: "id", scope: "delete")

  # Strategy mutations
  createStrategy(input: CreateStrategyInput!): Strategy! @isAuthenticated
  updateStrategy(id: ID!, input: UpdateStrategyInput!): Strategy! @hasScope(resource: "id", scope: "edit")
  deleteStrategy(id: ID!): Boolean! @hasScope(resource: "id", scope: "delete")

  # Bot mutations
  createBot(input: CreateBotInput!): Bot! @isAuthenticated
  updateBot(id: ID!, input: UpdateBotInput!): Bot! @hasScope(resource: "id", scope: "edit")
  deleteBot(id: ID!): Boolean! @hasScope(resource: "id", scope: "delete")

  # Bot lifecycle mutations
  startBot(id: ID!): Bot! @hasScope(resource: "id", scope: "run")
  stopBot(id: ID!): Bot! @hasScope(resource: "id", scope: "stop")
  restartBot(id: ID!): Bot! @hasScope(resource: "id", scope: "run")

  # BotRunner mutations
  createBotRunner(input: CreateBotRunnerInput!): BotRunner! @isAuthenticated
  updateBotRunner(id: ID!, input: UpdateBotRunnerInput!): BotRunner! @hasScope(resource: "id", scope: "edit")
  deleteBotRunner(id: ID!): Boolean! @hasScope(resource: "id", scope: "delete")

  # Runner data management
  refreshRunnerData(id: ID!): BotRunner! @hasScope(resource: "id", scope: "edit")

  # Runner connection testing
  testRunnerConnection(type: BotRunnerRunnerType!, config: RunnerConfigInput!): ConnectionTestResult! @isAuthenticated

  # S3 connection testing
  """
  Test S3 storage connection
  Verifies endpoint accessibility and bucket existence
  """
  testS3Connection(config: S3ConfigInput!): ConnectionTestResult! @isAuthenticated

  # Backtest mutations
  # Backtests are immutable - only creation is allowed, no updates
  # Authorization is checked via strategy_id (backtests inherit permissions from their parent strategy)
  runBacktest(input: CreateBacktestInput!): Backtest! @hasScope(resource: "input.strategyID", scope: "run-backtest")
  stopBacktest(id: ID!): Backtest! @hasScope(resource: "id", scope: "stop-backtest")
  deleteBacktest(id: ID!): Boolean! @hasScope(resource: "id", scope: "delete-backtest")

  # Trade mutations
  createTrade(input: CreateTradeInput!): Trade! @isAuthenticated
  updateTrade(id: ID!, input: UpdateTradeInput!): Trade! @hasScope(resource: "id", scope: "edit")
  deleteTrade(id: ID!): Boolean! @hasScope(resource: "id", scope: "delete")

  # Visibility mutations
  """
  Toggle strategy visibility (public/private)
  Only the owner can change visibility
  """
  setStrategyVisibility(id: ID!, public: Boolean!): Strategy! @hasScope(resource: "id", scope: "edit")

  """
  Toggle bot visibility (public/private)
  Only the owner can change visibility
  """
  setBotVisibility(id: ID!, public: Boolean!): Bot! @hasScope(resource: "id", scope: "edit")

  """
  Toggle runner visibility (public/private)
  Only the owner can change visibility
  """
  setRunnerVisibility(id: ID!, public: Boolean!): BotRunner! @hasScope(resource: "id", scope: "edit")

  # FreqUI integration
  """
  Get Freqtrade API token for a bot (for FreqUI authentication)
  Backend authenticates with bot API and returns JWT tokens
  This avoids exposing bot credentials to the frontend
  """
  getFreqtradeToken(botId: ID!): FreqtradeToken! @hasScope(resource: "botId", scope: "freqtrade-api")
}

# Resource Usage Extensions
# Note: Base types (ResourceUsageSample, ResourceUsageAggregation) and list queries
# (resourceUsageSamples, resourceUsageAggregations) are ENT-generated in ent.graphql

"""
Estimated cost breakdown for resource usage
Uses runner-specific pricing rates
"""
type UsageCost {
  """
  Cost for CPU usage (core-hours * rate)
  """
  cpuCost: Float!
  """
  Cost for memory usage (GB-hours * rate)
  """
  memoryCost: Float!
  """
  Cost for network transfer (GB * rate)
  """
  networkCost: Float!
  """
  Cost for disk I/O (GB * rate)
  """
  storageCost: Float!
  """
  Total estimated cost
  """
  totalCost: Float!
  """
  Currency for the cost
  """
  currency: String!
}

# Extend Bot with usage convenience fields
extend type Bot {
  """
  Usage summary for the last 24 hours
  Aggregated from ResourceUsageAggregation if available, or calculated from samples
  Only populated if the bot runs on a runner with billing enabled
  """
  recentUsage: ResourceUsageAggregation
}

# Extend Backtest with usage convenience field
extend type Backtest {
  """
  Total resource usage for this backtest execution
  Only populated if the backtest ran on a runner with billing enabled
  """
  resourceUsage: ResourceUsageAggregation
}

# Usage query extensions
extend type Query {
  """
  Get total usage for an organization over a time range
  Aggregates all resources (bots and backtests) owned by the organization
  """
  organizationUsage(ownerID: String!, start: Time!, end: Time!): ResourceUsageAggregation @isAuthenticated

  """
  Calculate estimated cost for usage over a time range
  Uses runner-specific pricing rates
  """
  estimatedCost(ownerID: String!, start: Time!, end: Time!): UsageCost! @isAuthenticated

  """
  Get usage history for a bot over a time range
  Returns time-series data for charts (granularity depends on aggregation settings)
  """
  botUsageHistory(botID: ID!, start: Time!, end: Time!): [ResourceUsageAggregation!]! @hasScope(resource: "botID", scope: "view")
}

# Alert System Extensions
# Note: Base types (AlertRule, AlertEvent) and list queries are ENT-generated in ent.graphql
# Create/Update/Delete mutations are defined here for authorization control

extend type Mutation {
  # Alert Rule mutations
  """
  Create a new alert rule
  """
  createAlertRule(input: CreateAlertRuleInput!): AlertRule! @isAuthenticated

  """
  Update an existing alert rule
  """
  updateAlertRule(id: ID!, input: UpdateAlertRuleInput!): AlertRule! @isAuthenticated

  """
  Toggle alert rule enabled/disabled state
  Quick toggle without full update
  """
  toggleAlertRule(id: ID!, enabled: Boolean!): AlertRule! @isAuthenticated

  """
  Delete an alert rule (soft delete)
  Associated events are preserved for audit
  """
  deleteAlertRule(id: ID!): Boolean! @isAuthenticated

  """
  Test an alert rule by simulating an event
  Sends a test alert to configured recipients
  """
  testAlertRule(id: ID!): Boolean! @isAuthenticated

  # Alert Event mutations
  """
  Mark a single alert event as read
  Sets readAt to current timestamp
  Only marks alert if it belongs to the specified organization
  """
  markAlertEventAsRead(id: ID!, ownerID: String!): AlertEvent! @hasScope(resource: "ownerID", scope: "mark-alert-as-read")

  """
  Mark all unread alert events as read for an organization
  Returns the count of events marked as read
  """
  markAllAlertEventsAsRead(ownerID: String!): Int! @hasScope(resource: "ownerID", scope: "mark-alert-as-read")
}

# Alert Type Metadata Types
# Used to dynamically show available alert types based on selected resource

"""
Type of condition field for alert configuration
"""
enum ConditionFieldType {
  number
  select
  multi_select
}

"""
Option for select/multi_select condition fields
"""
type SelectOption {
  value: String!
  label: String!
}

"""
Describes a configurable condition field for an alert type
"""
type ConditionField {
  name: String!
  label: String!
  type: ConditionFieldType!
  required: Boolean!
  description: String!
  """
  For number fields: minimum value
  """
  min: Float
  """
  For number fields: maximum value
  """
  max: Float
  """
  For number fields: default value
  """
  default: Float
  """
  For number fields: unit label (e.g., "%", "minutes")
  """
  unit: String
  """
  For select/multi_select fields: available options
  """
  options: [SelectOption!]
}

"""
Metadata about an alert type including available condition fields
"""
type AlertTypeInfo {
  type: AlertRuleAlertType!
  label: String!
  description: String!
  defaultSeverity: AlertRuleAlertSeverity!
  conditionFields: [ConditionField!]!
}

extend type Query {
  """
  Get available alert types for a resource
  Returns alert types that can be configured for the given resource type
  The resourceID is optional and reserved for future smart filtering
  """
  alertTypesForResource(
    resourceType: AlertRuleAlertResourceType!
    resourceID: ID
  ): [AlertTypeInfo!]! @isAuthenticated
}

# Permission checking for frontend authorization
# Used by dashboard to check multiple permissions in a single request
# Triggers self-healing if resource scopes are out of sync

"""
Input for checking a single permission
"""
input PermissionCheckInput {
  """
  The resource ID (UUID) to check permission for
  """
  resourceId: ID!
  """
  The scope to check (e.g., "edit", "delete", "run")
  """
  scope: String!
}

"""
Result of a permission check
"""
type PermissionCheckResult {
  """
  The resource ID that was checked
  """
  resourceId: ID!
  """
  The scope that was checked
  """
  scope: String!
  """
  Whether the permission is granted
  """
  granted: Boolean!
}

extend type Query {
  """
  Check multiple permissions in a single request
  Returns granted permissions for each resource/scope pair
  Triggers self-healing if resource scopes are out of sync in Keycloak
  """
  checkPermissions(permissions: [PermissionCheckInput!]!): [PermissionCheckResult!]! @isAuthenticated
}

# Organization User Management
# Uses Keycloak Admin API to fetch users from organization groups

"""
User in the organization (from Keycloak)
"""
type OrganizationUser {
  """
  User ID (Keycloak UUID)
  """
  id: ID!
  """
  Username
  """
  username: String!
  """
  Email address
  """
  email: String
  """
  Whether the email is verified
  """
  emailVerified: Boolean!
  """
  First name
  """
  firstName: String
  """
  Last name
  """
  lastName: String
  """
  Whether the user account is enabled
  """
  enabled: Boolean!
  """
  User creation timestamp (Unix milliseconds)
  """
  createdAt: Time!
}

type GroupNode {
  id: ID!
  name: String!
  path: String!
  type: String!
  title: String!
  children: [GroupNode!]!
}

# Resource Group Management (uses Keycloak extension endpoints)

"""
Role information with member count
"""
type RoleInfo {
  """
  Role name (e.g., "admin", "viewer")
  """
  name: String!
  """
  Number of members with this role
  """
  memberCount: Int!
}

"""
Resource group with normalized role data
Represents strategies, bots, and other resources under an organization
"""
type ResourceGroup {
  """
  Resource group name (our resource UUID)
  """
  name: String!
  """
  Resource group path (hierarchical)
  """
  path: String!
  """
  Display title (from GROUP_TITLE attribute)
  """
  title: String!
  """
  Resource type (from GROUP_TYPE attribute)
  Values: "strategy", "bot", "exchange", "runner", "organization", "none"
  """
  type: String!
  """
  List of roles with member counts
  """
  roles: [RoleInfo!]!
  """
  Total number of members across all roles
  """
  totalMembers: Int!
  """
  Whether this resource group has child resource groups
  """
  hasChildren: Boolean!
}

"""
Edge for resource group connection
"""
type ResourceGroupEdge {
  """
  Resource group node
  """
  node: ResourceGroup!
  """
  Cursor for pagination
  """
  cursor: String!
}

"""
Paginated resource group connection
"""
type ResourceGroupConnection {
  """
  Resource group edges
  """
  edges: [ResourceGroupEdge!]!
  """
  Total count of resource groups (before pagination)
  """
  totalCount: Int!
  """
  Pagination info
  """
  pageInfo: PageInfo!
}

"""
User information for resource group members
"""
type MemberUser {
  """
  User ID (Keycloak UUID)
  """
  id: ID!
  """
  Username
  """
  username: String!
  """
  Email address
  """
  email: String
  """
  Whether the email is verified
  """
  emailVerified: Boolean!
  """
  First name
  """
  firstName: String
  """
  Last name
  """
  lastName: String
  """
  Whether the user account is enabled
  """
  enabled: Boolean!
  """
  User creation timestamp
  """
  createdAt: Time!
}

"""
Resource group member with role information
"""
type ResourceGroupMember {
  """
  User information
  """
  user: MemberUser!
  """
  All roles the user has in this resource group
  """
  roles: [String!]!
  """
  Primary role (highest priority: owner > admin > editor > viewer)
  """
  primaryRole: String!
}

"""
Edge for resource group member connection
"""
type ResourceGroupMemberEdge {
  """
  Resource group member node
  """
  node: ResourceGroupMember!
  """
  Cursor for pagination
  """
  cursor: String!
}

"""
Paginated resource group member connection
"""
type ResourceGroupMemberConnection {
  """
  Resource group member edges
  """
  edges: [ResourceGroupMemberEdge!]!
  """
  Total count of members (before pagination)
  """
  totalCount: Int!
  """
  Pagination info
  """
  pageInfo: PageInfo!
}

"""
Filter input for resource groups
"""
input ResourceGroupWhereInput {
  """
  Search by title (case-insensitive substring match)
  """
  titleContainsFold: String
}

"""
Order input for resource groups
"""
input ResourceGroupOrder {
  """
  Field to order by
  """
  field: ResourceGroupOrderField!
  """
  Order direction
  """
  direction: OrderDirection!
}

"""
Resource group order fields
"""
enum ResourceGroupOrderField {
  TITLE
  TOTAL_MEMBERS
}

"""
Filter input for resource group members
"""
input ResourceGroupMemberWhereInput {
  """
  Filter by roles (user must have at least one of these roles)
  """
  roleIn: [String!]
  """
  Search by username, email, firstName, lastName (case-insensitive)
  """
  searchContainsFold: String
  """
  Filter by enabled status
  """
  enabled: Boolean
  """
  Filter by email verified status
  """
  emailVerified: Boolean
}

"""
Order input for resource group members
"""
input ResourceGroupMemberOrder {
  """
  Field to order by
  """
  field: ResourceGroupMemberOrderField!
  """
  Order direction
  """
  direction: OrderDirection!
}

"""
Resource group member order fields
"""
enum ResourceGroupMemberOrderField {
  USERNAME
  EMAIL
  FIRST_NAME
  LAST_NAME
  CREATED_AT
  PRIMARY_ROLE
}

extend type Query {
  """
  Get all users in the organization
  Fetches users from Keycloak group (including subgroups)
  Requires view-users permission on the organization resource
  """
  organizationUsers(organizationId: String!): [OrganizationUser!]! @hasScope(resource: "organizationId", scope: "view-users")

  """
  Get the hierarchical group tree for an organization
  Returns resource groups (inactive) and role subgroups (active)
  Requires view-users permission on the organization resource
  """
  organizationGroupTree(organizationId: String!): GroupNode! @hasScope(resource: "organizationId", scope: "view-users")

  """
  Get users in a specific group (non-recursive)
  Used to fetch members when a role group is selected in the tree
  Requires view-users permission on the organization resource
  """
  groupMembers(organizationId: String!, groupId: String!): [OrganizationUser!]! @hasScope(resource: "organizationId", scope: "view-users")

  """
  Get paginated resource groups for an organization
  Uses Keycloak extension endpoint for efficient server-side filtering, sorting, and pagination
  Requires view-users permission on the organization resource
  """
  resourceGroups(
    organizationId: String!
    where: ResourceGroupWhereInput
    orderBy: ResourceGroupOrder
    first: Int = 20
    offset: Int = 0
  ): ResourceGroupConnection! @hasScope(resource: "organizationId", scope: "view-users")

  """
  Get paginated members for a resource group
  Uses Keycloak extension endpoint for efficient server-side filtering, sorting, and pagination
  Requires view-users permission on the organization resource
  """
  resourceGroupMembers(
    organizationId: String!
    resourceGroupId: String!
    where: ResourceGroupMemberWhereInput
    orderBy: ResourceGroupMemberOrder
    first: Int = 50
    offset: Int = 0
  ): ResourceGroupMemberConnection! @hasScope(resource: "organizationId", scope: "view-users")
}

# Organization Invitation Types

"""
Input for inviting a user to an organization
"""
input InviteUserInput {
  """
  Email address of the user to invite
  """
  email: String!
  """
  First name of the user (optional, used in invitation email)
  """
  firstName: String
  """
  Last name of the user (optional, used in invitation email)
  """
  lastName: String
  """
  URL to redirect to after invitation acceptance (optional).
  Should include the organization path, e.g., "http://localhost:5173/organizations/{orgId}"
  """
  redirectUrl: String
}

"""
Response from invitation operations
"""
type OrganizationInvitation {
  """
  Invitation ID (UUID)
  """
  id: ID!
  """
  Email address of the invited user
  """
  email: String!
  """
  First name of the invited user
  """
  firstName: String
  """
  Last name of the invited user
  """
  lastName: String
  """
  Organization resource ID
  """
  organizationId: ID!
  """
  Invitation status (PENDING, EXPIRED)
  """
  status: String!
  """
  Timestamp when invitation was created (Unix milliseconds)
  """
  createdAt: Time!
  """
  Timestamp when invitation expires (Unix milliseconds)
  """
  expiresAt: Time!
}

extend type Mutation {
  """
  Invite a user to an organization
  Sends an invitation email with a link to join
  Invited users are automatically assigned the 'viewer' role upon acceptance
  Requires invite-user permission on the organization
  """
  inviteOrganizationUser(organizationId: ID!, input: InviteUserInput!): OrganizationInvitation! @hasScope(resource: "organizationId", scope: "invite-user")
}
