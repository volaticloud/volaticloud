// Code generated by ent, DO NOT EDIT.

package ent

import (
	"anytrade/internal/ent/backtest"
	"anytrade/internal/ent/bot"
	"anytrade/internal/ent/exchange"
	"anytrade/internal/ent/exchangesecret"
	"anytrade/internal/ent/hyperopt"
	"anytrade/internal/ent/strategy"
	"anytrade/internal/ent/trade"
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[uuid.UUID]
	PageInfo       = entgql.PageInfo[uuid.UUID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// BacktestEdge is the edge representation of Backtest.
type BacktestEdge struct {
	Node   *Backtest `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// BacktestConnection is the connection containing edges to Backtest.
type BacktestConnection struct {
	Edges      []*BacktestEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *BacktestConnection) build(nodes []*Backtest, pager *backtestPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Backtest
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Backtest {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Backtest {
			return nodes[i]
		}
	}
	c.Edges = make([]*BacktestEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BacktestEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BacktestPaginateOption enables pagination customization.
type BacktestPaginateOption func(*backtestPager) error

// WithBacktestOrder configures pagination ordering.
func WithBacktestOrder(order *BacktestOrder) BacktestPaginateOption {
	if order == nil {
		order = DefaultBacktestOrder
	}
	o := *order
	return func(pager *backtestPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBacktestOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBacktestFilter configures pagination filter.
func WithBacktestFilter(filter func(*BacktestQuery) (*BacktestQuery, error)) BacktestPaginateOption {
	return func(pager *backtestPager) error {
		if filter == nil {
			return errors.New("BacktestQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type backtestPager struct {
	reverse bool
	order   *BacktestOrder
	filter  func(*BacktestQuery) (*BacktestQuery, error)
}

func newBacktestPager(opts []BacktestPaginateOption, reverse bool) (*backtestPager, error) {
	pager := &backtestPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBacktestOrder
	}
	return pager, nil
}

func (p *backtestPager) applyFilter(query *BacktestQuery) (*BacktestQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *backtestPager) toCursor(_m *Backtest) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *backtestPager) applyCursors(query *BacktestQuery, after, before *Cursor) (*BacktestQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBacktestOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *backtestPager) applyOrder(query *BacktestQuery) *BacktestQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBacktestOrder.Field {
		query = query.Order(DefaultBacktestOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *backtestPager) orderExpr(query *BacktestQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBacktestOrder.Field {
			b.Comma().Ident(DefaultBacktestOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Backtest.
func (_m *BacktestQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BacktestPaginateOption,
) (*BacktestConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBacktestPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &BacktestConnection{Edges: []*BacktestEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BacktestOrderField defines the ordering field of Backtest.
type BacktestOrderField struct {
	// Value extracts the ordering value from the given Backtest.
	Value    func(*Backtest) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) backtest.OrderOption
	toCursor func(*Backtest) Cursor
}

// BacktestOrder defines the ordering of Backtest.
type BacktestOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *BacktestOrderField `json:"field"`
}

// DefaultBacktestOrder is the default ordering of Backtest.
var DefaultBacktestOrder = &BacktestOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BacktestOrderField{
		Value: func(_m *Backtest) (ent.Value, error) {
			return _m.ID, nil
		},
		column: backtest.FieldID,
		toTerm: backtest.ByID,
		toCursor: func(_m *Backtest) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Backtest into BacktestEdge.
func (_m *Backtest) ToEdge(order *BacktestOrder) *BacktestEdge {
	if order == nil {
		order = DefaultBacktestOrder
	}
	return &BacktestEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// BotEdge is the edge representation of Bot.
type BotEdge struct {
	Node   *Bot   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// BotConnection is the connection containing edges to Bot.
type BotConnection struct {
	Edges      []*BotEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *BotConnection) build(nodes []*Bot, pager *botPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Bot
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Bot {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Bot {
			return nodes[i]
		}
	}
	c.Edges = make([]*BotEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BotEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BotPaginateOption enables pagination customization.
type BotPaginateOption func(*botPager) error

// WithBotOrder configures pagination ordering.
func WithBotOrder(order *BotOrder) BotPaginateOption {
	if order == nil {
		order = DefaultBotOrder
	}
	o := *order
	return func(pager *botPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBotOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBotFilter configures pagination filter.
func WithBotFilter(filter func(*BotQuery) (*BotQuery, error)) BotPaginateOption {
	return func(pager *botPager) error {
		if filter == nil {
			return errors.New("BotQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type botPager struct {
	reverse bool
	order   *BotOrder
	filter  func(*BotQuery) (*BotQuery, error)
}

func newBotPager(opts []BotPaginateOption, reverse bool) (*botPager, error) {
	pager := &botPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBotOrder
	}
	return pager, nil
}

func (p *botPager) applyFilter(query *BotQuery) (*BotQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *botPager) toCursor(_m *Bot) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *botPager) applyCursors(query *BotQuery, after, before *Cursor) (*BotQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBotOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *botPager) applyOrder(query *BotQuery) *BotQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBotOrder.Field {
		query = query.Order(DefaultBotOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *botPager) orderExpr(query *BotQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBotOrder.Field {
			b.Comma().Ident(DefaultBotOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Bot.
func (_m *BotQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BotPaginateOption,
) (*BotConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBotPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &BotConnection{Edges: []*BotEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BotOrderField defines the ordering field of Bot.
type BotOrderField struct {
	// Value extracts the ordering value from the given Bot.
	Value    func(*Bot) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) bot.OrderOption
	toCursor func(*Bot) Cursor
}

// BotOrder defines the ordering of Bot.
type BotOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *BotOrderField `json:"field"`
}

// DefaultBotOrder is the default ordering of Bot.
var DefaultBotOrder = &BotOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BotOrderField{
		Value: func(_m *Bot) (ent.Value, error) {
			return _m.ID, nil
		},
		column: bot.FieldID,
		toTerm: bot.ByID,
		toCursor: func(_m *Bot) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Bot into BotEdge.
func (_m *Bot) ToEdge(order *BotOrder) *BotEdge {
	if order == nil {
		order = DefaultBotOrder
	}
	return &BotEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ExchangeEdge is the edge representation of Exchange.
type ExchangeEdge struct {
	Node   *Exchange `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ExchangeConnection is the connection containing edges to Exchange.
type ExchangeConnection struct {
	Edges      []*ExchangeEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ExchangeConnection) build(nodes []*Exchange, pager *exchangePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Exchange
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Exchange {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Exchange {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExchangeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExchangeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExchangePaginateOption enables pagination customization.
type ExchangePaginateOption func(*exchangePager) error

// WithExchangeOrder configures pagination ordering.
func WithExchangeOrder(order *ExchangeOrder) ExchangePaginateOption {
	if order == nil {
		order = DefaultExchangeOrder
	}
	o := *order
	return func(pager *exchangePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExchangeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExchangeFilter configures pagination filter.
func WithExchangeFilter(filter func(*ExchangeQuery) (*ExchangeQuery, error)) ExchangePaginateOption {
	return func(pager *exchangePager) error {
		if filter == nil {
			return errors.New("ExchangeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exchangePager struct {
	reverse bool
	order   *ExchangeOrder
	filter  func(*ExchangeQuery) (*ExchangeQuery, error)
}

func newExchangePager(opts []ExchangePaginateOption, reverse bool) (*exchangePager, error) {
	pager := &exchangePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExchangeOrder
	}
	return pager, nil
}

func (p *exchangePager) applyFilter(query *ExchangeQuery) (*ExchangeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exchangePager) toCursor(_m *Exchange) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *exchangePager) applyCursors(query *ExchangeQuery, after, before *Cursor) (*ExchangeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultExchangeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *exchangePager) applyOrder(query *ExchangeQuery) *ExchangeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultExchangeOrder.Field {
		query = query.Order(DefaultExchangeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *exchangePager) orderExpr(query *ExchangeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultExchangeOrder.Field {
			b.Comma().Ident(DefaultExchangeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Exchange.
func (_m *ExchangeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExchangePaginateOption,
) (*ExchangeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExchangePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ExchangeConnection{Edges: []*ExchangeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ExchangeOrderField defines the ordering field of Exchange.
type ExchangeOrderField struct {
	// Value extracts the ordering value from the given Exchange.
	Value    func(*Exchange) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) exchange.OrderOption
	toCursor func(*Exchange) Cursor
}

// ExchangeOrder defines the ordering of Exchange.
type ExchangeOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ExchangeOrderField `json:"field"`
}

// DefaultExchangeOrder is the default ordering of Exchange.
var DefaultExchangeOrder = &ExchangeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ExchangeOrderField{
		Value: func(_m *Exchange) (ent.Value, error) {
			return _m.ID, nil
		},
		column: exchange.FieldID,
		toTerm: exchange.ByID,
		toCursor: func(_m *Exchange) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Exchange into ExchangeEdge.
func (_m *Exchange) ToEdge(order *ExchangeOrder) *ExchangeEdge {
	if order == nil {
		order = DefaultExchangeOrder
	}
	return &ExchangeEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ExchangeSecretEdge is the edge representation of ExchangeSecret.
type ExchangeSecretEdge struct {
	Node   *ExchangeSecret `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ExchangeSecretConnection is the connection containing edges to ExchangeSecret.
type ExchangeSecretConnection struct {
	Edges      []*ExchangeSecretEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ExchangeSecretConnection) build(nodes []*ExchangeSecret, pager *exchangesecretPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ExchangeSecret
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ExchangeSecret {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ExchangeSecret {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExchangeSecretEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExchangeSecretEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExchangeSecretPaginateOption enables pagination customization.
type ExchangeSecretPaginateOption func(*exchangesecretPager) error

// WithExchangeSecretOrder configures pagination ordering.
func WithExchangeSecretOrder(order *ExchangeSecretOrder) ExchangeSecretPaginateOption {
	if order == nil {
		order = DefaultExchangeSecretOrder
	}
	o := *order
	return func(pager *exchangesecretPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExchangeSecretOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExchangeSecretFilter configures pagination filter.
func WithExchangeSecretFilter(filter func(*ExchangeSecretQuery) (*ExchangeSecretQuery, error)) ExchangeSecretPaginateOption {
	return func(pager *exchangesecretPager) error {
		if filter == nil {
			return errors.New("ExchangeSecretQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exchangesecretPager struct {
	reverse bool
	order   *ExchangeSecretOrder
	filter  func(*ExchangeSecretQuery) (*ExchangeSecretQuery, error)
}

func newExchangeSecretPager(opts []ExchangeSecretPaginateOption, reverse bool) (*exchangesecretPager, error) {
	pager := &exchangesecretPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExchangeSecretOrder
	}
	return pager, nil
}

func (p *exchangesecretPager) applyFilter(query *ExchangeSecretQuery) (*ExchangeSecretQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exchangesecretPager) toCursor(_m *ExchangeSecret) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *exchangesecretPager) applyCursors(query *ExchangeSecretQuery, after, before *Cursor) (*ExchangeSecretQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultExchangeSecretOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *exchangesecretPager) applyOrder(query *ExchangeSecretQuery) *ExchangeSecretQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultExchangeSecretOrder.Field {
		query = query.Order(DefaultExchangeSecretOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *exchangesecretPager) orderExpr(query *ExchangeSecretQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultExchangeSecretOrder.Field {
			b.Comma().Ident(DefaultExchangeSecretOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ExchangeSecret.
func (_m *ExchangeSecretQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExchangeSecretPaginateOption,
) (*ExchangeSecretConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExchangeSecretPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ExchangeSecretConnection{Edges: []*ExchangeSecretEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ExchangeSecretOrderField defines the ordering field of ExchangeSecret.
type ExchangeSecretOrderField struct {
	// Value extracts the ordering value from the given ExchangeSecret.
	Value    func(*ExchangeSecret) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) exchangesecret.OrderOption
	toCursor func(*ExchangeSecret) Cursor
}

// ExchangeSecretOrder defines the ordering of ExchangeSecret.
type ExchangeSecretOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ExchangeSecretOrderField `json:"field"`
}

// DefaultExchangeSecretOrder is the default ordering of ExchangeSecret.
var DefaultExchangeSecretOrder = &ExchangeSecretOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ExchangeSecretOrderField{
		Value: func(_m *ExchangeSecret) (ent.Value, error) {
			return _m.ID, nil
		},
		column: exchangesecret.FieldID,
		toTerm: exchangesecret.ByID,
		toCursor: func(_m *ExchangeSecret) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ExchangeSecret into ExchangeSecretEdge.
func (_m *ExchangeSecret) ToEdge(order *ExchangeSecretOrder) *ExchangeSecretEdge {
	if order == nil {
		order = DefaultExchangeSecretOrder
	}
	return &ExchangeSecretEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// HyperOptEdge is the edge representation of HyperOpt.
type HyperOptEdge struct {
	Node   *HyperOpt `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// HyperOptConnection is the connection containing edges to HyperOpt.
type HyperOptConnection struct {
	Edges      []*HyperOptEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *HyperOptConnection) build(nodes []*HyperOpt, pager *hyperoptPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HyperOpt
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HyperOpt {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HyperOpt {
			return nodes[i]
		}
	}
	c.Edges = make([]*HyperOptEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HyperOptEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HyperOptPaginateOption enables pagination customization.
type HyperOptPaginateOption func(*hyperoptPager) error

// WithHyperOptOrder configures pagination ordering.
func WithHyperOptOrder(order *HyperOptOrder) HyperOptPaginateOption {
	if order == nil {
		order = DefaultHyperOptOrder
	}
	o := *order
	return func(pager *hyperoptPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHyperOptOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHyperOptFilter configures pagination filter.
func WithHyperOptFilter(filter func(*HyperOptQuery) (*HyperOptQuery, error)) HyperOptPaginateOption {
	return func(pager *hyperoptPager) error {
		if filter == nil {
			return errors.New("HyperOptQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hyperoptPager struct {
	reverse bool
	order   *HyperOptOrder
	filter  func(*HyperOptQuery) (*HyperOptQuery, error)
}

func newHyperOptPager(opts []HyperOptPaginateOption, reverse bool) (*hyperoptPager, error) {
	pager := &hyperoptPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHyperOptOrder
	}
	return pager, nil
}

func (p *hyperoptPager) applyFilter(query *HyperOptQuery) (*HyperOptQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hyperoptPager) toCursor(_m *HyperOpt) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *hyperoptPager) applyCursors(query *HyperOptQuery, after, before *Cursor) (*HyperOptQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHyperOptOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hyperoptPager) applyOrder(query *HyperOptQuery) *HyperOptQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHyperOptOrder.Field {
		query = query.Order(DefaultHyperOptOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hyperoptPager) orderExpr(query *HyperOptQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHyperOptOrder.Field {
			b.Comma().Ident(DefaultHyperOptOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HyperOpt.
func (_m *HyperOptQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HyperOptPaginateOption,
) (*HyperOptConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHyperOptPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &HyperOptConnection{Edges: []*HyperOptEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// HyperOptOrderField defines the ordering field of HyperOpt.
type HyperOptOrderField struct {
	// Value extracts the ordering value from the given HyperOpt.
	Value    func(*HyperOpt) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hyperopt.OrderOption
	toCursor func(*HyperOpt) Cursor
}

// HyperOptOrder defines the ordering of HyperOpt.
type HyperOptOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *HyperOptOrderField `json:"field"`
}

// DefaultHyperOptOrder is the default ordering of HyperOpt.
var DefaultHyperOptOrder = &HyperOptOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HyperOptOrderField{
		Value: func(_m *HyperOpt) (ent.Value, error) {
			return _m.ID, nil
		},
		column: hyperopt.FieldID,
		toTerm: hyperopt.ByID,
		toCursor: func(_m *HyperOpt) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts HyperOpt into HyperOptEdge.
func (_m *HyperOpt) ToEdge(order *HyperOptOrder) *HyperOptEdge {
	if order == nil {
		order = DefaultHyperOptOrder
	}
	return &HyperOptEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// StrategyEdge is the edge representation of Strategy.
type StrategyEdge struct {
	Node   *Strategy `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// StrategyConnection is the connection containing edges to Strategy.
type StrategyConnection struct {
	Edges      []*StrategyEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *StrategyConnection) build(nodes []*Strategy, pager *strategyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Strategy
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Strategy {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Strategy {
			return nodes[i]
		}
	}
	c.Edges = make([]*StrategyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StrategyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StrategyPaginateOption enables pagination customization.
type StrategyPaginateOption func(*strategyPager) error

// WithStrategyOrder configures pagination ordering.
func WithStrategyOrder(order *StrategyOrder) StrategyPaginateOption {
	if order == nil {
		order = DefaultStrategyOrder
	}
	o := *order
	return func(pager *strategyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStrategyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStrategyFilter configures pagination filter.
func WithStrategyFilter(filter func(*StrategyQuery) (*StrategyQuery, error)) StrategyPaginateOption {
	return func(pager *strategyPager) error {
		if filter == nil {
			return errors.New("StrategyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type strategyPager struct {
	reverse bool
	order   *StrategyOrder
	filter  func(*StrategyQuery) (*StrategyQuery, error)
}

func newStrategyPager(opts []StrategyPaginateOption, reverse bool) (*strategyPager, error) {
	pager := &strategyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStrategyOrder
	}
	return pager, nil
}

func (p *strategyPager) applyFilter(query *StrategyQuery) (*StrategyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *strategyPager) toCursor(_m *Strategy) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *strategyPager) applyCursors(query *StrategyQuery, after, before *Cursor) (*StrategyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStrategyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *strategyPager) applyOrder(query *StrategyQuery) *StrategyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStrategyOrder.Field {
		query = query.Order(DefaultStrategyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *strategyPager) orderExpr(query *StrategyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStrategyOrder.Field {
			b.Comma().Ident(DefaultStrategyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Strategy.
func (_m *StrategyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StrategyPaginateOption,
) (*StrategyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStrategyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &StrategyConnection{Edges: []*StrategyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// StrategyOrderField defines the ordering field of Strategy.
type StrategyOrderField struct {
	// Value extracts the ordering value from the given Strategy.
	Value    func(*Strategy) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) strategy.OrderOption
	toCursor func(*Strategy) Cursor
}

// StrategyOrder defines the ordering of Strategy.
type StrategyOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *StrategyOrderField `json:"field"`
}

// DefaultStrategyOrder is the default ordering of Strategy.
var DefaultStrategyOrder = &StrategyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StrategyOrderField{
		Value: func(_m *Strategy) (ent.Value, error) {
			return _m.ID, nil
		},
		column: strategy.FieldID,
		toTerm: strategy.ByID,
		toCursor: func(_m *Strategy) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Strategy into StrategyEdge.
func (_m *Strategy) ToEdge(order *StrategyOrder) *StrategyEdge {
	if order == nil {
		order = DefaultStrategyOrder
	}
	return &StrategyEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TradeEdge is the edge representation of Trade.
type TradeEdge struct {
	Node   *Trade `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TradeConnection is the connection containing edges to Trade.
type TradeConnection struct {
	Edges      []*TradeEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *TradeConnection) build(nodes []*Trade, pager *tradePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Trade
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Trade {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Trade {
			return nodes[i]
		}
	}
	c.Edges = make([]*TradeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TradeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TradePaginateOption enables pagination customization.
type TradePaginateOption func(*tradePager) error

// WithTradeOrder configures pagination ordering.
func WithTradeOrder(order *TradeOrder) TradePaginateOption {
	if order == nil {
		order = DefaultTradeOrder
	}
	o := *order
	return func(pager *tradePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTradeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTradeFilter configures pagination filter.
func WithTradeFilter(filter func(*TradeQuery) (*TradeQuery, error)) TradePaginateOption {
	return func(pager *tradePager) error {
		if filter == nil {
			return errors.New("TradeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tradePager struct {
	reverse bool
	order   *TradeOrder
	filter  func(*TradeQuery) (*TradeQuery, error)
}

func newTradePager(opts []TradePaginateOption, reverse bool) (*tradePager, error) {
	pager := &tradePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTradeOrder
	}
	return pager, nil
}

func (p *tradePager) applyFilter(query *TradeQuery) (*TradeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tradePager) toCursor(_m *Trade) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *tradePager) applyCursors(query *TradeQuery, after, before *Cursor) (*TradeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTradeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tradePager) applyOrder(query *TradeQuery) *TradeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTradeOrder.Field {
		query = query.Order(DefaultTradeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tradePager) orderExpr(query *TradeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTradeOrder.Field {
			b.Comma().Ident(DefaultTradeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Trade.
func (_m *TradeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TradePaginateOption,
) (*TradeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTradePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TradeConnection{Edges: []*TradeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TradeOrderField defines the ordering field of Trade.
type TradeOrderField struct {
	// Value extracts the ordering value from the given Trade.
	Value    func(*Trade) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trade.OrderOption
	toCursor func(*Trade) Cursor
}

// TradeOrder defines the ordering of Trade.
type TradeOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *TradeOrderField `json:"field"`
}

// DefaultTradeOrder is the default ordering of Trade.
var DefaultTradeOrder = &TradeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TradeOrderField{
		Value: func(_m *Trade) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trade.FieldID,
		toTerm: trade.ByID,
		toCursor: func(_m *Trade) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Trade into TradeEdge.
func (_m *Trade) ToEdge(order *TradeOrder) *TradeEdge {
	if order == nil {
		order = DefaultTradeOrder
	}
	return &TradeEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}
