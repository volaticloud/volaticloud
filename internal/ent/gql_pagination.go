// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"volaticloud/internal/ent/backtest"
	"volaticloud/internal/ent/bot"
	"volaticloud/internal/ent/botmetrics"
	"volaticloud/internal/ent/botrunner"
	"volaticloud/internal/ent/exchange"
	"volaticloud/internal/ent/resourceusageaggregation"
	"volaticloud/internal/ent/resourceusagesample"
	"volaticloud/internal/ent/strategy"
	"volaticloud/internal/ent/trade"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[uuid.UUID]
	PageInfo       = entgql.PageInfo[uuid.UUID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// BacktestEdge is the edge representation of Backtest.
type BacktestEdge struct {
	Node   *Backtest `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// BacktestConnection is the connection containing edges to Backtest.
type BacktestConnection struct {
	Edges      []*BacktestEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *BacktestConnection) build(nodes []*Backtest, pager *backtestPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Backtest
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Backtest {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Backtest {
			return nodes[i]
		}
	}
	c.Edges = make([]*BacktestEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BacktestEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BacktestPaginateOption enables pagination customization.
type BacktestPaginateOption func(*backtestPager) error

// WithBacktestOrder configures pagination ordering.
func WithBacktestOrder(order *BacktestOrder) BacktestPaginateOption {
	if order == nil {
		order = DefaultBacktestOrder
	}
	o := *order
	return func(pager *backtestPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBacktestOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBacktestFilter configures pagination filter.
func WithBacktestFilter(filter func(*BacktestQuery) (*BacktestQuery, error)) BacktestPaginateOption {
	return func(pager *backtestPager) error {
		if filter == nil {
			return errors.New("BacktestQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type backtestPager struct {
	reverse bool
	order   *BacktestOrder
	filter  func(*BacktestQuery) (*BacktestQuery, error)
}

func newBacktestPager(opts []BacktestPaginateOption, reverse bool) (*backtestPager, error) {
	pager := &backtestPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBacktestOrder
	}
	return pager, nil
}

func (p *backtestPager) applyFilter(query *BacktestQuery) (*BacktestQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *backtestPager) toCursor(_m *Backtest) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *backtestPager) applyCursors(query *BacktestQuery, after, before *Cursor) (*BacktestQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBacktestOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *backtestPager) applyOrder(query *BacktestQuery) *BacktestQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBacktestOrder.Field {
		query = query.Order(DefaultBacktestOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *backtestPager) orderExpr(query *BacktestQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBacktestOrder.Field {
			b.Comma().Ident(DefaultBacktestOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Backtest.
func (_m *BacktestQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BacktestPaginateOption,
) (*BacktestConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBacktestPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &BacktestConnection{Edges: []*BacktestEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BacktestOrderField defines the ordering field of Backtest.
type BacktestOrderField struct {
	// Value extracts the ordering value from the given Backtest.
	Value    func(*Backtest) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) backtest.OrderOption
	toCursor func(*Backtest) Cursor
}

// BacktestOrder defines the ordering of Backtest.
type BacktestOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *BacktestOrderField `json:"field"`
}

// DefaultBacktestOrder is the default ordering of Backtest.
var DefaultBacktestOrder = &BacktestOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BacktestOrderField{
		Value: func(_m *Backtest) (ent.Value, error) {
			return _m.ID, nil
		},
		column: backtest.FieldID,
		toTerm: backtest.ByID,
		toCursor: func(_m *Backtest) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Backtest into BacktestEdge.
func (_m *Backtest) ToEdge(order *BacktestOrder) *BacktestEdge {
	if order == nil {
		order = DefaultBacktestOrder
	}
	return &BacktestEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// BotEdge is the edge representation of Bot.
type BotEdge struct {
	Node   *Bot   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// BotConnection is the connection containing edges to Bot.
type BotConnection struct {
	Edges      []*BotEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *BotConnection) build(nodes []*Bot, pager *botPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Bot
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Bot {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Bot {
			return nodes[i]
		}
	}
	c.Edges = make([]*BotEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BotEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BotPaginateOption enables pagination customization.
type BotPaginateOption func(*botPager) error

// WithBotOrder configures pagination ordering.
func WithBotOrder(order *BotOrder) BotPaginateOption {
	if order == nil {
		order = DefaultBotOrder
	}
	o := *order
	return func(pager *botPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBotOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBotFilter configures pagination filter.
func WithBotFilter(filter func(*BotQuery) (*BotQuery, error)) BotPaginateOption {
	return func(pager *botPager) error {
		if filter == nil {
			return errors.New("BotQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type botPager struct {
	reverse bool
	order   *BotOrder
	filter  func(*BotQuery) (*BotQuery, error)
}

func newBotPager(opts []BotPaginateOption, reverse bool) (*botPager, error) {
	pager := &botPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBotOrder
	}
	return pager, nil
}

func (p *botPager) applyFilter(query *BotQuery) (*BotQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *botPager) toCursor(_m *Bot) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *botPager) applyCursors(query *BotQuery, after, before *Cursor) (*BotQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBotOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *botPager) applyOrder(query *BotQuery) *BotQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBotOrder.Field {
		query = query.Order(DefaultBotOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *botPager) orderExpr(query *BotQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBotOrder.Field {
			b.Comma().Ident(DefaultBotOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Bot.
func (_m *BotQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BotPaginateOption,
) (*BotConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBotPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &BotConnection{Edges: []*BotEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BotOrderField defines the ordering field of Bot.
type BotOrderField struct {
	// Value extracts the ordering value from the given Bot.
	Value    func(*Bot) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) bot.OrderOption
	toCursor func(*Bot) Cursor
}

// BotOrder defines the ordering of Bot.
type BotOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *BotOrderField `json:"field"`
}

// DefaultBotOrder is the default ordering of Bot.
var DefaultBotOrder = &BotOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BotOrderField{
		Value: func(_m *Bot) (ent.Value, error) {
			return _m.ID, nil
		},
		column: bot.FieldID,
		toTerm: bot.ByID,
		toCursor: func(_m *Bot) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Bot into BotEdge.
func (_m *Bot) ToEdge(order *BotOrder) *BotEdge {
	if order == nil {
		order = DefaultBotOrder
	}
	return &BotEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// BotMetricsEdge is the edge representation of BotMetrics.
type BotMetricsEdge struct {
	Node   *BotMetrics `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// BotMetricsConnection is the connection containing edges to BotMetrics.
type BotMetricsConnection struct {
	Edges      []*BotMetricsEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *BotMetricsConnection) build(nodes []*BotMetrics, pager *botmetricsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BotMetrics
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BotMetrics {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BotMetrics {
			return nodes[i]
		}
	}
	c.Edges = make([]*BotMetricsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BotMetricsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BotMetricsPaginateOption enables pagination customization.
type BotMetricsPaginateOption func(*botmetricsPager) error

// WithBotMetricsOrder configures pagination ordering.
func WithBotMetricsOrder(order *BotMetricsOrder) BotMetricsPaginateOption {
	if order == nil {
		order = DefaultBotMetricsOrder
	}
	o := *order
	return func(pager *botmetricsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBotMetricsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBotMetricsFilter configures pagination filter.
func WithBotMetricsFilter(filter func(*BotMetricsQuery) (*BotMetricsQuery, error)) BotMetricsPaginateOption {
	return func(pager *botmetricsPager) error {
		if filter == nil {
			return errors.New("BotMetricsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type botmetricsPager struct {
	reverse bool
	order   *BotMetricsOrder
	filter  func(*BotMetricsQuery) (*BotMetricsQuery, error)
}

func newBotMetricsPager(opts []BotMetricsPaginateOption, reverse bool) (*botmetricsPager, error) {
	pager := &botmetricsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBotMetricsOrder
	}
	return pager, nil
}

func (p *botmetricsPager) applyFilter(query *BotMetricsQuery) (*BotMetricsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *botmetricsPager) toCursor(_m *BotMetrics) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *botmetricsPager) applyCursors(query *BotMetricsQuery, after, before *Cursor) (*BotMetricsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBotMetricsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *botmetricsPager) applyOrder(query *BotMetricsQuery) *BotMetricsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBotMetricsOrder.Field {
		query = query.Order(DefaultBotMetricsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *botmetricsPager) orderExpr(query *BotMetricsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBotMetricsOrder.Field {
			b.Comma().Ident(DefaultBotMetricsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to BotMetrics.
func (_m *BotMetricsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BotMetricsPaginateOption,
) (*BotMetricsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBotMetricsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &BotMetricsConnection{Edges: []*BotMetricsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BotMetricsOrderField defines the ordering field of BotMetrics.
type BotMetricsOrderField struct {
	// Value extracts the ordering value from the given BotMetrics.
	Value    func(*BotMetrics) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) botmetrics.OrderOption
	toCursor func(*BotMetrics) Cursor
}

// BotMetricsOrder defines the ordering of BotMetrics.
type BotMetricsOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *BotMetricsOrderField `json:"field"`
}

// DefaultBotMetricsOrder is the default ordering of BotMetrics.
var DefaultBotMetricsOrder = &BotMetricsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BotMetricsOrderField{
		Value: func(_m *BotMetrics) (ent.Value, error) {
			return _m.ID, nil
		},
		column: botmetrics.FieldID,
		toTerm: botmetrics.ByID,
		toCursor: func(_m *BotMetrics) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts BotMetrics into BotMetricsEdge.
func (_m *BotMetrics) ToEdge(order *BotMetricsOrder) *BotMetricsEdge {
	if order == nil {
		order = DefaultBotMetricsOrder
	}
	return &BotMetricsEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// BotRunnerEdge is the edge representation of BotRunner.
type BotRunnerEdge struct {
	Node   *BotRunner `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// BotRunnerConnection is the connection containing edges to BotRunner.
type BotRunnerConnection struct {
	Edges      []*BotRunnerEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *BotRunnerConnection) build(nodes []*BotRunner, pager *botrunnerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BotRunner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BotRunner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BotRunner {
			return nodes[i]
		}
	}
	c.Edges = make([]*BotRunnerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BotRunnerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BotRunnerPaginateOption enables pagination customization.
type BotRunnerPaginateOption func(*botrunnerPager) error

// WithBotRunnerOrder configures pagination ordering.
func WithBotRunnerOrder(order *BotRunnerOrder) BotRunnerPaginateOption {
	if order == nil {
		order = DefaultBotRunnerOrder
	}
	o := *order
	return func(pager *botrunnerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBotRunnerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBotRunnerFilter configures pagination filter.
func WithBotRunnerFilter(filter func(*BotRunnerQuery) (*BotRunnerQuery, error)) BotRunnerPaginateOption {
	return func(pager *botrunnerPager) error {
		if filter == nil {
			return errors.New("BotRunnerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type botrunnerPager struct {
	reverse bool
	order   *BotRunnerOrder
	filter  func(*BotRunnerQuery) (*BotRunnerQuery, error)
}

func newBotRunnerPager(opts []BotRunnerPaginateOption, reverse bool) (*botrunnerPager, error) {
	pager := &botrunnerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBotRunnerOrder
	}
	return pager, nil
}

func (p *botrunnerPager) applyFilter(query *BotRunnerQuery) (*BotRunnerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *botrunnerPager) toCursor(_m *BotRunner) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *botrunnerPager) applyCursors(query *BotRunnerQuery, after, before *Cursor) (*BotRunnerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBotRunnerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *botrunnerPager) applyOrder(query *BotRunnerQuery) *BotRunnerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBotRunnerOrder.Field {
		query = query.Order(DefaultBotRunnerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *botrunnerPager) orderExpr(query *BotRunnerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBotRunnerOrder.Field {
			b.Comma().Ident(DefaultBotRunnerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to BotRunner.
func (_m *BotRunnerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BotRunnerPaginateOption,
) (*BotRunnerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBotRunnerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &BotRunnerConnection{Edges: []*BotRunnerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BotRunnerOrderField defines the ordering field of BotRunner.
type BotRunnerOrderField struct {
	// Value extracts the ordering value from the given BotRunner.
	Value    func(*BotRunner) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) botrunner.OrderOption
	toCursor func(*BotRunner) Cursor
}

// BotRunnerOrder defines the ordering of BotRunner.
type BotRunnerOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *BotRunnerOrderField `json:"field"`
}

// DefaultBotRunnerOrder is the default ordering of BotRunner.
var DefaultBotRunnerOrder = &BotRunnerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BotRunnerOrderField{
		Value: func(_m *BotRunner) (ent.Value, error) {
			return _m.ID, nil
		},
		column: botrunner.FieldID,
		toTerm: botrunner.ByID,
		toCursor: func(_m *BotRunner) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts BotRunner into BotRunnerEdge.
func (_m *BotRunner) ToEdge(order *BotRunnerOrder) *BotRunnerEdge {
	if order == nil {
		order = DefaultBotRunnerOrder
	}
	return &BotRunnerEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ExchangeEdge is the edge representation of Exchange.
type ExchangeEdge struct {
	Node   *Exchange `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ExchangeConnection is the connection containing edges to Exchange.
type ExchangeConnection struct {
	Edges      []*ExchangeEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ExchangeConnection) build(nodes []*Exchange, pager *exchangePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Exchange
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Exchange {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Exchange {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExchangeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExchangeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExchangePaginateOption enables pagination customization.
type ExchangePaginateOption func(*exchangePager) error

// WithExchangeOrder configures pagination ordering.
func WithExchangeOrder(order *ExchangeOrder) ExchangePaginateOption {
	if order == nil {
		order = DefaultExchangeOrder
	}
	o := *order
	return func(pager *exchangePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExchangeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExchangeFilter configures pagination filter.
func WithExchangeFilter(filter func(*ExchangeQuery) (*ExchangeQuery, error)) ExchangePaginateOption {
	return func(pager *exchangePager) error {
		if filter == nil {
			return errors.New("ExchangeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exchangePager struct {
	reverse bool
	order   *ExchangeOrder
	filter  func(*ExchangeQuery) (*ExchangeQuery, error)
}

func newExchangePager(opts []ExchangePaginateOption, reverse bool) (*exchangePager, error) {
	pager := &exchangePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExchangeOrder
	}
	return pager, nil
}

func (p *exchangePager) applyFilter(query *ExchangeQuery) (*ExchangeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exchangePager) toCursor(_m *Exchange) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *exchangePager) applyCursors(query *ExchangeQuery, after, before *Cursor) (*ExchangeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultExchangeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *exchangePager) applyOrder(query *ExchangeQuery) *ExchangeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultExchangeOrder.Field {
		query = query.Order(DefaultExchangeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *exchangePager) orderExpr(query *ExchangeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultExchangeOrder.Field {
			b.Comma().Ident(DefaultExchangeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Exchange.
func (_m *ExchangeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExchangePaginateOption,
) (*ExchangeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExchangePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ExchangeConnection{Edges: []*ExchangeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ExchangeOrderField defines the ordering field of Exchange.
type ExchangeOrderField struct {
	// Value extracts the ordering value from the given Exchange.
	Value    func(*Exchange) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) exchange.OrderOption
	toCursor func(*Exchange) Cursor
}

// ExchangeOrder defines the ordering of Exchange.
type ExchangeOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ExchangeOrderField `json:"field"`
}

// DefaultExchangeOrder is the default ordering of Exchange.
var DefaultExchangeOrder = &ExchangeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ExchangeOrderField{
		Value: func(_m *Exchange) (ent.Value, error) {
			return _m.ID, nil
		},
		column: exchange.FieldID,
		toTerm: exchange.ByID,
		toCursor: func(_m *Exchange) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Exchange into ExchangeEdge.
func (_m *Exchange) ToEdge(order *ExchangeOrder) *ExchangeEdge {
	if order == nil {
		order = DefaultExchangeOrder
	}
	return &ExchangeEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ResourceUsageAggregationEdge is the edge representation of ResourceUsageAggregation.
type ResourceUsageAggregationEdge struct {
	Node   *ResourceUsageAggregation `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// ResourceUsageAggregationConnection is the connection containing edges to ResourceUsageAggregation.
type ResourceUsageAggregationConnection struct {
	Edges      []*ResourceUsageAggregationEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *ResourceUsageAggregationConnection) build(nodes []*ResourceUsageAggregation, pager *resourceusageaggregationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ResourceUsageAggregation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ResourceUsageAggregation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ResourceUsageAggregation {
			return nodes[i]
		}
	}
	c.Edges = make([]*ResourceUsageAggregationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ResourceUsageAggregationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ResourceUsageAggregationPaginateOption enables pagination customization.
type ResourceUsageAggregationPaginateOption func(*resourceusageaggregationPager) error

// WithResourceUsageAggregationOrder configures pagination ordering.
func WithResourceUsageAggregationOrder(order *ResourceUsageAggregationOrder) ResourceUsageAggregationPaginateOption {
	if order == nil {
		order = DefaultResourceUsageAggregationOrder
	}
	o := *order
	return func(pager *resourceusageaggregationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultResourceUsageAggregationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithResourceUsageAggregationFilter configures pagination filter.
func WithResourceUsageAggregationFilter(filter func(*ResourceUsageAggregationQuery) (*ResourceUsageAggregationQuery, error)) ResourceUsageAggregationPaginateOption {
	return func(pager *resourceusageaggregationPager) error {
		if filter == nil {
			return errors.New("ResourceUsageAggregationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type resourceusageaggregationPager struct {
	reverse bool
	order   *ResourceUsageAggregationOrder
	filter  func(*ResourceUsageAggregationQuery) (*ResourceUsageAggregationQuery, error)
}

func newResourceUsageAggregationPager(opts []ResourceUsageAggregationPaginateOption, reverse bool) (*resourceusageaggregationPager, error) {
	pager := &resourceusageaggregationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultResourceUsageAggregationOrder
	}
	return pager, nil
}

func (p *resourceusageaggregationPager) applyFilter(query *ResourceUsageAggregationQuery) (*ResourceUsageAggregationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *resourceusageaggregationPager) toCursor(_m *ResourceUsageAggregation) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *resourceusageaggregationPager) applyCursors(query *ResourceUsageAggregationQuery, after, before *Cursor) (*ResourceUsageAggregationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultResourceUsageAggregationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *resourceusageaggregationPager) applyOrder(query *ResourceUsageAggregationQuery) *ResourceUsageAggregationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultResourceUsageAggregationOrder.Field {
		query = query.Order(DefaultResourceUsageAggregationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *resourceusageaggregationPager) orderExpr(query *ResourceUsageAggregationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultResourceUsageAggregationOrder.Field {
			b.Comma().Ident(DefaultResourceUsageAggregationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ResourceUsageAggregation.
func (_m *ResourceUsageAggregationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ResourceUsageAggregationPaginateOption,
) (*ResourceUsageAggregationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newResourceUsageAggregationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ResourceUsageAggregationConnection{Edges: []*ResourceUsageAggregationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ResourceUsageAggregationOrderField defines the ordering field of ResourceUsageAggregation.
type ResourceUsageAggregationOrderField struct {
	// Value extracts the ordering value from the given ResourceUsageAggregation.
	Value    func(*ResourceUsageAggregation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) resourceusageaggregation.OrderOption
	toCursor func(*ResourceUsageAggregation) Cursor
}

// ResourceUsageAggregationOrder defines the ordering of ResourceUsageAggregation.
type ResourceUsageAggregationOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *ResourceUsageAggregationOrderField `json:"field"`
}

// DefaultResourceUsageAggregationOrder is the default ordering of ResourceUsageAggregation.
var DefaultResourceUsageAggregationOrder = &ResourceUsageAggregationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ResourceUsageAggregationOrderField{
		Value: func(_m *ResourceUsageAggregation) (ent.Value, error) {
			return _m.ID, nil
		},
		column: resourceusageaggregation.FieldID,
		toTerm: resourceusageaggregation.ByID,
		toCursor: func(_m *ResourceUsageAggregation) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ResourceUsageAggregation into ResourceUsageAggregationEdge.
func (_m *ResourceUsageAggregation) ToEdge(order *ResourceUsageAggregationOrder) *ResourceUsageAggregationEdge {
	if order == nil {
		order = DefaultResourceUsageAggregationOrder
	}
	return &ResourceUsageAggregationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ResourceUsageSampleEdge is the edge representation of ResourceUsageSample.
type ResourceUsageSampleEdge struct {
	Node   *ResourceUsageSample `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// ResourceUsageSampleConnection is the connection containing edges to ResourceUsageSample.
type ResourceUsageSampleConnection struct {
	Edges      []*ResourceUsageSampleEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *ResourceUsageSampleConnection) build(nodes []*ResourceUsageSample, pager *resourceusagesamplePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ResourceUsageSample
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ResourceUsageSample {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ResourceUsageSample {
			return nodes[i]
		}
	}
	c.Edges = make([]*ResourceUsageSampleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ResourceUsageSampleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ResourceUsageSamplePaginateOption enables pagination customization.
type ResourceUsageSamplePaginateOption func(*resourceusagesamplePager) error

// WithResourceUsageSampleOrder configures pagination ordering.
func WithResourceUsageSampleOrder(order *ResourceUsageSampleOrder) ResourceUsageSamplePaginateOption {
	if order == nil {
		order = DefaultResourceUsageSampleOrder
	}
	o := *order
	return func(pager *resourceusagesamplePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultResourceUsageSampleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithResourceUsageSampleFilter configures pagination filter.
func WithResourceUsageSampleFilter(filter func(*ResourceUsageSampleQuery) (*ResourceUsageSampleQuery, error)) ResourceUsageSamplePaginateOption {
	return func(pager *resourceusagesamplePager) error {
		if filter == nil {
			return errors.New("ResourceUsageSampleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type resourceusagesamplePager struct {
	reverse bool
	order   *ResourceUsageSampleOrder
	filter  func(*ResourceUsageSampleQuery) (*ResourceUsageSampleQuery, error)
}

func newResourceUsageSamplePager(opts []ResourceUsageSamplePaginateOption, reverse bool) (*resourceusagesamplePager, error) {
	pager := &resourceusagesamplePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultResourceUsageSampleOrder
	}
	return pager, nil
}

func (p *resourceusagesamplePager) applyFilter(query *ResourceUsageSampleQuery) (*ResourceUsageSampleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *resourceusagesamplePager) toCursor(_m *ResourceUsageSample) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *resourceusagesamplePager) applyCursors(query *ResourceUsageSampleQuery, after, before *Cursor) (*ResourceUsageSampleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultResourceUsageSampleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *resourceusagesamplePager) applyOrder(query *ResourceUsageSampleQuery) *ResourceUsageSampleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultResourceUsageSampleOrder.Field {
		query = query.Order(DefaultResourceUsageSampleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *resourceusagesamplePager) orderExpr(query *ResourceUsageSampleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultResourceUsageSampleOrder.Field {
			b.Comma().Ident(DefaultResourceUsageSampleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ResourceUsageSample.
func (_m *ResourceUsageSampleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ResourceUsageSamplePaginateOption,
) (*ResourceUsageSampleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newResourceUsageSamplePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ResourceUsageSampleConnection{Edges: []*ResourceUsageSampleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ResourceUsageSampleOrderField defines the ordering field of ResourceUsageSample.
type ResourceUsageSampleOrderField struct {
	// Value extracts the ordering value from the given ResourceUsageSample.
	Value    func(*ResourceUsageSample) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) resourceusagesample.OrderOption
	toCursor func(*ResourceUsageSample) Cursor
}

// ResourceUsageSampleOrder defines the ordering of ResourceUsageSample.
type ResourceUsageSampleOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *ResourceUsageSampleOrderField `json:"field"`
}

// DefaultResourceUsageSampleOrder is the default ordering of ResourceUsageSample.
var DefaultResourceUsageSampleOrder = &ResourceUsageSampleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ResourceUsageSampleOrderField{
		Value: func(_m *ResourceUsageSample) (ent.Value, error) {
			return _m.ID, nil
		},
		column: resourceusagesample.FieldID,
		toTerm: resourceusagesample.ByID,
		toCursor: func(_m *ResourceUsageSample) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ResourceUsageSample into ResourceUsageSampleEdge.
func (_m *ResourceUsageSample) ToEdge(order *ResourceUsageSampleOrder) *ResourceUsageSampleEdge {
	if order == nil {
		order = DefaultResourceUsageSampleOrder
	}
	return &ResourceUsageSampleEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// StrategyEdge is the edge representation of Strategy.
type StrategyEdge struct {
	Node   *Strategy `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// StrategyConnection is the connection containing edges to Strategy.
type StrategyConnection struct {
	Edges      []*StrategyEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *StrategyConnection) build(nodes []*Strategy, pager *strategyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Strategy
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Strategy {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Strategy {
			return nodes[i]
		}
	}
	c.Edges = make([]*StrategyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StrategyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StrategyPaginateOption enables pagination customization.
type StrategyPaginateOption func(*strategyPager) error

// WithStrategyOrder configures pagination ordering.
func WithStrategyOrder(order *StrategyOrder) StrategyPaginateOption {
	if order == nil {
		order = DefaultStrategyOrder
	}
	o := *order
	return func(pager *strategyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStrategyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStrategyFilter configures pagination filter.
func WithStrategyFilter(filter func(*StrategyQuery) (*StrategyQuery, error)) StrategyPaginateOption {
	return func(pager *strategyPager) error {
		if filter == nil {
			return errors.New("StrategyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type strategyPager struct {
	reverse bool
	order   *StrategyOrder
	filter  func(*StrategyQuery) (*StrategyQuery, error)
}

func newStrategyPager(opts []StrategyPaginateOption, reverse bool) (*strategyPager, error) {
	pager := &strategyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStrategyOrder
	}
	return pager, nil
}

func (p *strategyPager) applyFilter(query *StrategyQuery) (*StrategyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *strategyPager) toCursor(_m *Strategy) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *strategyPager) applyCursors(query *StrategyQuery, after, before *Cursor) (*StrategyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStrategyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *strategyPager) applyOrder(query *StrategyQuery) *StrategyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStrategyOrder.Field {
		query = query.Order(DefaultStrategyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *strategyPager) orderExpr(query *StrategyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStrategyOrder.Field {
			b.Comma().Ident(DefaultStrategyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Strategy.
func (_m *StrategyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StrategyPaginateOption,
) (*StrategyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStrategyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &StrategyConnection{Edges: []*StrategyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// StrategyOrderField defines the ordering field of Strategy.
type StrategyOrderField struct {
	// Value extracts the ordering value from the given Strategy.
	Value    func(*Strategy) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) strategy.OrderOption
	toCursor func(*Strategy) Cursor
}

// StrategyOrder defines the ordering of Strategy.
type StrategyOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *StrategyOrderField `json:"field"`
}

// DefaultStrategyOrder is the default ordering of Strategy.
var DefaultStrategyOrder = &StrategyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StrategyOrderField{
		Value: func(_m *Strategy) (ent.Value, error) {
			return _m.ID, nil
		},
		column: strategy.FieldID,
		toTerm: strategy.ByID,
		toCursor: func(_m *Strategy) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Strategy into StrategyEdge.
func (_m *Strategy) ToEdge(order *StrategyOrder) *StrategyEdge {
	if order == nil {
		order = DefaultStrategyOrder
	}
	return &StrategyEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TradeEdge is the edge representation of Trade.
type TradeEdge struct {
	Node   *Trade `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TradeConnection is the connection containing edges to Trade.
type TradeConnection struct {
	Edges      []*TradeEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *TradeConnection) build(nodes []*Trade, pager *tradePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Trade
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Trade {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Trade {
			return nodes[i]
		}
	}
	c.Edges = make([]*TradeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TradeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TradePaginateOption enables pagination customization.
type TradePaginateOption func(*tradePager) error

// WithTradeOrder configures pagination ordering.
func WithTradeOrder(order *TradeOrder) TradePaginateOption {
	if order == nil {
		order = DefaultTradeOrder
	}
	o := *order
	return func(pager *tradePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTradeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTradeFilter configures pagination filter.
func WithTradeFilter(filter func(*TradeQuery) (*TradeQuery, error)) TradePaginateOption {
	return func(pager *tradePager) error {
		if filter == nil {
			return errors.New("TradeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tradePager struct {
	reverse bool
	order   *TradeOrder
	filter  func(*TradeQuery) (*TradeQuery, error)
}

func newTradePager(opts []TradePaginateOption, reverse bool) (*tradePager, error) {
	pager := &tradePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTradeOrder
	}
	return pager, nil
}

func (p *tradePager) applyFilter(query *TradeQuery) (*TradeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tradePager) toCursor(_m *Trade) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *tradePager) applyCursors(query *TradeQuery, after, before *Cursor) (*TradeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTradeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tradePager) applyOrder(query *TradeQuery) *TradeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTradeOrder.Field {
		query = query.Order(DefaultTradeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tradePager) orderExpr(query *TradeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTradeOrder.Field {
			b.Comma().Ident(DefaultTradeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Trade.
func (_m *TradeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TradePaginateOption,
) (*TradeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTradePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TradeConnection{Edges: []*TradeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TradeOrderFieldOpenDate orders Trade by open_date.
	TradeOrderFieldOpenDate = &TradeOrderField{
		Value: func(_m *Trade) (ent.Value, error) {
			return _m.OpenDate, nil
		},
		column: trade.FieldOpenDate,
		toTerm: trade.ByOpenDate,
		toCursor: func(_m *Trade) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.OpenDate,
			}
		},
	}
	// TradeOrderFieldCloseDate orders Trade by close_date.
	TradeOrderFieldCloseDate = &TradeOrderField{
		Value: func(_m *Trade) (ent.Value, error) {
			return _m.CloseDate, nil
		},
		column: trade.FieldCloseDate,
		toTerm: trade.ByCloseDate,
		toCursor: func(_m *Trade) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CloseDate,
			}
		},
	}
	// TradeOrderFieldProfitAbs orders Trade by profit_abs.
	TradeOrderFieldProfitAbs = &TradeOrderField{
		Value: func(_m *Trade) (ent.Value, error) {
			return _m.ProfitAbs, nil
		},
		column: trade.FieldProfitAbs,
		toTerm: trade.ByProfitAbs,
		toCursor: func(_m *Trade) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ProfitAbs,
			}
		},
	}
	// TradeOrderFieldProfitRatio orders Trade by profit_ratio.
	TradeOrderFieldProfitRatio = &TradeOrderField{
		Value: func(_m *Trade) (ent.Value, error) {
			return _m.ProfitRatio, nil
		},
		column: trade.FieldProfitRatio,
		toTerm: trade.ByProfitRatio,
		toCursor: func(_m *Trade) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ProfitRatio,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TradeOrderField) String() string {
	var str string
	switch f.column {
	case TradeOrderFieldOpenDate.column:
		str = "OPEN_DATE"
	case TradeOrderFieldCloseDate.column:
		str = "CLOSE_DATE"
	case TradeOrderFieldProfitAbs.column:
		str = "PROFIT_ABS"
	case TradeOrderFieldProfitRatio.column:
		str = "PROFIT_RATIO"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TradeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TradeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TradeOrderField %T must be a string", v)
	}
	switch str {
	case "OPEN_DATE":
		*f = *TradeOrderFieldOpenDate
	case "CLOSE_DATE":
		*f = *TradeOrderFieldCloseDate
	case "PROFIT_ABS":
		*f = *TradeOrderFieldProfitAbs
	case "PROFIT_RATIO":
		*f = *TradeOrderFieldProfitRatio
	default:
		return fmt.Errorf("%s is not a valid TradeOrderField", str)
	}
	return nil
}

// TradeOrderField defines the ordering field of Trade.
type TradeOrderField struct {
	// Value extracts the ordering value from the given Trade.
	Value    func(*Trade) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trade.OrderOption
	toCursor func(*Trade) Cursor
}

// TradeOrder defines the ordering of Trade.
type TradeOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *TradeOrderField `json:"field"`
}

// DefaultTradeOrder is the default ordering of Trade.
var DefaultTradeOrder = &TradeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TradeOrderField{
		Value: func(_m *Trade) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trade.FieldID,
		toTerm: trade.ByID,
		toCursor: func(_m *Trade) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Trade into TradeEdge.
func (_m *Trade) ToEdge(order *TradeOrder) *TradeEdge {
	if order == nil {
		order = DefaultTradeOrder
	}
	return &TradeEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}
