// Code generated by ent, DO NOT EDIT.

package ent

import (
	"anytrade/internal/ent/backtest"
	"anytrade/internal/ent/bot"
	"anytrade/internal/ent/exchange"
	"anytrade/internal/ent/exchangesecret"
	"anytrade/internal/ent/hyperopt"
	"anytrade/internal/ent/predicate"
	"anytrade/internal/ent/strategy"
	"anytrade/internal/ent/trade"
	"anytrade/internal/enum"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBacktest       = "Backtest"
	TypeBot            = "Bot"
	TypeExchange       = "Exchange"
	TypeExchangeSecret = "ExchangeSecret"
	TypeHyperOpt       = "HyperOpt"
	TypeStrategy       = "Strategy"
	TypeTrade          = "Trade"
)

// BacktestMutation represents an operation that mutates the Backtest nodes in the graph.
type BacktestMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	status          *enum.TaskStatus
	start_date      *time.Time
	end_date        *time.Time
	timeframe       *string
	stake_amount    *float64
	addstake_amount *float64
	stake_currency  *string
	pairs           *[]string
	appendpairs     []string
	results         *map[string]interface{}
	_config         *map[string]interface{}
	runtime_id      *string
	log_output      *string
	error_message   *string
	created_at      *time.Time
	updated_at      *time.Time
	completed_at    *time.Time
	clearedFields   map[string]struct{}
	strategy        *uuid.UUID
	clearedstrategy bool
	done            bool
	oldValue        func(context.Context) (*Backtest, error)
	predicates      []predicate.Backtest
}

var _ ent.Mutation = (*BacktestMutation)(nil)

// backtestOption allows management of the mutation configuration using functional options.
type backtestOption func(*BacktestMutation)

// newBacktestMutation creates new mutation for the Backtest entity.
func newBacktestMutation(c config, op Op, opts ...backtestOption) *BacktestMutation {
	m := &BacktestMutation{
		config:        c,
		op:            op,
		typ:           TypeBacktest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBacktestID sets the ID field of the mutation.
func withBacktestID(id uuid.UUID) backtestOption {
	return func(m *BacktestMutation) {
		var (
			err   error
			once  sync.Once
			value *Backtest
		)
		m.oldValue = func(ctx context.Context) (*Backtest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Backtest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBacktest sets the old Backtest of the mutation.
func withBacktest(node *Backtest) backtestOption {
	return func(m *BacktestMutation) {
		m.oldValue = func(context.Context) (*Backtest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BacktestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BacktestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Backtest entities.
func (m *BacktestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BacktestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BacktestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Backtest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *BacktestMutation) SetStatus(es enum.TaskStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *BacktestMutation) Status() (r enum.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldStatus(ctx context.Context) (v enum.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BacktestMutation) ResetStatus() {
	m.status = nil
}

// SetStartDate sets the "start_date" field.
func (m *BacktestMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *BacktestMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *BacktestMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *BacktestMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *BacktestMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *BacktestMutation) ResetEndDate() {
	m.end_date = nil
}

// SetTimeframe sets the "timeframe" field.
func (m *BacktestMutation) SetTimeframe(s string) {
	m.timeframe = &s
}

// Timeframe returns the value of the "timeframe" field in the mutation.
func (m *BacktestMutation) Timeframe() (r string, exists bool) {
	v := m.timeframe
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeframe returns the old "timeframe" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldTimeframe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeframe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeframe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeframe: %w", err)
	}
	return oldValue.Timeframe, nil
}

// ResetTimeframe resets all changes to the "timeframe" field.
func (m *BacktestMutation) ResetTimeframe() {
	m.timeframe = nil
}

// SetStakeAmount sets the "stake_amount" field.
func (m *BacktestMutation) SetStakeAmount(f float64) {
	m.stake_amount = &f
	m.addstake_amount = nil
}

// StakeAmount returns the value of the "stake_amount" field in the mutation.
func (m *BacktestMutation) StakeAmount() (r float64, exists bool) {
	v := m.stake_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStakeAmount returns the old "stake_amount" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldStakeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakeAmount: %w", err)
	}
	return oldValue.StakeAmount, nil
}

// AddStakeAmount adds f to the "stake_amount" field.
func (m *BacktestMutation) AddStakeAmount(f float64) {
	if m.addstake_amount != nil {
		*m.addstake_amount += f
	} else {
		m.addstake_amount = &f
	}
}

// AddedStakeAmount returns the value that was added to the "stake_amount" field in this mutation.
func (m *BacktestMutation) AddedStakeAmount() (r float64, exists bool) {
	v := m.addstake_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetStakeAmount resets all changes to the "stake_amount" field.
func (m *BacktestMutation) ResetStakeAmount() {
	m.stake_amount = nil
	m.addstake_amount = nil
}

// SetStakeCurrency sets the "stake_currency" field.
func (m *BacktestMutation) SetStakeCurrency(s string) {
	m.stake_currency = &s
}

// StakeCurrency returns the value of the "stake_currency" field in the mutation.
func (m *BacktestMutation) StakeCurrency() (r string, exists bool) {
	v := m.stake_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldStakeCurrency returns the old "stake_currency" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldStakeCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakeCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakeCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakeCurrency: %w", err)
	}
	return oldValue.StakeCurrency, nil
}

// ResetStakeCurrency resets all changes to the "stake_currency" field.
func (m *BacktestMutation) ResetStakeCurrency() {
	m.stake_currency = nil
}

// SetPairs sets the "pairs" field.
func (m *BacktestMutation) SetPairs(s []string) {
	m.pairs = &s
	m.appendpairs = nil
}

// Pairs returns the value of the "pairs" field in the mutation.
func (m *BacktestMutation) Pairs() (r []string, exists bool) {
	v := m.pairs
	if v == nil {
		return
	}
	return *v, true
}

// OldPairs returns the old "pairs" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldPairs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPairs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPairs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPairs: %w", err)
	}
	return oldValue.Pairs, nil
}

// AppendPairs adds s to the "pairs" field.
func (m *BacktestMutation) AppendPairs(s []string) {
	m.appendpairs = append(m.appendpairs, s...)
}

// AppendedPairs returns the list of values that were appended to the "pairs" field in this mutation.
func (m *BacktestMutation) AppendedPairs() ([]string, bool) {
	if len(m.appendpairs) == 0 {
		return nil, false
	}
	return m.appendpairs, true
}

// ResetPairs resets all changes to the "pairs" field.
func (m *BacktestMutation) ResetPairs() {
	m.pairs = nil
	m.appendpairs = nil
}

// SetResults sets the "results" field.
func (m *BacktestMutation) SetResults(value map[string]interface{}) {
	m.results = &value
}

// Results returns the value of the "results" field in the mutation.
func (m *BacktestMutation) Results() (r map[string]interface{}, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldResults(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// ClearResults clears the value of the "results" field.
func (m *BacktestMutation) ClearResults() {
	m.results = nil
	m.clearedFields[backtest.FieldResults] = struct{}{}
}

// ResultsCleared returns if the "results" field was cleared in this mutation.
func (m *BacktestMutation) ResultsCleared() bool {
	_, ok := m.clearedFields[backtest.FieldResults]
	return ok
}

// ResetResults resets all changes to the "results" field.
func (m *BacktestMutation) ResetResults() {
	m.results = nil
	delete(m.clearedFields, backtest.FieldResults)
}

// SetConfig sets the "config" field.
func (m *BacktestMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *BacktestMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *BacktestMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[backtest.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *BacktestMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[backtest.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *BacktestMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, backtest.FieldConfig)
}

// SetRuntimeID sets the "runtime_id" field.
func (m *BacktestMutation) SetRuntimeID(s string) {
	m.runtime_id = &s
}

// RuntimeID returns the value of the "runtime_id" field in the mutation.
func (m *BacktestMutation) RuntimeID() (r string, exists bool) {
	v := m.runtime_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntimeID returns the old "runtime_id" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldRuntimeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuntimeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuntimeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntimeID: %w", err)
	}
	return oldValue.RuntimeID, nil
}

// ClearRuntimeID clears the value of the "runtime_id" field.
func (m *BacktestMutation) ClearRuntimeID() {
	m.runtime_id = nil
	m.clearedFields[backtest.FieldRuntimeID] = struct{}{}
}

// RuntimeIDCleared returns if the "runtime_id" field was cleared in this mutation.
func (m *BacktestMutation) RuntimeIDCleared() bool {
	_, ok := m.clearedFields[backtest.FieldRuntimeID]
	return ok
}

// ResetRuntimeID resets all changes to the "runtime_id" field.
func (m *BacktestMutation) ResetRuntimeID() {
	m.runtime_id = nil
	delete(m.clearedFields, backtest.FieldRuntimeID)
}

// SetLogOutput sets the "log_output" field.
func (m *BacktestMutation) SetLogOutput(s string) {
	m.log_output = &s
}

// LogOutput returns the value of the "log_output" field in the mutation.
func (m *BacktestMutation) LogOutput() (r string, exists bool) {
	v := m.log_output
	if v == nil {
		return
	}
	return *v, true
}

// OldLogOutput returns the old "log_output" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldLogOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogOutput: %w", err)
	}
	return oldValue.LogOutput, nil
}

// ClearLogOutput clears the value of the "log_output" field.
func (m *BacktestMutation) ClearLogOutput() {
	m.log_output = nil
	m.clearedFields[backtest.FieldLogOutput] = struct{}{}
}

// LogOutputCleared returns if the "log_output" field was cleared in this mutation.
func (m *BacktestMutation) LogOutputCleared() bool {
	_, ok := m.clearedFields[backtest.FieldLogOutput]
	return ok
}

// ResetLogOutput resets all changes to the "log_output" field.
func (m *BacktestMutation) ResetLogOutput() {
	m.log_output = nil
	delete(m.clearedFields, backtest.FieldLogOutput)
}

// SetErrorMessage sets the "error_message" field.
func (m *BacktestMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *BacktestMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *BacktestMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[backtest.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *BacktestMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[backtest.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *BacktestMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, backtest.FieldErrorMessage)
}

// SetStrategyID sets the "strategy_id" field.
func (m *BacktestMutation) SetStrategyID(u uuid.UUID) {
	m.strategy = &u
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *BacktestMutation) StrategyID() (r uuid.UUID, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldStrategyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *BacktestMutation) ResetStrategyID() {
	m.strategy = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BacktestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BacktestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BacktestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BacktestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BacktestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BacktestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *BacktestMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *BacktestMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *BacktestMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[backtest.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *BacktestMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[backtest.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *BacktestMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, backtest.FieldCompletedAt)
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *BacktestMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[backtest.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *BacktestMutation) StrategyCleared() bool {
	return m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *BacktestMutation) StrategyIDs() (ids []uuid.UUID) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *BacktestMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// Where appends a list predicates to the BacktestMutation builder.
func (m *BacktestMutation) Where(ps ...predicate.Backtest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BacktestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BacktestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Backtest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BacktestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BacktestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Backtest).
func (m *BacktestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BacktestMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.status != nil {
		fields = append(fields, backtest.FieldStatus)
	}
	if m.start_date != nil {
		fields = append(fields, backtest.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, backtest.FieldEndDate)
	}
	if m.timeframe != nil {
		fields = append(fields, backtest.FieldTimeframe)
	}
	if m.stake_amount != nil {
		fields = append(fields, backtest.FieldStakeAmount)
	}
	if m.stake_currency != nil {
		fields = append(fields, backtest.FieldStakeCurrency)
	}
	if m.pairs != nil {
		fields = append(fields, backtest.FieldPairs)
	}
	if m.results != nil {
		fields = append(fields, backtest.FieldResults)
	}
	if m._config != nil {
		fields = append(fields, backtest.FieldConfig)
	}
	if m.runtime_id != nil {
		fields = append(fields, backtest.FieldRuntimeID)
	}
	if m.log_output != nil {
		fields = append(fields, backtest.FieldLogOutput)
	}
	if m.error_message != nil {
		fields = append(fields, backtest.FieldErrorMessage)
	}
	if m.strategy != nil {
		fields = append(fields, backtest.FieldStrategyID)
	}
	if m.created_at != nil {
		fields = append(fields, backtest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backtest.FieldUpdatedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, backtest.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BacktestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backtest.FieldStatus:
		return m.Status()
	case backtest.FieldStartDate:
		return m.StartDate()
	case backtest.FieldEndDate:
		return m.EndDate()
	case backtest.FieldTimeframe:
		return m.Timeframe()
	case backtest.FieldStakeAmount:
		return m.StakeAmount()
	case backtest.FieldStakeCurrency:
		return m.StakeCurrency()
	case backtest.FieldPairs:
		return m.Pairs()
	case backtest.FieldResults:
		return m.Results()
	case backtest.FieldConfig:
		return m.Config()
	case backtest.FieldRuntimeID:
		return m.RuntimeID()
	case backtest.FieldLogOutput:
		return m.LogOutput()
	case backtest.FieldErrorMessage:
		return m.ErrorMessage()
	case backtest.FieldStrategyID:
		return m.StrategyID()
	case backtest.FieldCreatedAt:
		return m.CreatedAt()
	case backtest.FieldUpdatedAt:
		return m.UpdatedAt()
	case backtest.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BacktestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backtest.FieldStatus:
		return m.OldStatus(ctx)
	case backtest.FieldStartDate:
		return m.OldStartDate(ctx)
	case backtest.FieldEndDate:
		return m.OldEndDate(ctx)
	case backtest.FieldTimeframe:
		return m.OldTimeframe(ctx)
	case backtest.FieldStakeAmount:
		return m.OldStakeAmount(ctx)
	case backtest.FieldStakeCurrency:
		return m.OldStakeCurrency(ctx)
	case backtest.FieldPairs:
		return m.OldPairs(ctx)
	case backtest.FieldResults:
		return m.OldResults(ctx)
	case backtest.FieldConfig:
		return m.OldConfig(ctx)
	case backtest.FieldRuntimeID:
		return m.OldRuntimeID(ctx)
	case backtest.FieldLogOutput:
		return m.OldLogOutput(ctx)
	case backtest.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case backtest.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case backtest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backtest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case backtest.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Backtest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BacktestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backtest.FieldStatus:
		v, ok := value.(enum.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case backtest.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case backtest.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case backtest.FieldTimeframe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeframe(v)
		return nil
	case backtest.FieldStakeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakeAmount(v)
		return nil
	case backtest.FieldStakeCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakeCurrency(v)
		return nil
	case backtest.FieldPairs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPairs(v)
		return nil
	case backtest.FieldResults:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	case backtest.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case backtest.FieldRuntimeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntimeID(v)
		return nil
	case backtest.FieldLogOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogOutput(v)
		return nil
	case backtest.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case backtest.FieldStrategyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case backtest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backtest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case backtest.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Backtest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BacktestMutation) AddedFields() []string {
	var fields []string
	if m.addstake_amount != nil {
		fields = append(fields, backtest.FieldStakeAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BacktestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case backtest.FieldStakeAmount:
		return m.AddedStakeAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BacktestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case backtest.FieldStakeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStakeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Backtest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BacktestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(backtest.FieldResults) {
		fields = append(fields, backtest.FieldResults)
	}
	if m.FieldCleared(backtest.FieldConfig) {
		fields = append(fields, backtest.FieldConfig)
	}
	if m.FieldCleared(backtest.FieldRuntimeID) {
		fields = append(fields, backtest.FieldRuntimeID)
	}
	if m.FieldCleared(backtest.FieldLogOutput) {
		fields = append(fields, backtest.FieldLogOutput)
	}
	if m.FieldCleared(backtest.FieldErrorMessage) {
		fields = append(fields, backtest.FieldErrorMessage)
	}
	if m.FieldCleared(backtest.FieldCompletedAt) {
		fields = append(fields, backtest.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BacktestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BacktestMutation) ClearField(name string) error {
	switch name {
	case backtest.FieldResults:
		m.ClearResults()
		return nil
	case backtest.FieldConfig:
		m.ClearConfig()
		return nil
	case backtest.FieldRuntimeID:
		m.ClearRuntimeID()
		return nil
	case backtest.FieldLogOutput:
		m.ClearLogOutput()
		return nil
	case backtest.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case backtest.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Backtest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BacktestMutation) ResetField(name string) error {
	switch name {
	case backtest.FieldStatus:
		m.ResetStatus()
		return nil
	case backtest.FieldStartDate:
		m.ResetStartDate()
		return nil
	case backtest.FieldEndDate:
		m.ResetEndDate()
		return nil
	case backtest.FieldTimeframe:
		m.ResetTimeframe()
		return nil
	case backtest.FieldStakeAmount:
		m.ResetStakeAmount()
		return nil
	case backtest.FieldStakeCurrency:
		m.ResetStakeCurrency()
		return nil
	case backtest.FieldPairs:
		m.ResetPairs()
		return nil
	case backtest.FieldResults:
		m.ResetResults()
		return nil
	case backtest.FieldConfig:
		m.ResetConfig()
		return nil
	case backtest.FieldRuntimeID:
		m.ResetRuntimeID()
		return nil
	case backtest.FieldLogOutput:
		m.ResetLogOutput()
		return nil
	case backtest.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case backtest.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case backtest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backtest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case backtest.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Backtest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BacktestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.strategy != nil {
		edges = append(edges, backtest.EdgeStrategy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BacktestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case backtest.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BacktestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BacktestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BacktestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstrategy {
		edges = append(edges, backtest.EdgeStrategy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BacktestMutation) EdgeCleared(name string) bool {
	switch name {
	case backtest.EdgeStrategy:
		return m.clearedstrategy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BacktestMutation) ClearEdge(name string) error {
	switch name {
	case backtest.EdgeStrategy:
		m.ClearStrategy()
		return nil
	}
	return fmt.Errorf("unknown Backtest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BacktestMutation) ResetEdge(name string) error {
	switch name {
	case backtest.EdgeStrategy:
		m.ResetStrategy()
		return nil
	}
	return fmt.Errorf("unknown Backtest edge %s", name)
}

// BotMutation represents an operation that mutates the Bot nodes in the graph.
type BotMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	status            *enum.BotStatus
	mode              *enum.BotMode
	runtime_type      *enum.RuntimeType
	runtime_id        *string
	runtime_metadata  *map[string]string
	api_url           *string
	api_username      *string
	api_password      *string
	_config           *map[string]interface{}
	freqtrade_version *string
	last_seen_at      *time.Time
	error_message     *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	exchange          *uuid.UUID
	clearedexchange   bool
	strategy          *uuid.UUID
	clearedstrategy   bool
	trades            map[uuid.UUID]struct{}
	removedtrades     map[uuid.UUID]struct{}
	clearedtrades     bool
	done              bool
	oldValue          func(context.Context) (*Bot, error)
	predicates        []predicate.Bot
}

var _ ent.Mutation = (*BotMutation)(nil)

// botOption allows management of the mutation configuration using functional options.
type botOption func(*BotMutation)

// newBotMutation creates new mutation for the Bot entity.
func newBotMutation(c config, op Op, opts ...botOption) *BotMutation {
	m := &BotMutation{
		config:        c,
		op:            op,
		typ:           TypeBot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBotID sets the ID field of the mutation.
func withBotID(id uuid.UUID) botOption {
	return func(m *BotMutation) {
		var (
			err   error
			once  sync.Once
			value *Bot
		)
		m.oldValue = func(ctx context.Context) (*Bot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBot sets the old Bot of the mutation.
func withBot(node *Bot) botOption {
	return func(m *BotMutation) {
		m.oldValue = func(context.Context) (*Bot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bot entities.
func (m *BotMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BotMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BotMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BotMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *BotMutation) SetStatus(es enum.BotStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *BotMutation) Status() (r enum.BotStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldStatus(ctx context.Context) (v enum.BotStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BotMutation) ResetStatus() {
	m.status = nil
}

// SetMode sets the "mode" field.
func (m *BotMutation) SetMode(em enum.BotMode) {
	m.mode = &em
}

// Mode returns the value of the "mode" field in the mutation.
func (m *BotMutation) Mode() (r enum.BotMode, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldMode(ctx context.Context) (v enum.BotMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *BotMutation) ResetMode() {
	m.mode = nil
}

// SetRuntimeType sets the "runtime_type" field.
func (m *BotMutation) SetRuntimeType(et enum.RuntimeType) {
	m.runtime_type = &et
}

// RuntimeType returns the value of the "runtime_type" field in the mutation.
func (m *BotMutation) RuntimeType() (r enum.RuntimeType, exists bool) {
	v := m.runtime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntimeType returns the old "runtime_type" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldRuntimeType(ctx context.Context) (v enum.RuntimeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuntimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuntimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntimeType: %w", err)
	}
	return oldValue.RuntimeType, nil
}

// ResetRuntimeType resets all changes to the "runtime_type" field.
func (m *BotMutation) ResetRuntimeType() {
	m.runtime_type = nil
}

// SetRuntimeID sets the "runtime_id" field.
func (m *BotMutation) SetRuntimeID(s string) {
	m.runtime_id = &s
}

// RuntimeID returns the value of the "runtime_id" field in the mutation.
func (m *BotMutation) RuntimeID() (r string, exists bool) {
	v := m.runtime_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntimeID returns the old "runtime_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldRuntimeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuntimeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuntimeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntimeID: %w", err)
	}
	return oldValue.RuntimeID, nil
}

// ClearRuntimeID clears the value of the "runtime_id" field.
func (m *BotMutation) ClearRuntimeID() {
	m.runtime_id = nil
	m.clearedFields[bot.FieldRuntimeID] = struct{}{}
}

// RuntimeIDCleared returns if the "runtime_id" field was cleared in this mutation.
func (m *BotMutation) RuntimeIDCleared() bool {
	_, ok := m.clearedFields[bot.FieldRuntimeID]
	return ok
}

// ResetRuntimeID resets all changes to the "runtime_id" field.
func (m *BotMutation) ResetRuntimeID() {
	m.runtime_id = nil
	delete(m.clearedFields, bot.FieldRuntimeID)
}

// SetRuntimeMetadata sets the "runtime_metadata" field.
func (m *BotMutation) SetRuntimeMetadata(value map[string]string) {
	m.runtime_metadata = &value
}

// RuntimeMetadata returns the value of the "runtime_metadata" field in the mutation.
func (m *BotMutation) RuntimeMetadata() (r map[string]string, exists bool) {
	v := m.runtime_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntimeMetadata returns the old "runtime_metadata" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldRuntimeMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuntimeMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuntimeMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntimeMetadata: %w", err)
	}
	return oldValue.RuntimeMetadata, nil
}

// ClearRuntimeMetadata clears the value of the "runtime_metadata" field.
func (m *BotMutation) ClearRuntimeMetadata() {
	m.runtime_metadata = nil
	m.clearedFields[bot.FieldRuntimeMetadata] = struct{}{}
}

// RuntimeMetadataCleared returns if the "runtime_metadata" field was cleared in this mutation.
func (m *BotMutation) RuntimeMetadataCleared() bool {
	_, ok := m.clearedFields[bot.FieldRuntimeMetadata]
	return ok
}

// ResetRuntimeMetadata resets all changes to the "runtime_metadata" field.
func (m *BotMutation) ResetRuntimeMetadata() {
	m.runtime_metadata = nil
	delete(m.clearedFields, bot.FieldRuntimeMetadata)
}

// SetAPIURL sets the "api_url" field.
func (m *BotMutation) SetAPIURL(s string) {
	m.api_url = &s
}

// APIURL returns the value of the "api_url" field in the mutation.
func (m *BotMutation) APIURL() (r string, exists bool) {
	v := m.api_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIURL returns the old "api_url" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldAPIURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIURL: %w", err)
	}
	return oldValue.APIURL, nil
}

// ClearAPIURL clears the value of the "api_url" field.
func (m *BotMutation) ClearAPIURL() {
	m.api_url = nil
	m.clearedFields[bot.FieldAPIURL] = struct{}{}
}

// APIURLCleared returns if the "api_url" field was cleared in this mutation.
func (m *BotMutation) APIURLCleared() bool {
	_, ok := m.clearedFields[bot.FieldAPIURL]
	return ok
}

// ResetAPIURL resets all changes to the "api_url" field.
func (m *BotMutation) ResetAPIURL() {
	m.api_url = nil
	delete(m.clearedFields, bot.FieldAPIURL)
}

// SetAPIUsername sets the "api_username" field.
func (m *BotMutation) SetAPIUsername(s string) {
	m.api_username = &s
}

// APIUsername returns the value of the "api_username" field in the mutation.
func (m *BotMutation) APIUsername() (r string, exists bool) {
	v := m.api_username
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIUsername returns the old "api_username" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldAPIUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIUsername: %w", err)
	}
	return oldValue.APIUsername, nil
}

// ClearAPIUsername clears the value of the "api_username" field.
func (m *BotMutation) ClearAPIUsername() {
	m.api_username = nil
	m.clearedFields[bot.FieldAPIUsername] = struct{}{}
}

// APIUsernameCleared returns if the "api_username" field was cleared in this mutation.
func (m *BotMutation) APIUsernameCleared() bool {
	_, ok := m.clearedFields[bot.FieldAPIUsername]
	return ok
}

// ResetAPIUsername resets all changes to the "api_username" field.
func (m *BotMutation) ResetAPIUsername() {
	m.api_username = nil
	delete(m.clearedFields, bot.FieldAPIUsername)
}

// SetAPIPassword sets the "api_password" field.
func (m *BotMutation) SetAPIPassword(s string) {
	m.api_password = &s
}

// APIPassword returns the value of the "api_password" field in the mutation.
func (m *BotMutation) APIPassword() (r string, exists bool) {
	v := m.api_password
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIPassword returns the old "api_password" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldAPIPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIPassword: %w", err)
	}
	return oldValue.APIPassword, nil
}

// ClearAPIPassword clears the value of the "api_password" field.
func (m *BotMutation) ClearAPIPassword() {
	m.api_password = nil
	m.clearedFields[bot.FieldAPIPassword] = struct{}{}
}

// APIPasswordCleared returns if the "api_password" field was cleared in this mutation.
func (m *BotMutation) APIPasswordCleared() bool {
	_, ok := m.clearedFields[bot.FieldAPIPassword]
	return ok
}

// ResetAPIPassword resets all changes to the "api_password" field.
func (m *BotMutation) ResetAPIPassword() {
	m.api_password = nil
	delete(m.clearedFields, bot.FieldAPIPassword)
}

// SetConfig sets the "config" field.
func (m *BotMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *BotMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *BotMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[bot.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *BotMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[bot.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *BotMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, bot.FieldConfig)
}

// SetFreqtradeVersion sets the "freqtrade_version" field.
func (m *BotMutation) SetFreqtradeVersion(s string) {
	m.freqtrade_version = &s
}

// FreqtradeVersion returns the value of the "freqtrade_version" field in the mutation.
func (m *BotMutation) FreqtradeVersion() (r string, exists bool) {
	v := m.freqtrade_version
	if v == nil {
		return
	}
	return *v, true
}

// OldFreqtradeVersion returns the old "freqtrade_version" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldFreqtradeVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreqtradeVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreqtradeVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreqtradeVersion: %w", err)
	}
	return oldValue.FreqtradeVersion, nil
}

// ResetFreqtradeVersion resets all changes to the "freqtrade_version" field.
func (m *BotMutation) ResetFreqtradeVersion() {
	m.freqtrade_version = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *BotMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *BotMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ClearLastSeenAt clears the value of the "last_seen_at" field.
func (m *BotMutation) ClearLastSeenAt() {
	m.last_seen_at = nil
	m.clearedFields[bot.FieldLastSeenAt] = struct{}{}
}

// LastSeenAtCleared returns if the "last_seen_at" field was cleared in this mutation.
func (m *BotMutation) LastSeenAtCleared() bool {
	_, ok := m.clearedFields[bot.FieldLastSeenAt]
	return ok
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *BotMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
	delete(m.clearedFields, bot.FieldLastSeenAt)
}

// SetErrorMessage sets the "error_message" field.
func (m *BotMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *BotMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *BotMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[bot.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *BotMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[bot.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *BotMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, bot.FieldErrorMessage)
}

// SetExchangeID sets the "exchange_id" field.
func (m *BotMutation) SetExchangeID(u uuid.UUID) {
	m.exchange = &u
}

// ExchangeID returns the value of the "exchange_id" field in the mutation.
func (m *BotMutation) ExchangeID() (r uuid.UUID, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeID returns the old "exchange_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldExchangeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeID: %w", err)
	}
	return oldValue.ExchangeID, nil
}

// ResetExchangeID resets all changes to the "exchange_id" field.
func (m *BotMutation) ResetExchangeID() {
	m.exchange = nil
}

// SetStrategyID sets the "strategy_id" field.
func (m *BotMutation) SetStrategyID(u uuid.UUID) {
	m.strategy = &u
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *BotMutation) StrategyID() (r uuid.UUID, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldStrategyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *BotMutation) ResetStrategyID() {
	m.strategy = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearExchange clears the "exchange" edge to the Exchange entity.
func (m *BotMutation) ClearExchange() {
	m.clearedexchange = true
	m.clearedFields[bot.FieldExchangeID] = struct{}{}
}

// ExchangeCleared reports if the "exchange" edge to the Exchange entity was cleared.
func (m *BotMutation) ExchangeCleared() bool {
	return m.clearedexchange
}

// ExchangeIDs returns the "exchange" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExchangeID instead. It exists only for internal usage by the builders.
func (m *BotMutation) ExchangeIDs() (ids []uuid.UUID) {
	if id := m.exchange; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExchange resets all changes to the "exchange" edge.
func (m *BotMutation) ResetExchange() {
	m.exchange = nil
	m.clearedexchange = false
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *BotMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[bot.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *BotMutation) StrategyCleared() bool {
	return m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *BotMutation) StrategyIDs() (ids []uuid.UUID) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *BotMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// AddTradeIDs adds the "trades" edge to the Trade entity by ids.
func (m *BotMutation) AddTradeIDs(ids ...uuid.UUID) {
	if m.trades == nil {
		m.trades = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.trades[ids[i]] = struct{}{}
	}
}

// ClearTrades clears the "trades" edge to the Trade entity.
func (m *BotMutation) ClearTrades() {
	m.clearedtrades = true
}

// TradesCleared reports if the "trades" edge to the Trade entity was cleared.
func (m *BotMutation) TradesCleared() bool {
	return m.clearedtrades
}

// RemoveTradeIDs removes the "trades" edge to the Trade entity by IDs.
func (m *BotMutation) RemoveTradeIDs(ids ...uuid.UUID) {
	if m.removedtrades == nil {
		m.removedtrades = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.trades, ids[i])
		m.removedtrades[ids[i]] = struct{}{}
	}
}

// RemovedTrades returns the removed IDs of the "trades" edge to the Trade entity.
func (m *BotMutation) RemovedTradesIDs() (ids []uuid.UUID) {
	for id := range m.removedtrades {
		ids = append(ids, id)
	}
	return
}

// TradesIDs returns the "trades" edge IDs in the mutation.
func (m *BotMutation) TradesIDs() (ids []uuid.UUID) {
	for id := range m.trades {
		ids = append(ids, id)
	}
	return
}

// ResetTrades resets all changes to the "trades" edge.
func (m *BotMutation) ResetTrades() {
	m.trades = nil
	m.clearedtrades = false
	m.removedtrades = nil
}

// Where appends a list predicates to the BotMutation builder.
func (m *BotMutation) Where(ps ...predicate.Bot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bot).
func (m *BotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BotMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.name != nil {
		fields = append(fields, bot.FieldName)
	}
	if m.status != nil {
		fields = append(fields, bot.FieldStatus)
	}
	if m.mode != nil {
		fields = append(fields, bot.FieldMode)
	}
	if m.runtime_type != nil {
		fields = append(fields, bot.FieldRuntimeType)
	}
	if m.runtime_id != nil {
		fields = append(fields, bot.FieldRuntimeID)
	}
	if m.runtime_metadata != nil {
		fields = append(fields, bot.FieldRuntimeMetadata)
	}
	if m.api_url != nil {
		fields = append(fields, bot.FieldAPIURL)
	}
	if m.api_username != nil {
		fields = append(fields, bot.FieldAPIUsername)
	}
	if m.api_password != nil {
		fields = append(fields, bot.FieldAPIPassword)
	}
	if m._config != nil {
		fields = append(fields, bot.FieldConfig)
	}
	if m.freqtrade_version != nil {
		fields = append(fields, bot.FieldFreqtradeVersion)
	}
	if m.last_seen_at != nil {
		fields = append(fields, bot.FieldLastSeenAt)
	}
	if m.error_message != nil {
		fields = append(fields, bot.FieldErrorMessage)
	}
	if m.exchange != nil {
		fields = append(fields, bot.FieldExchangeID)
	}
	if m.strategy != nil {
		fields = append(fields, bot.FieldStrategyID)
	}
	if m.created_at != nil {
		fields = append(fields, bot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bot.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bot.FieldName:
		return m.Name()
	case bot.FieldStatus:
		return m.Status()
	case bot.FieldMode:
		return m.Mode()
	case bot.FieldRuntimeType:
		return m.RuntimeType()
	case bot.FieldRuntimeID:
		return m.RuntimeID()
	case bot.FieldRuntimeMetadata:
		return m.RuntimeMetadata()
	case bot.FieldAPIURL:
		return m.APIURL()
	case bot.FieldAPIUsername:
		return m.APIUsername()
	case bot.FieldAPIPassword:
		return m.APIPassword()
	case bot.FieldConfig:
		return m.Config()
	case bot.FieldFreqtradeVersion:
		return m.FreqtradeVersion()
	case bot.FieldLastSeenAt:
		return m.LastSeenAt()
	case bot.FieldErrorMessage:
		return m.ErrorMessage()
	case bot.FieldExchangeID:
		return m.ExchangeID()
	case bot.FieldStrategyID:
		return m.StrategyID()
	case bot.FieldCreatedAt:
		return m.CreatedAt()
	case bot.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bot.FieldName:
		return m.OldName(ctx)
	case bot.FieldStatus:
		return m.OldStatus(ctx)
	case bot.FieldMode:
		return m.OldMode(ctx)
	case bot.FieldRuntimeType:
		return m.OldRuntimeType(ctx)
	case bot.FieldRuntimeID:
		return m.OldRuntimeID(ctx)
	case bot.FieldRuntimeMetadata:
		return m.OldRuntimeMetadata(ctx)
	case bot.FieldAPIURL:
		return m.OldAPIURL(ctx)
	case bot.FieldAPIUsername:
		return m.OldAPIUsername(ctx)
	case bot.FieldAPIPassword:
		return m.OldAPIPassword(ctx)
	case bot.FieldConfig:
		return m.OldConfig(ctx)
	case bot.FieldFreqtradeVersion:
		return m.OldFreqtradeVersion(ctx)
	case bot.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	case bot.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case bot.FieldExchangeID:
		return m.OldExchangeID(ctx)
	case bot.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case bot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Bot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bot.FieldStatus:
		v, ok := value.(enum.BotStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bot.FieldMode:
		v, ok := value.(enum.BotMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case bot.FieldRuntimeType:
		v, ok := value.(enum.RuntimeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntimeType(v)
		return nil
	case bot.FieldRuntimeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntimeID(v)
		return nil
	case bot.FieldRuntimeMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntimeMetadata(v)
		return nil
	case bot.FieldAPIURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIURL(v)
		return nil
	case bot.FieldAPIUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIUsername(v)
		return nil
	case bot.FieldAPIPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIPassword(v)
		return nil
	case bot.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case bot.FieldFreqtradeVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreqtradeVersion(v)
		return nil
	case bot.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	case bot.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case bot.FieldExchangeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeID(v)
		return nil
	case bot.FieldStrategyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case bot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Bot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bot.FieldRuntimeID) {
		fields = append(fields, bot.FieldRuntimeID)
	}
	if m.FieldCleared(bot.FieldRuntimeMetadata) {
		fields = append(fields, bot.FieldRuntimeMetadata)
	}
	if m.FieldCleared(bot.FieldAPIURL) {
		fields = append(fields, bot.FieldAPIURL)
	}
	if m.FieldCleared(bot.FieldAPIUsername) {
		fields = append(fields, bot.FieldAPIUsername)
	}
	if m.FieldCleared(bot.FieldAPIPassword) {
		fields = append(fields, bot.FieldAPIPassword)
	}
	if m.FieldCleared(bot.FieldConfig) {
		fields = append(fields, bot.FieldConfig)
	}
	if m.FieldCleared(bot.FieldLastSeenAt) {
		fields = append(fields, bot.FieldLastSeenAt)
	}
	if m.FieldCleared(bot.FieldErrorMessage) {
		fields = append(fields, bot.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BotMutation) ClearField(name string) error {
	switch name {
	case bot.FieldRuntimeID:
		m.ClearRuntimeID()
		return nil
	case bot.FieldRuntimeMetadata:
		m.ClearRuntimeMetadata()
		return nil
	case bot.FieldAPIURL:
		m.ClearAPIURL()
		return nil
	case bot.FieldAPIUsername:
		m.ClearAPIUsername()
		return nil
	case bot.FieldAPIPassword:
		m.ClearAPIPassword()
		return nil
	case bot.FieldConfig:
		m.ClearConfig()
		return nil
	case bot.FieldLastSeenAt:
		m.ClearLastSeenAt()
		return nil
	case bot.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown Bot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BotMutation) ResetField(name string) error {
	switch name {
	case bot.FieldName:
		m.ResetName()
		return nil
	case bot.FieldStatus:
		m.ResetStatus()
		return nil
	case bot.FieldMode:
		m.ResetMode()
		return nil
	case bot.FieldRuntimeType:
		m.ResetRuntimeType()
		return nil
	case bot.FieldRuntimeID:
		m.ResetRuntimeID()
		return nil
	case bot.FieldRuntimeMetadata:
		m.ResetRuntimeMetadata()
		return nil
	case bot.FieldAPIURL:
		m.ResetAPIURL()
		return nil
	case bot.FieldAPIUsername:
		m.ResetAPIUsername()
		return nil
	case bot.FieldAPIPassword:
		m.ResetAPIPassword()
		return nil
	case bot.FieldConfig:
		m.ResetConfig()
		return nil
	case bot.FieldFreqtradeVersion:
		m.ResetFreqtradeVersion()
		return nil
	case bot.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	case bot.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case bot.FieldExchangeID:
		m.ResetExchangeID()
		return nil
	case bot.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case bot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Bot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BotMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.exchange != nil {
		edges = append(edges, bot.EdgeExchange)
	}
	if m.strategy != nil {
		edges = append(edges, bot.EdgeStrategy)
	}
	if m.trades != nil {
		edges = append(edges, bot.EdgeTrades)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bot.EdgeExchange:
		if id := m.exchange; id != nil {
			return []ent.Value{*id}
		}
	case bot.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	case bot.EdgeTrades:
		ids := make([]ent.Value, 0, len(m.trades))
		for id := range m.trades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtrades != nil {
		edges = append(edges, bot.EdgeTrades)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BotMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bot.EdgeTrades:
		ids := make([]ent.Value, 0, len(m.removedtrades))
		for id := range m.removedtrades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedexchange {
		edges = append(edges, bot.EdgeExchange)
	}
	if m.clearedstrategy {
		edges = append(edges, bot.EdgeStrategy)
	}
	if m.clearedtrades {
		edges = append(edges, bot.EdgeTrades)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BotMutation) EdgeCleared(name string) bool {
	switch name {
	case bot.EdgeExchange:
		return m.clearedexchange
	case bot.EdgeStrategy:
		return m.clearedstrategy
	case bot.EdgeTrades:
		return m.clearedtrades
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BotMutation) ClearEdge(name string) error {
	switch name {
	case bot.EdgeExchange:
		m.ClearExchange()
		return nil
	case bot.EdgeStrategy:
		m.ClearStrategy()
		return nil
	}
	return fmt.Errorf("unknown Bot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BotMutation) ResetEdge(name string) error {
	switch name {
	case bot.EdgeExchange:
		m.ResetExchange()
		return nil
	case bot.EdgeStrategy:
		m.ResetStrategy()
		return nil
	case bot.EdgeTrades:
		m.ResetTrades()
		return nil
	}
	return fmt.Errorf("unknown Bot edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	name           *enum.ExchangeType
	test_mode      *bool
	_config        *map[string]interface{}
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	bots           map[uuid.UUID]struct{}
	removedbots    map[uuid.UUID]struct{}
	clearedbots    bool
	secrets        map[uuid.UUID]struct{}
	removedsecrets map[uuid.UUID]struct{}
	clearedsecrets bool
	done           bool
	oldValue       func(context.Context) (*Exchange, error)
	predicates     []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id uuid.UUID) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exchange entities.
func (m *ExchangeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ExchangeMutation) SetName(et enum.ExchangeType) {
	m.name = &et
}

// Name returns the value of the "name" field in the mutation.
func (m *ExchangeMutation) Name() (r enum.ExchangeType, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldName(ctx context.Context) (v enum.ExchangeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExchangeMutation) ResetName() {
	m.name = nil
}

// SetTestMode sets the "test_mode" field.
func (m *ExchangeMutation) SetTestMode(b bool) {
	m.test_mode = &b
}

// TestMode returns the value of the "test_mode" field in the mutation.
func (m *ExchangeMutation) TestMode() (r bool, exists bool) {
	v := m.test_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldTestMode returns the old "test_mode" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldTestMode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestMode: %w", err)
	}
	return oldValue.TestMode, nil
}

// ResetTestMode resets all changes to the "test_mode" field.
func (m *ExchangeMutation) ResetTestMode() {
	m.test_mode = nil
}

// SetConfig sets the "config" field.
func (m *ExchangeMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *ExchangeMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *ExchangeMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[exchange.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *ExchangeMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[exchange.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *ExchangeMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, exchange.FieldConfig)
}

// SetCreatedAt sets the "created_at" field.
func (m *ExchangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExchangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExchangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExchangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExchangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExchangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBotIDs adds the "bots" edge to the Bot entity by ids.
func (m *ExchangeMutation) AddBotIDs(ids ...uuid.UUID) {
	if m.bots == nil {
		m.bots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bots[ids[i]] = struct{}{}
	}
}

// ClearBots clears the "bots" edge to the Bot entity.
func (m *ExchangeMutation) ClearBots() {
	m.clearedbots = true
}

// BotsCleared reports if the "bots" edge to the Bot entity was cleared.
func (m *ExchangeMutation) BotsCleared() bool {
	return m.clearedbots
}

// RemoveBotIDs removes the "bots" edge to the Bot entity by IDs.
func (m *ExchangeMutation) RemoveBotIDs(ids ...uuid.UUID) {
	if m.removedbots == nil {
		m.removedbots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bots, ids[i])
		m.removedbots[ids[i]] = struct{}{}
	}
}

// RemovedBots returns the removed IDs of the "bots" edge to the Bot entity.
func (m *ExchangeMutation) RemovedBotsIDs() (ids []uuid.UUID) {
	for id := range m.removedbots {
		ids = append(ids, id)
	}
	return
}

// BotsIDs returns the "bots" edge IDs in the mutation.
func (m *ExchangeMutation) BotsIDs() (ids []uuid.UUID) {
	for id := range m.bots {
		ids = append(ids, id)
	}
	return
}

// ResetBots resets all changes to the "bots" edge.
func (m *ExchangeMutation) ResetBots() {
	m.bots = nil
	m.clearedbots = false
	m.removedbots = nil
}

// AddSecretIDs adds the "secrets" edge to the ExchangeSecret entity by ids.
func (m *ExchangeMutation) AddSecretIDs(ids ...uuid.UUID) {
	if m.secrets == nil {
		m.secrets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.secrets[ids[i]] = struct{}{}
	}
}

// ClearSecrets clears the "secrets" edge to the ExchangeSecret entity.
func (m *ExchangeMutation) ClearSecrets() {
	m.clearedsecrets = true
}

// SecretsCleared reports if the "secrets" edge to the ExchangeSecret entity was cleared.
func (m *ExchangeMutation) SecretsCleared() bool {
	return m.clearedsecrets
}

// RemoveSecretIDs removes the "secrets" edge to the ExchangeSecret entity by IDs.
func (m *ExchangeMutation) RemoveSecretIDs(ids ...uuid.UUID) {
	if m.removedsecrets == nil {
		m.removedsecrets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.secrets, ids[i])
		m.removedsecrets[ids[i]] = struct{}{}
	}
}

// RemovedSecrets returns the removed IDs of the "secrets" edge to the ExchangeSecret entity.
func (m *ExchangeMutation) RemovedSecretsIDs() (ids []uuid.UUID) {
	for id := range m.removedsecrets {
		ids = append(ids, id)
	}
	return
}

// SecretsIDs returns the "secrets" edge IDs in the mutation.
func (m *ExchangeMutation) SecretsIDs() (ids []uuid.UUID) {
	for id := range m.secrets {
		ids = append(ids, id)
	}
	return
}

// ResetSecrets resets all changes to the "secrets" edge.
func (m *ExchangeMutation) ResetSecrets() {
	m.secrets = nil
	m.clearedsecrets = false
	m.removedsecrets = nil
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExchangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExchangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exchange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExchangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, exchange.FieldName)
	}
	if m.test_mode != nil {
		fields = append(fields, exchange.FieldTestMode)
	}
	if m._config != nil {
		fields = append(fields, exchange.FieldConfig)
	}
	if m.created_at != nil {
		fields = append(fields, exchange.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exchange.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldName:
		return m.Name()
	case exchange.FieldTestMode:
		return m.TestMode()
	case exchange.FieldConfig:
		return m.Config()
	case exchange.FieldCreatedAt:
		return m.CreatedAt()
	case exchange.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldName:
		return m.OldName(ctx)
	case exchange.FieldTestMode:
		return m.OldTestMode(ctx)
	case exchange.FieldConfig:
		return m.OldConfig(ctx)
	case exchange.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exchange.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldName:
		v, ok := value.(enum.ExchangeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case exchange.FieldTestMode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestMode(v)
		return nil
	case exchange.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case exchange.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exchange.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exchange.FieldConfig) {
		fields = append(fields, exchange.FieldConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	switch name {
	case exchange.FieldConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldName:
		m.ResetName()
		return nil
	case exchange.FieldTestMode:
		m.ResetTestMode()
		return nil
	case exchange.FieldConfig:
		m.ResetConfig()
		return nil
	case exchange.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exchange.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.bots != nil {
		edges = append(edges, exchange.EdgeBots)
	}
	if m.secrets != nil {
		edges = append(edges, exchange.EdgeSecrets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeBots:
		ids := make([]ent.Value, 0, len(m.bots))
		for id := range m.bots {
			ids = append(ids, id)
		}
		return ids
	case exchange.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.secrets))
		for id := range m.secrets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbots != nil {
		edges = append(edges, exchange.EdgeBots)
	}
	if m.removedsecrets != nil {
		edges = append(edges, exchange.EdgeSecrets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeBots:
		ids := make([]ent.Value, 0, len(m.removedbots))
		for id := range m.removedbots {
			ids = append(ids, id)
		}
		return ids
	case exchange.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.removedsecrets))
		for id := range m.removedsecrets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbots {
		edges = append(edges, exchange.EdgeBots)
	}
	if m.clearedsecrets {
		edges = append(edges, exchange.EdgeSecrets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	switch name {
	case exchange.EdgeBots:
		return m.clearedbots
	case exchange.EdgeSecrets:
		return m.clearedsecrets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	switch name {
	case exchange.EdgeBots:
		m.ResetBots()
		return nil
	case exchange.EdgeSecrets:
		m.ResetSecrets()
		return nil
	}
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// ExchangeSecretMutation represents an operation that mutates the ExchangeSecret nodes in the graph.
type ExchangeSecretMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	value           *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	exchange        *uuid.UUID
	clearedexchange bool
	done            bool
	oldValue        func(context.Context) (*ExchangeSecret, error)
	predicates      []predicate.ExchangeSecret
}

var _ ent.Mutation = (*ExchangeSecretMutation)(nil)

// exchangesecretOption allows management of the mutation configuration using functional options.
type exchangesecretOption func(*ExchangeSecretMutation)

// newExchangeSecretMutation creates new mutation for the ExchangeSecret entity.
func newExchangeSecretMutation(c config, op Op, opts ...exchangesecretOption) *ExchangeSecretMutation {
	m := &ExchangeSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeExchangeSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeSecretID sets the ID field of the mutation.
func withExchangeSecretID(id uuid.UUID) exchangesecretOption {
	return func(m *ExchangeSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *ExchangeSecret
		)
		m.oldValue = func(ctx context.Context) (*ExchangeSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExchangeSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchangeSecret sets the old ExchangeSecret of the mutation.
func withExchangeSecret(node *ExchangeSecret) exchangesecretOption {
	return func(m *ExchangeSecretMutation) {
		m.oldValue = func(context.Context) (*ExchangeSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExchangeSecret entities.
func (m *ExchangeSecretMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeSecretMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeSecretMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExchangeSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExchangeID sets the "exchange_id" field.
func (m *ExchangeSecretMutation) SetExchangeID(u uuid.UUID) {
	m.exchange = &u
}

// ExchangeID returns the value of the "exchange_id" field in the mutation.
func (m *ExchangeSecretMutation) ExchangeID() (r uuid.UUID, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeID returns the old "exchange_id" field's value of the ExchangeSecret entity.
// If the ExchangeSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeSecretMutation) OldExchangeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeID: %w", err)
	}
	return oldValue.ExchangeID, nil
}

// ResetExchangeID resets all changes to the "exchange_id" field.
func (m *ExchangeSecretMutation) ResetExchangeID() {
	m.exchange = nil
}

// SetName sets the "name" field.
func (m *ExchangeSecretMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExchangeSecretMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ExchangeSecret entity.
// If the ExchangeSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeSecretMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExchangeSecretMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *ExchangeSecretMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *ExchangeSecretMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the ExchangeSecret entity.
// If the ExchangeSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeSecretMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *ExchangeSecretMutation) ResetValue() {
	m.value = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExchangeSecretMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExchangeSecretMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExchangeSecret entity.
// If the ExchangeSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeSecretMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExchangeSecretMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExchangeSecretMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExchangeSecretMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExchangeSecret entity.
// If the ExchangeSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeSecretMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExchangeSecretMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearExchange clears the "exchange" edge to the Exchange entity.
func (m *ExchangeSecretMutation) ClearExchange() {
	m.clearedexchange = true
	m.clearedFields[exchangesecret.FieldExchangeID] = struct{}{}
}

// ExchangeCleared reports if the "exchange" edge to the Exchange entity was cleared.
func (m *ExchangeSecretMutation) ExchangeCleared() bool {
	return m.clearedexchange
}

// ExchangeIDs returns the "exchange" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExchangeID instead. It exists only for internal usage by the builders.
func (m *ExchangeSecretMutation) ExchangeIDs() (ids []uuid.UUID) {
	if id := m.exchange; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExchange resets all changes to the "exchange" edge.
func (m *ExchangeSecretMutation) ResetExchange() {
	m.exchange = nil
	m.clearedexchange = false
}

// Where appends a list predicates to the ExchangeSecretMutation builder.
func (m *ExchangeSecretMutation) Where(ps ...predicate.ExchangeSecret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExchangeSecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExchangeSecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExchangeSecret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExchangeSecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExchangeSecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExchangeSecret).
func (m *ExchangeSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeSecretMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.exchange != nil {
		fields = append(fields, exchangesecret.FieldExchangeID)
	}
	if m.name != nil {
		fields = append(fields, exchangesecret.FieldName)
	}
	if m.value != nil {
		fields = append(fields, exchangesecret.FieldValue)
	}
	if m.created_at != nil {
		fields = append(fields, exchangesecret.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exchangesecret.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchangesecret.FieldExchangeID:
		return m.ExchangeID()
	case exchangesecret.FieldName:
		return m.Name()
	case exchangesecret.FieldValue:
		return m.Value()
	case exchangesecret.FieldCreatedAt:
		return m.CreatedAt()
	case exchangesecret.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchangesecret.FieldExchangeID:
		return m.OldExchangeID(ctx)
	case exchangesecret.FieldName:
		return m.OldName(ctx)
	case exchangesecret.FieldValue:
		return m.OldValue(ctx)
	case exchangesecret.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exchangesecret.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ExchangeSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchangesecret.FieldExchangeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeID(v)
		return nil
	case exchangesecret.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case exchangesecret.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case exchangesecret.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exchangesecret.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ExchangeSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeSecretMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeSecretMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ExchangeSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeSecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeSecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ExchangeSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeSecretMutation) ResetField(name string) error {
	switch name {
	case exchangesecret.FieldExchangeID:
		m.ResetExchangeID()
		return nil
	case exchangesecret.FieldName:
		m.ResetName()
		return nil
	case exchangesecret.FieldValue:
		m.ResetValue()
		return nil
	case exchangesecret.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exchangesecret.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ExchangeSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.exchange != nil {
		edges = append(edges, exchangesecret.EdgeExchange)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeSecretMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exchangesecret.EdgeExchange:
		if id := m.exchange; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexchange {
		edges = append(edges, exchangesecret.EdgeExchange)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeSecretMutation) EdgeCleared(name string) bool {
	switch name {
	case exchangesecret.EdgeExchange:
		return m.clearedexchange
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeSecretMutation) ClearEdge(name string) error {
	switch name {
	case exchangesecret.EdgeExchange:
		m.ClearExchange()
		return nil
	}
	return fmt.Errorf("unknown ExchangeSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeSecretMutation) ResetEdge(name string) error {
	switch name {
	case exchangesecret.EdgeExchange:
		m.ResetExchange()
		return nil
	}
	return fmt.Errorf("unknown ExchangeSecret edge %s", name)
}

// HyperOptMutation represents an operation that mutates the HyperOpt nodes in the graph.
type HyperOptMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	status              *enum.TaskStatus
	epochs              *int
	addepochs           *int
	start_date          *time.Time
	end_date            *time.Time
	timeframe           *string
	stake_amount        *float64
	addstake_amount     *float64
	stake_currency      *string
	pairs               *[]string
	appendpairs         []string
	optimization_metric *enum.OptimizationMetric
	spaces              *[]string
	appendspaces        []string
	results             *map[string]interface{}
	_config             *map[string]interface{}
	runtime_id          *string
	log_output          *string
	progress            *float64
	addprogress         *float64
	error_message       *string
	created_at          *time.Time
	updated_at          *time.Time
	completed_at        *time.Time
	clearedFields       map[string]struct{}
	strategy            *uuid.UUID
	clearedstrategy     bool
	done                bool
	oldValue            func(context.Context) (*HyperOpt, error)
	predicates          []predicate.HyperOpt
}

var _ ent.Mutation = (*HyperOptMutation)(nil)

// hyperoptOption allows management of the mutation configuration using functional options.
type hyperoptOption func(*HyperOptMutation)

// newHyperOptMutation creates new mutation for the HyperOpt entity.
func newHyperOptMutation(c config, op Op, opts ...hyperoptOption) *HyperOptMutation {
	m := &HyperOptMutation{
		config:        c,
		op:            op,
		typ:           TypeHyperOpt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHyperOptID sets the ID field of the mutation.
func withHyperOptID(id uuid.UUID) hyperoptOption {
	return func(m *HyperOptMutation) {
		var (
			err   error
			once  sync.Once
			value *HyperOpt
		)
		m.oldValue = func(ctx context.Context) (*HyperOpt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HyperOpt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHyperOpt sets the old HyperOpt of the mutation.
func withHyperOpt(node *HyperOpt) hyperoptOption {
	return func(m *HyperOptMutation) {
		m.oldValue = func(context.Context) (*HyperOpt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HyperOptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HyperOptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HyperOpt entities.
func (m *HyperOptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HyperOptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HyperOptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HyperOpt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *HyperOptMutation) SetStatus(es enum.TaskStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *HyperOptMutation) Status() (r enum.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldStatus(ctx context.Context) (v enum.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HyperOptMutation) ResetStatus() {
	m.status = nil
}

// SetEpochs sets the "epochs" field.
func (m *HyperOptMutation) SetEpochs(i int) {
	m.epochs = &i
	m.addepochs = nil
}

// Epochs returns the value of the "epochs" field in the mutation.
func (m *HyperOptMutation) Epochs() (r int, exists bool) {
	v := m.epochs
	if v == nil {
		return
	}
	return *v, true
}

// OldEpochs returns the old "epochs" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldEpochs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpochs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpochs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpochs: %w", err)
	}
	return oldValue.Epochs, nil
}

// AddEpochs adds i to the "epochs" field.
func (m *HyperOptMutation) AddEpochs(i int) {
	if m.addepochs != nil {
		*m.addepochs += i
	} else {
		m.addepochs = &i
	}
}

// AddedEpochs returns the value that was added to the "epochs" field in this mutation.
func (m *HyperOptMutation) AddedEpochs() (r int, exists bool) {
	v := m.addepochs
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpochs resets all changes to the "epochs" field.
func (m *HyperOptMutation) ResetEpochs() {
	m.epochs = nil
	m.addepochs = nil
}

// SetStartDate sets the "start_date" field.
func (m *HyperOptMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *HyperOptMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *HyperOptMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *HyperOptMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *HyperOptMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *HyperOptMutation) ResetEndDate() {
	m.end_date = nil
}

// SetTimeframe sets the "timeframe" field.
func (m *HyperOptMutation) SetTimeframe(s string) {
	m.timeframe = &s
}

// Timeframe returns the value of the "timeframe" field in the mutation.
func (m *HyperOptMutation) Timeframe() (r string, exists bool) {
	v := m.timeframe
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeframe returns the old "timeframe" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldTimeframe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeframe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeframe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeframe: %w", err)
	}
	return oldValue.Timeframe, nil
}

// ResetTimeframe resets all changes to the "timeframe" field.
func (m *HyperOptMutation) ResetTimeframe() {
	m.timeframe = nil
}

// SetStakeAmount sets the "stake_amount" field.
func (m *HyperOptMutation) SetStakeAmount(f float64) {
	m.stake_amount = &f
	m.addstake_amount = nil
}

// StakeAmount returns the value of the "stake_amount" field in the mutation.
func (m *HyperOptMutation) StakeAmount() (r float64, exists bool) {
	v := m.stake_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStakeAmount returns the old "stake_amount" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldStakeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakeAmount: %w", err)
	}
	return oldValue.StakeAmount, nil
}

// AddStakeAmount adds f to the "stake_amount" field.
func (m *HyperOptMutation) AddStakeAmount(f float64) {
	if m.addstake_amount != nil {
		*m.addstake_amount += f
	} else {
		m.addstake_amount = &f
	}
}

// AddedStakeAmount returns the value that was added to the "stake_amount" field in this mutation.
func (m *HyperOptMutation) AddedStakeAmount() (r float64, exists bool) {
	v := m.addstake_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetStakeAmount resets all changes to the "stake_amount" field.
func (m *HyperOptMutation) ResetStakeAmount() {
	m.stake_amount = nil
	m.addstake_amount = nil
}

// SetStakeCurrency sets the "stake_currency" field.
func (m *HyperOptMutation) SetStakeCurrency(s string) {
	m.stake_currency = &s
}

// StakeCurrency returns the value of the "stake_currency" field in the mutation.
func (m *HyperOptMutation) StakeCurrency() (r string, exists bool) {
	v := m.stake_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldStakeCurrency returns the old "stake_currency" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldStakeCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakeCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakeCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakeCurrency: %w", err)
	}
	return oldValue.StakeCurrency, nil
}

// ResetStakeCurrency resets all changes to the "stake_currency" field.
func (m *HyperOptMutation) ResetStakeCurrency() {
	m.stake_currency = nil
}

// SetPairs sets the "pairs" field.
func (m *HyperOptMutation) SetPairs(s []string) {
	m.pairs = &s
	m.appendpairs = nil
}

// Pairs returns the value of the "pairs" field in the mutation.
func (m *HyperOptMutation) Pairs() (r []string, exists bool) {
	v := m.pairs
	if v == nil {
		return
	}
	return *v, true
}

// OldPairs returns the old "pairs" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldPairs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPairs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPairs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPairs: %w", err)
	}
	return oldValue.Pairs, nil
}

// AppendPairs adds s to the "pairs" field.
func (m *HyperOptMutation) AppendPairs(s []string) {
	m.appendpairs = append(m.appendpairs, s...)
}

// AppendedPairs returns the list of values that were appended to the "pairs" field in this mutation.
func (m *HyperOptMutation) AppendedPairs() ([]string, bool) {
	if len(m.appendpairs) == 0 {
		return nil, false
	}
	return m.appendpairs, true
}

// ResetPairs resets all changes to the "pairs" field.
func (m *HyperOptMutation) ResetPairs() {
	m.pairs = nil
	m.appendpairs = nil
}

// SetOptimizationMetric sets the "optimization_metric" field.
func (m *HyperOptMutation) SetOptimizationMetric(em enum.OptimizationMetric) {
	m.optimization_metric = &em
}

// OptimizationMetric returns the value of the "optimization_metric" field in the mutation.
func (m *HyperOptMutation) OptimizationMetric() (r enum.OptimizationMetric, exists bool) {
	v := m.optimization_metric
	if v == nil {
		return
	}
	return *v, true
}

// OldOptimizationMetric returns the old "optimization_metric" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldOptimizationMetric(ctx context.Context) (v enum.OptimizationMetric, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptimizationMetric is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptimizationMetric requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptimizationMetric: %w", err)
	}
	return oldValue.OptimizationMetric, nil
}

// ResetOptimizationMetric resets all changes to the "optimization_metric" field.
func (m *HyperOptMutation) ResetOptimizationMetric() {
	m.optimization_metric = nil
}

// SetSpaces sets the "spaces" field.
func (m *HyperOptMutation) SetSpaces(s []string) {
	m.spaces = &s
	m.appendspaces = nil
}

// Spaces returns the value of the "spaces" field in the mutation.
func (m *HyperOptMutation) Spaces() (r []string, exists bool) {
	v := m.spaces
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaces returns the old "spaces" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldSpaces(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaces is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaces requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaces: %w", err)
	}
	return oldValue.Spaces, nil
}

// AppendSpaces adds s to the "spaces" field.
func (m *HyperOptMutation) AppendSpaces(s []string) {
	m.appendspaces = append(m.appendspaces, s...)
}

// AppendedSpaces returns the list of values that were appended to the "spaces" field in this mutation.
func (m *HyperOptMutation) AppendedSpaces() ([]string, bool) {
	if len(m.appendspaces) == 0 {
		return nil, false
	}
	return m.appendspaces, true
}

// ResetSpaces resets all changes to the "spaces" field.
func (m *HyperOptMutation) ResetSpaces() {
	m.spaces = nil
	m.appendspaces = nil
}

// SetResults sets the "results" field.
func (m *HyperOptMutation) SetResults(value map[string]interface{}) {
	m.results = &value
}

// Results returns the value of the "results" field in the mutation.
func (m *HyperOptMutation) Results() (r map[string]interface{}, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldResults(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// ClearResults clears the value of the "results" field.
func (m *HyperOptMutation) ClearResults() {
	m.results = nil
	m.clearedFields[hyperopt.FieldResults] = struct{}{}
}

// ResultsCleared returns if the "results" field was cleared in this mutation.
func (m *HyperOptMutation) ResultsCleared() bool {
	_, ok := m.clearedFields[hyperopt.FieldResults]
	return ok
}

// ResetResults resets all changes to the "results" field.
func (m *HyperOptMutation) ResetResults() {
	m.results = nil
	delete(m.clearedFields, hyperopt.FieldResults)
}

// SetConfig sets the "config" field.
func (m *HyperOptMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *HyperOptMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *HyperOptMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[hyperopt.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *HyperOptMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[hyperopt.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *HyperOptMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, hyperopt.FieldConfig)
}

// SetRuntimeID sets the "runtime_id" field.
func (m *HyperOptMutation) SetRuntimeID(s string) {
	m.runtime_id = &s
}

// RuntimeID returns the value of the "runtime_id" field in the mutation.
func (m *HyperOptMutation) RuntimeID() (r string, exists bool) {
	v := m.runtime_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntimeID returns the old "runtime_id" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldRuntimeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuntimeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuntimeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntimeID: %w", err)
	}
	return oldValue.RuntimeID, nil
}

// ClearRuntimeID clears the value of the "runtime_id" field.
func (m *HyperOptMutation) ClearRuntimeID() {
	m.runtime_id = nil
	m.clearedFields[hyperopt.FieldRuntimeID] = struct{}{}
}

// RuntimeIDCleared returns if the "runtime_id" field was cleared in this mutation.
func (m *HyperOptMutation) RuntimeIDCleared() bool {
	_, ok := m.clearedFields[hyperopt.FieldRuntimeID]
	return ok
}

// ResetRuntimeID resets all changes to the "runtime_id" field.
func (m *HyperOptMutation) ResetRuntimeID() {
	m.runtime_id = nil
	delete(m.clearedFields, hyperopt.FieldRuntimeID)
}

// SetLogOutput sets the "log_output" field.
func (m *HyperOptMutation) SetLogOutput(s string) {
	m.log_output = &s
}

// LogOutput returns the value of the "log_output" field in the mutation.
func (m *HyperOptMutation) LogOutput() (r string, exists bool) {
	v := m.log_output
	if v == nil {
		return
	}
	return *v, true
}

// OldLogOutput returns the old "log_output" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldLogOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogOutput: %w", err)
	}
	return oldValue.LogOutput, nil
}

// ClearLogOutput clears the value of the "log_output" field.
func (m *HyperOptMutation) ClearLogOutput() {
	m.log_output = nil
	m.clearedFields[hyperopt.FieldLogOutput] = struct{}{}
}

// LogOutputCleared returns if the "log_output" field was cleared in this mutation.
func (m *HyperOptMutation) LogOutputCleared() bool {
	_, ok := m.clearedFields[hyperopt.FieldLogOutput]
	return ok
}

// ResetLogOutput resets all changes to the "log_output" field.
func (m *HyperOptMutation) ResetLogOutput() {
	m.log_output = nil
	delete(m.clearedFields, hyperopt.FieldLogOutput)
}

// SetProgress sets the "progress" field.
func (m *HyperOptMutation) SetProgress(f float64) {
	m.progress = &f
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *HyperOptMutation) Progress() (r float64, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldProgress(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds f to the "progress" field.
func (m *HyperOptMutation) AddProgress(f float64) {
	if m.addprogress != nil {
		*m.addprogress += f
	} else {
		m.addprogress = &f
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *HyperOptMutation) AddedProgress() (r float64, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *HyperOptMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *HyperOptMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *HyperOptMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *HyperOptMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[hyperopt.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *HyperOptMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[hyperopt.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *HyperOptMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, hyperopt.FieldErrorMessage)
}

// SetStrategyID sets the "strategy_id" field.
func (m *HyperOptMutation) SetStrategyID(u uuid.UUID) {
	m.strategy = &u
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *HyperOptMutation) StrategyID() (r uuid.UUID, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldStrategyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *HyperOptMutation) ResetStrategyID() {
	m.strategy = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HyperOptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HyperOptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HyperOptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HyperOptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HyperOptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HyperOptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *HyperOptMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *HyperOptMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the HyperOpt entity.
// If the HyperOpt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HyperOptMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *HyperOptMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[hyperopt.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *HyperOptMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[hyperopt.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *HyperOptMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, hyperopt.FieldCompletedAt)
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *HyperOptMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[hyperopt.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *HyperOptMutation) StrategyCleared() bool {
	return m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *HyperOptMutation) StrategyIDs() (ids []uuid.UUID) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *HyperOptMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// Where appends a list predicates to the HyperOptMutation builder.
func (m *HyperOptMutation) Where(ps ...predicate.HyperOpt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HyperOptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HyperOptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HyperOpt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HyperOptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HyperOptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HyperOpt).
func (m *HyperOptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HyperOptMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.status != nil {
		fields = append(fields, hyperopt.FieldStatus)
	}
	if m.epochs != nil {
		fields = append(fields, hyperopt.FieldEpochs)
	}
	if m.start_date != nil {
		fields = append(fields, hyperopt.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, hyperopt.FieldEndDate)
	}
	if m.timeframe != nil {
		fields = append(fields, hyperopt.FieldTimeframe)
	}
	if m.stake_amount != nil {
		fields = append(fields, hyperopt.FieldStakeAmount)
	}
	if m.stake_currency != nil {
		fields = append(fields, hyperopt.FieldStakeCurrency)
	}
	if m.pairs != nil {
		fields = append(fields, hyperopt.FieldPairs)
	}
	if m.optimization_metric != nil {
		fields = append(fields, hyperopt.FieldOptimizationMetric)
	}
	if m.spaces != nil {
		fields = append(fields, hyperopt.FieldSpaces)
	}
	if m.results != nil {
		fields = append(fields, hyperopt.FieldResults)
	}
	if m._config != nil {
		fields = append(fields, hyperopt.FieldConfig)
	}
	if m.runtime_id != nil {
		fields = append(fields, hyperopt.FieldRuntimeID)
	}
	if m.log_output != nil {
		fields = append(fields, hyperopt.FieldLogOutput)
	}
	if m.progress != nil {
		fields = append(fields, hyperopt.FieldProgress)
	}
	if m.error_message != nil {
		fields = append(fields, hyperopt.FieldErrorMessage)
	}
	if m.strategy != nil {
		fields = append(fields, hyperopt.FieldStrategyID)
	}
	if m.created_at != nil {
		fields = append(fields, hyperopt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hyperopt.FieldUpdatedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, hyperopt.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HyperOptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hyperopt.FieldStatus:
		return m.Status()
	case hyperopt.FieldEpochs:
		return m.Epochs()
	case hyperopt.FieldStartDate:
		return m.StartDate()
	case hyperopt.FieldEndDate:
		return m.EndDate()
	case hyperopt.FieldTimeframe:
		return m.Timeframe()
	case hyperopt.FieldStakeAmount:
		return m.StakeAmount()
	case hyperopt.FieldStakeCurrency:
		return m.StakeCurrency()
	case hyperopt.FieldPairs:
		return m.Pairs()
	case hyperopt.FieldOptimizationMetric:
		return m.OptimizationMetric()
	case hyperopt.FieldSpaces:
		return m.Spaces()
	case hyperopt.FieldResults:
		return m.Results()
	case hyperopt.FieldConfig:
		return m.Config()
	case hyperopt.FieldRuntimeID:
		return m.RuntimeID()
	case hyperopt.FieldLogOutput:
		return m.LogOutput()
	case hyperopt.FieldProgress:
		return m.Progress()
	case hyperopt.FieldErrorMessage:
		return m.ErrorMessage()
	case hyperopt.FieldStrategyID:
		return m.StrategyID()
	case hyperopt.FieldCreatedAt:
		return m.CreatedAt()
	case hyperopt.FieldUpdatedAt:
		return m.UpdatedAt()
	case hyperopt.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HyperOptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hyperopt.FieldStatus:
		return m.OldStatus(ctx)
	case hyperopt.FieldEpochs:
		return m.OldEpochs(ctx)
	case hyperopt.FieldStartDate:
		return m.OldStartDate(ctx)
	case hyperopt.FieldEndDate:
		return m.OldEndDate(ctx)
	case hyperopt.FieldTimeframe:
		return m.OldTimeframe(ctx)
	case hyperopt.FieldStakeAmount:
		return m.OldStakeAmount(ctx)
	case hyperopt.FieldStakeCurrency:
		return m.OldStakeCurrency(ctx)
	case hyperopt.FieldPairs:
		return m.OldPairs(ctx)
	case hyperopt.FieldOptimizationMetric:
		return m.OldOptimizationMetric(ctx)
	case hyperopt.FieldSpaces:
		return m.OldSpaces(ctx)
	case hyperopt.FieldResults:
		return m.OldResults(ctx)
	case hyperopt.FieldConfig:
		return m.OldConfig(ctx)
	case hyperopt.FieldRuntimeID:
		return m.OldRuntimeID(ctx)
	case hyperopt.FieldLogOutput:
		return m.OldLogOutput(ctx)
	case hyperopt.FieldProgress:
		return m.OldProgress(ctx)
	case hyperopt.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case hyperopt.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case hyperopt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hyperopt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hyperopt.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown HyperOpt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HyperOptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hyperopt.FieldStatus:
		v, ok := value.(enum.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hyperopt.FieldEpochs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpochs(v)
		return nil
	case hyperopt.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case hyperopt.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case hyperopt.FieldTimeframe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeframe(v)
		return nil
	case hyperopt.FieldStakeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakeAmount(v)
		return nil
	case hyperopt.FieldStakeCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakeCurrency(v)
		return nil
	case hyperopt.FieldPairs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPairs(v)
		return nil
	case hyperopt.FieldOptimizationMetric:
		v, ok := value.(enum.OptimizationMetric)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptimizationMetric(v)
		return nil
	case hyperopt.FieldSpaces:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaces(v)
		return nil
	case hyperopt.FieldResults:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	case hyperopt.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case hyperopt.FieldRuntimeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntimeID(v)
		return nil
	case hyperopt.FieldLogOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogOutput(v)
		return nil
	case hyperopt.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case hyperopt.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case hyperopt.FieldStrategyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case hyperopt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hyperopt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hyperopt.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown HyperOpt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HyperOptMutation) AddedFields() []string {
	var fields []string
	if m.addepochs != nil {
		fields = append(fields, hyperopt.FieldEpochs)
	}
	if m.addstake_amount != nil {
		fields = append(fields, hyperopt.FieldStakeAmount)
	}
	if m.addprogress != nil {
		fields = append(fields, hyperopt.FieldProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HyperOptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hyperopt.FieldEpochs:
		return m.AddedEpochs()
	case hyperopt.FieldStakeAmount:
		return m.AddedStakeAmount()
	case hyperopt.FieldProgress:
		return m.AddedProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HyperOptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hyperopt.FieldEpochs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpochs(v)
		return nil
	case hyperopt.FieldStakeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStakeAmount(v)
		return nil
	case hyperopt.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	}
	return fmt.Errorf("unknown HyperOpt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HyperOptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hyperopt.FieldResults) {
		fields = append(fields, hyperopt.FieldResults)
	}
	if m.FieldCleared(hyperopt.FieldConfig) {
		fields = append(fields, hyperopt.FieldConfig)
	}
	if m.FieldCleared(hyperopt.FieldRuntimeID) {
		fields = append(fields, hyperopt.FieldRuntimeID)
	}
	if m.FieldCleared(hyperopt.FieldLogOutput) {
		fields = append(fields, hyperopt.FieldLogOutput)
	}
	if m.FieldCleared(hyperopt.FieldErrorMessage) {
		fields = append(fields, hyperopt.FieldErrorMessage)
	}
	if m.FieldCleared(hyperopt.FieldCompletedAt) {
		fields = append(fields, hyperopt.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HyperOptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HyperOptMutation) ClearField(name string) error {
	switch name {
	case hyperopt.FieldResults:
		m.ClearResults()
		return nil
	case hyperopt.FieldConfig:
		m.ClearConfig()
		return nil
	case hyperopt.FieldRuntimeID:
		m.ClearRuntimeID()
		return nil
	case hyperopt.FieldLogOutput:
		m.ClearLogOutput()
		return nil
	case hyperopt.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case hyperopt.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown HyperOpt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HyperOptMutation) ResetField(name string) error {
	switch name {
	case hyperopt.FieldStatus:
		m.ResetStatus()
		return nil
	case hyperopt.FieldEpochs:
		m.ResetEpochs()
		return nil
	case hyperopt.FieldStartDate:
		m.ResetStartDate()
		return nil
	case hyperopt.FieldEndDate:
		m.ResetEndDate()
		return nil
	case hyperopt.FieldTimeframe:
		m.ResetTimeframe()
		return nil
	case hyperopt.FieldStakeAmount:
		m.ResetStakeAmount()
		return nil
	case hyperopt.FieldStakeCurrency:
		m.ResetStakeCurrency()
		return nil
	case hyperopt.FieldPairs:
		m.ResetPairs()
		return nil
	case hyperopt.FieldOptimizationMetric:
		m.ResetOptimizationMetric()
		return nil
	case hyperopt.FieldSpaces:
		m.ResetSpaces()
		return nil
	case hyperopt.FieldResults:
		m.ResetResults()
		return nil
	case hyperopt.FieldConfig:
		m.ResetConfig()
		return nil
	case hyperopt.FieldRuntimeID:
		m.ResetRuntimeID()
		return nil
	case hyperopt.FieldLogOutput:
		m.ResetLogOutput()
		return nil
	case hyperopt.FieldProgress:
		m.ResetProgress()
		return nil
	case hyperopt.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case hyperopt.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case hyperopt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hyperopt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hyperopt.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown HyperOpt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HyperOptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.strategy != nil {
		edges = append(edges, hyperopt.EdgeStrategy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HyperOptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hyperopt.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HyperOptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HyperOptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HyperOptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstrategy {
		edges = append(edges, hyperopt.EdgeStrategy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HyperOptMutation) EdgeCleared(name string) bool {
	switch name {
	case hyperopt.EdgeStrategy:
		return m.clearedstrategy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HyperOptMutation) ClearEdge(name string) error {
	switch name {
	case hyperopt.EdgeStrategy:
		m.ClearStrategy()
		return nil
	}
	return fmt.Errorf("unknown HyperOpt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HyperOptMutation) ResetEdge(name string) error {
	switch name {
	case hyperopt.EdgeStrategy:
		m.ResetStrategy()
		return nil
	}
	return fmt.Errorf("unknown HyperOpt edge %s", name)
}

// StrategyMutation represents an operation that mutates the Strategy nodes in the graph.
type StrategyMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	description      *string
	code             *string
	version          *string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	bots             map[uuid.UUID]struct{}
	removedbots      map[uuid.UUID]struct{}
	clearedbots      bool
	backtests        map[uuid.UUID]struct{}
	removedbacktests map[uuid.UUID]struct{}
	clearedbacktests bool
	hyperopts        map[uuid.UUID]struct{}
	removedhyperopts map[uuid.UUID]struct{}
	clearedhyperopts bool
	done             bool
	oldValue         func(context.Context) (*Strategy, error)
	predicates       []predicate.Strategy
}

var _ ent.Mutation = (*StrategyMutation)(nil)

// strategyOption allows management of the mutation configuration using functional options.
type strategyOption func(*StrategyMutation)

// newStrategyMutation creates new mutation for the Strategy entity.
func newStrategyMutation(c config, op Op, opts ...strategyOption) *StrategyMutation {
	m := &StrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyID sets the ID field of the mutation.
func withStrategyID(id uuid.UUID) strategyOption {
	return func(m *StrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *Strategy
		)
		m.oldValue = func(ctx context.Context) (*Strategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Strategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategy sets the old Strategy of the mutation.
func withStrategy(node *Strategy) strategyOption {
	return func(m *StrategyMutation) {
		m.oldValue = func(context.Context) (*Strategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Strategy entities.
func (m *StrategyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Strategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *StrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[strategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[strategy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, strategy.FieldDescription)
}

// SetCode sets the "code" field.
func (m *StrategyMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *StrategyMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *StrategyMutation) ResetCode() {
	m.code = nil
}

// SetVersion sets the "version" field.
func (m *StrategyMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *StrategyMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *StrategyMutation) ResetVersion() {
	m.version = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StrategyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StrategyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StrategyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StrategyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StrategyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StrategyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBotIDs adds the "bots" edge to the Bot entity by ids.
func (m *StrategyMutation) AddBotIDs(ids ...uuid.UUID) {
	if m.bots == nil {
		m.bots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bots[ids[i]] = struct{}{}
	}
}

// ClearBots clears the "bots" edge to the Bot entity.
func (m *StrategyMutation) ClearBots() {
	m.clearedbots = true
}

// BotsCleared reports if the "bots" edge to the Bot entity was cleared.
func (m *StrategyMutation) BotsCleared() bool {
	return m.clearedbots
}

// RemoveBotIDs removes the "bots" edge to the Bot entity by IDs.
func (m *StrategyMutation) RemoveBotIDs(ids ...uuid.UUID) {
	if m.removedbots == nil {
		m.removedbots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bots, ids[i])
		m.removedbots[ids[i]] = struct{}{}
	}
}

// RemovedBots returns the removed IDs of the "bots" edge to the Bot entity.
func (m *StrategyMutation) RemovedBotsIDs() (ids []uuid.UUID) {
	for id := range m.removedbots {
		ids = append(ids, id)
	}
	return
}

// BotsIDs returns the "bots" edge IDs in the mutation.
func (m *StrategyMutation) BotsIDs() (ids []uuid.UUID) {
	for id := range m.bots {
		ids = append(ids, id)
	}
	return
}

// ResetBots resets all changes to the "bots" edge.
func (m *StrategyMutation) ResetBots() {
	m.bots = nil
	m.clearedbots = false
	m.removedbots = nil
}

// AddBacktestIDs adds the "backtests" edge to the Backtest entity by ids.
func (m *StrategyMutation) AddBacktestIDs(ids ...uuid.UUID) {
	if m.backtests == nil {
		m.backtests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.backtests[ids[i]] = struct{}{}
	}
}

// ClearBacktests clears the "backtests" edge to the Backtest entity.
func (m *StrategyMutation) ClearBacktests() {
	m.clearedbacktests = true
}

// BacktestsCleared reports if the "backtests" edge to the Backtest entity was cleared.
func (m *StrategyMutation) BacktestsCleared() bool {
	return m.clearedbacktests
}

// RemoveBacktestIDs removes the "backtests" edge to the Backtest entity by IDs.
func (m *StrategyMutation) RemoveBacktestIDs(ids ...uuid.UUID) {
	if m.removedbacktests == nil {
		m.removedbacktests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.backtests, ids[i])
		m.removedbacktests[ids[i]] = struct{}{}
	}
}

// RemovedBacktests returns the removed IDs of the "backtests" edge to the Backtest entity.
func (m *StrategyMutation) RemovedBacktestsIDs() (ids []uuid.UUID) {
	for id := range m.removedbacktests {
		ids = append(ids, id)
	}
	return
}

// BacktestsIDs returns the "backtests" edge IDs in the mutation.
func (m *StrategyMutation) BacktestsIDs() (ids []uuid.UUID) {
	for id := range m.backtests {
		ids = append(ids, id)
	}
	return
}

// ResetBacktests resets all changes to the "backtests" edge.
func (m *StrategyMutation) ResetBacktests() {
	m.backtests = nil
	m.clearedbacktests = false
	m.removedbacktests = nil
}

// AddHyperoptIDs adds the "hyperopts" edge to the HyperOpt entity by ids.
func (m *StrategyMutation) AddHyperoptIDs(ids ...uuid.UUID) {
	if m.hyperopts == nil {
		m.hyperopts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hyperopts[ids[i]] = struct{}{}
	}
}

// ClearHyperopts clears the "hyperopts" edge to the HyperOpt entity.
func (m *StrategyMutation) ClearHyperopts() {
	m.clearedhyperopts = true
}

// HyperoptsCleared reports if the "hyperopts" edge to the HyperOpt entity was cleared.
func (m *StrategyMutation) HyperoptsCleared() bool {
	return m.clearedhyperopts
}

// RemoveHyperoptIDs removes the "hyperopts" edge to the HyperOpt entity by IDs.
func (m *StrategyMutation) RemoveHyperoptIDs(ids ...uuid.UUID) {
	if m.removedhyperopts == nil {
		m.removedhyperopts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hyperopts, ids[i])
		m.removedhyperopts[ids[i]] = struct{}{}
	}
}

// RemovedHyperopts returns the removed IDs of the "hyperopts" edge to the HyperOpt entity.
func (m *StrategyMutation) RemovedHyperoptsIDs() (ids []uuid.UUID) {
	for id := range m.removedhyperopts {
		ids = append(ids, id)
	}
	return
}

// HyperoptsIDs returns the "hyperopts" edge IDs in the mutation.
func (m *StrategyMutation) HyperoptsIDs() (ids []uuid.UUID) {
	for id := range m.hyperopts {
		ids = append(ids, id)
	}
	return
}

// ResetHyperopts resets all changes to the "hyperopts" edge.
func (m *StrategyMutation) ResetHyperopts() {
	m.hyperopts = nil
	m.clearedhyperopts = false
	m.removedhyperopts = nil
}

// Where appends a list predicates to the StrategyMutation builder.
func (m *StrategyMutation) Where(ps ...predicate.Strategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Strategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Strategy).
func (m *StrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, strategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, strategy.FieldDescription)
	}
	if m.code != nil {
		fields = append(fields, strategy.FieldCode)
	}
	if m.version != nil {
		fields = append(fields, strategy.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, strategy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, strategy.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldName:
		return m.Name()
	case strategy.FieldDescription:
		return m.Description()
	case strategy.FieldCode:
		return m.Code()
	case strategy.FieldVersion:
		return m.Version()
	case strategy.FieldCreatedAt:
		return m.CreatedAt()
	case strategy.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategy.FieldName:
		return m.OldName(ctx)
	case strategy.FieldDescription:
		return m.OldDescription(ctx)
	case strategy.FieldCode:
		return m.OldCode(ctx)
	case strategy.FieldVersion:
		return m.OldVersion(ctx)
	case strategy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case strategy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Strategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case strategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case strategy.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case strategy.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case strategy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case strategy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Strategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategy.FieldDescription) {
		fields = append(fields, strategy.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyMutation) ClearField(name string) error {
	switch name {
	case strategy.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Strategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyMutation) ResetField(name string) error {
	switch name {
	case strategy.FieldName:
		m.ResetName()
		return nil
	case strategy.FieldDescription:
		m.ResetDescription()
		return nil
	case strategy.FieldCode:
		m.ResetCode()
		return nil
	case strategy.FieldVersion:
		m.ResetVersion()
		return nil
	case strategy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case strategy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.bots != nil {
		edges = append(edges, strategy.EdgeBots)
	}
	if m.backtests != nil {
		edges = append(edges, strategy.EdgeBacktests)
	}
	if m.hyperopts != nil {
		edges = append(edges, strategy.EdgeHyperopts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeBots:
		ids := make([]ent.Value, 0, len(m.bots))
		for id := range m.bots {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeBacktests:
		ids := make([]ent.Value, 0, len(m.backtests))
		for id := range m.backtests {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeHyperopts:
		ids := make([]ent.Value, 0, len(m.hyperopts))
		for id := range m.hyperopts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbots != nil {
		edges = append(edges, strategy.EdgeBots)
	}
	if m.removedbacktests != nil {
		edges = append(edges, strategy.EdgeBacktests)
	}
	if m.removedhyperopts != nil {
		edges = append(edges, strategy.EdgeHyperopts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeBots:
		ids := make([]ent.Value, 0, len(m.removedbots))
		for id := range m.removedbots {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeBacktests:
		ids := make([]ent.Value, 0, len(m.removedbacktests))
		for id := range m.removedbacktests {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeHyperopts:
		ids := make([]ent.Value, 0, len(m.removedhyperopts))
		for id := range m.removedhyperopts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbots {
		edges = append(edges, strategy.EdgeBots)
	}
	if m.clearedbacktests {
		edges = append(edges, strategy.EdgeBacktests)
	}
	if m.clearedhyperopts {
		edges = append(edges, strategy.EdgeHyperopts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyMutation) EdgeCleared(name string) bool {
	switch name {
	case strategy.EdgeBots:
		return m.clearedbots
	case strategy.EdgeBacktests:
		return m.clearedbacktests
	case strategy.EdgeHyperopts:
		return m.clearedhyperopts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Strategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyMutation) ResetEdge(name string) error {
	switch name {
	case strategy.EdgeBots:
		m.ResetBots()
		return nil
	case strategy.EdgeBacktests:
		m.ResetBacktests()
		return nil
	case strategy.EdgeHyperopts:
		m.ResetHyperopts()
		return nil
	}
	return fmt.Errorf("unknown Strategy edge %s", name)
}

// TradeMutation represents an operation that mutates the Trade nodes in the graph.
type TradeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	freqtrade_trade_id    *int
	addfreqtrade_trade_id *int
	pair                  *string
	is_open               *bool
	open_date             *time.Time
	close_date            *time.Time
	open_rate             *float64
	addopen_rate          *float64
	close_rate            *float64
	addclose_rate         *float64
	amount                *float64
	addamount             *float64
	stake_amount          *float64
	addstake_amount       *float64
	profit_abs            *float64
	addprofit_abs         *float64
	profit_ratio          *float64
	addprofit_ratio       *float64
	sell_reason           *string
	strategy_name         *string
	timeframe             *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	bot                   *uuid.UUID
	clearedbot            bool
	done                  bool
	oldValue              func(context.Context) (*Trade, error)
	predicates            []predicate.Trade
}

var _ ent.Mutation = (*TradeMutation)(nil)

// tradeOption allows management of the mutation configuration using functional options.
type tradeOption func(*TradeMutation)

// newTradeMutation creates new mutation for the Trade entity.
func newTradeMutation(c config, op Op, opts ...tradeOption) *TradeMutation {
	m := &TradeMutation{
		config:        c,
		op:            op,
		typ:           TypeTrade,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTradeID sets the ID field of the mutation.
func withTradeID(id uuid.UUID) tradeOption {
	return func(m *TradeMutation) {
		var (
			err   error
			once  sync.Once
			value *Trade
		)
		m.oldValue = func(ctx context.Context) (*Trade, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trade.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrade sets the old Trade of the mutation.
func withTrade(node *Trade) tradeOption {
	return func(m *TradeMutation) {
		m.oldValue = func(context.Context) (*Trade, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TradeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TradeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Trade entities.
func (m *TradeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TradeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TradeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trade.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFreqtradeTradeID sets the "freqtrade_trade_id" field.
func (m *TradeMutation) SetFreqtradeTradeID(i int) {
	m.freqtrade_trade_id = &i
	m.addfreqtrade_trade_id = nil
}

// FreqtradeTradeID returns the value of the "freqtrade_trade_id" field in the mutation.
func (m *TradeMutation) FreqtradeTradeID() (r int, exists bool) {
	v := m.freqtrade_trade_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFreqtradeTradeID returns the old "freqtrade_trade_id" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldFreqtradeTradeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreqtradeTradeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreqtradeTradeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreqtradeTradeID: %w", err)
	}
	return oldValue.FreqtradeTradeID, nil
}

// AddFreqtradeTradeID adds i to the "freqtrade_trade_id" field.
func (m *TradeMutation) AddFreqtradeTradeID(i int) {
	if m.addfreqtrade_trade_id != nil {
		*m.addfreqtrade_trade_id += i
	} else {
		m.addfreqtrade_trade_id = &i
	}
}

// AddedFreqtradeTradeID returns the value that was added to the "freqtrade_trade_id" field in this mutation.
func (m *TradeMutation) AddedFreqtradeTradeID() (r int, exists bool) {
	v := m.addfreqtrade_trade_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFreqtradeTradeID resets all changes to the "freqtrade_trade_id" field.
func (m *TradeMutation) ResetFreqtradeTradeID() {
	m.freqtrade_trade_id = nil
	m.addfreqtrade_trade_id = nil
}

// SetPair sets the "pair" field.
func (m *TradeMutation) SetPair(s string) {
	m.pair = &s
}

// Pair returns the value of the "pair" field in the mutation.
func (m *TradeMutation) Pair() (r string, exists bool) {
	v := m.pair
	if v == nil {
		return
	}
	return *v, true
}

// OldPair returns the old "pair" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldPair(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPair is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPair requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPair: %w", err)
	}
	return oldValue.Pair, nil
}

// ResetPair resets all changes to the "pair" field.
func (m *TradeMutation) ResetPair() {
	m.pair = nil
}

// SetIsOpen sets the "is_open" field.
func (m *TradeMutation) SetIsOpen(b bool) {
	m.is_open = &b
}

// IsOpen returns the value of the "is_open" field in the mutation.
func (m *TradeMutation) IsOpen() (r bool, exists bool) {
	v := m.is_open
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOpen returns the old "is_open" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldIsOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOpen: %w", err)
	}
	return oldValue.IsOpen, nil
}

// ResetIsOpen resets all changes to the "is_open" field.
func (m *TradeMutation) ResetIsOpen() {
	m.is_open = nil
}

// SetOpenDate sets the "open_date" field.
func (m *TradeMutation) SetOpenDate(t time.Time) {
	m.open_date = &t
}

// OpenDate returns the value of the "open_date" field in the mutation.
func (m *TradeMutation) OpenDate() (r time.Time, exists bool) {
	v := m.open_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenDate returns the old "open_date" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldOpenDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenDate: %w", err)
	}
	return oldValue.OpenDate, nil
}

// ResetOpenDate resets all changes to the "open_date" field.
func (m *TradeMutation) ResetOpenDate() {
	m.open_date = nil
}

// SetCloseDate sets the "close_date" field.
func (m *TradeMutation) SetCloseDate(t time.Time) {
	m.close_date = &t
}

// CloseDate returns the value of the "close_date" field in the mutation.
func (m *TradeMutation) CloseDate() (r time.Time, exists bool) {
	v := m.close_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseDate returns the old "close_date" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldCloseDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseDate: %w", err)
	}
	return oldValue.CloseDate, nil
}

// ClearCloseDate clears the value of the "close_date" field.
func (m *TradeMutation) ClearCloseDate() {
	m.close_date = nil
	m.clearedFields[trade.FieldCloseDate] = struct{}{}
}

// CloseDateCleared returns if the "close_date" field was cleared in this mutation.
func (m *TradeMutation) CloseDateCleared() bool {
	_, ok := m.clearedFields[trade.FieldCloseDate]
	return ok
}

// ResetCloseDate resets all changes to the "close_date" field.
func (m *TradeMutation) ResetCloseDate() {
	m.close_date = nil
	delete(m.clearedFields, trade.FieldCloseDate)
}

// SetOpenRate sets the "open_rate" field.
func (m *TradeMutation) SetOpenRate(f float64) {
	m.open_rate = &f
	m.addopen_rate = nil
}

// OpenRate returns the value of the "open_rate" field in the mutation.
func (m *TradeMutation) OpenRate() (r float64, exists bool) {
	v := m.open_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenRate returns the old "open_rate" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldOpenRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenRate: %w", err)
	}
	return oldValue.OpenRate, nil
}

// AddOpenRate adds f to the "open_rate" field.
func (m *TradeMutation) AddOpenRate(f float64) {
	if m.addopen_rate != nil {
		*m.addopen_rate += f
	} else {
		m.addopen_rate = &f
	}
}

// AddedOpenRate returns the value that was added to the "open_rate" field in this mutation.
func (m *TradeMutation) AddedOpenRate() (r float64, exists bool) {
	v := m.addopen_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpenRate resets all changes to the "open_rate" field.
func (m *TradeMutation) ResetOpenRate() {
	m.open_rate = nil
	m.addopen_rate = nil
}

// SetCloseRate sets the "close_rate" field.
func (m *TradeMutation) SetCloseRate(f float64) {
	m.close_rate = &f
	m.addclose_rate = nil
}

// CloseRate returns the value of the "close_rate" field in the mutation.
func (m *TradeMutation) CloseRate() (r float64, exists bool) {
	v := m.close_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseRate returns the old "close_rate" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldCloseRate(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseRate: %w", err)
	}
	return oldValue.CloseRate, nil
}

// AddCloseRate adds f to the "close_rate" field.
func (m *TradeMutation) AddCloseRate(f float64) {
	if m.addclose_rate != nil {
		*m.addclose_rate += f
	} else {
		m.addclose_rate = &f
	}
}

// AddedCloseRate returns the value that was added to the "close_rate" field in this mutation.
func (m *TradeMutation) AddedCloseRate() (r float64, exists bool) {
	v := m.addclose_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearCloseRate clears the value of the "close_rate" field.
func (m *TradeMutation) ClearCloseRate() {
	m.close_rate = nil
	m.addclose_rate = nil
	m.clearedFields[trade.FieldCloseRate] = struct{}{}
}

// CloseRateCleared returns if the "close_rate" field was cleared in this mutation.
func (m *TradeMutation) CloseRateCleared() bool {
	_, ok := m.clearedFields[trade.FieldCloseRate]
	return ok
}

// ResetCloseRate resets all changes to the "close_rate" field.
func (m *TradeMutation) ResetCloseRate() {
	m.close_rate = nil
	m.addclose_rate = nil
	delete(m.clearedFields, trade.FieldCloseRate)
}

// SetAmount sets the "amount" field.
func (m *TradeMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TradeMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TradeMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TradeMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TradeMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStakeAmount sets the "stake_amount" field.
func (m *TradeMutation) SetStakeAmount(f float64) {
	m.stake_amount = &f
	m.addstake_amount = nil
}

// StakeAmount returns the value of the "stake_amount" field in the mutation.
func (m *TradeMutation) StakeAmount() (r float64, exists bool) {
	v := m.stake_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStakeAmount returns the old "stake_amount" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldStakeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakeAmount: %w", err)
	}
	return oldValue.StakeAmount, nil
}

// AddStakeAmount adds f to the "stake_amount" field.
func (m *TradeMutation) AddStakeAmount(f float64) {
	if m.addstake_amount != nil {
		*m.addstake_amount += f
	} else {
		m.addstake_amount = &f
	}
}

// AddedStakeAmount returns the value that was added to the "stake_amount" field in this mutation.
func (m *TradeMutation) AddedStakeAmount() (r float64, exists bool) {
	v := m.addstake_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetStakeAmount resets all changes to the "stake_amount" field.
func (m *TradeMutation) ResetStakeAmount() {
	m.stake_amount = nil
	m.addstake_amount = nil
}

// SetProfitAbs sets the "profit_abs" field.
func (m *TradeMutation) SetProfitAbs(f float64) {
	m.profit_abs = &f
	m.addprofit_abs = nil
}

// ProfitAbs returns the value of the "profit_abs" field in the mutation.
func (m *TradeMutation) ProfitAbs() (r float64, exists bool) {
	v := m.profit_abs
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAbs returns the old "profit_abs" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldProfitAbs(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAbs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAbs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAbs: %w", err)
	}
	return oldValue.ProfitAbs, nil
}

// AddProfitAbs adds f to the "profit_abs" field.
func (m *TradeMutation) AddProfitAbs(f float64) {
	if m.addprofit_abs != nil {
		*m.addprofit_abs += f
	} else {
		m.addprofit_abs = &f
	}
}

// AddedProfitAbs returns the value that was added to the "profit_abs" field in this mutation.
func (m *TradeMutation) AddedProfitAbs() (r float64, exists bool) {
	v := m.addprofit_abs
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitAbs resets all changes to the "profit_abs" field.
func (m *TradeMutation) ResetProfitAbs() {
	m.profit_abs = nil
	m.addprofit_abs = nil
}

// SetProfitRatio sets the "profit_ratio" field.
func (m *TradeMutation) SetProfitRatio(f float64) {
	m.profit_ratio = &f
	m.addprofit_ratio = nil
}

// ProfitRatio returns the value of the "profit_ratio" field in the mutation.
func (m *TradeMutation) ProfitRatio() (r float64, exists bool) {
	v := m.profit_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitRatio returns the old "profit_ratio" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldProfitRatio(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitRatio: %w", err)
	}
	return oldValue.ProfitRatio, nil
}

// AddProfitRatio adds f to the "profit_ratio" field.
func (m *TradeMutation) AddProfitRatio(f float64) {
	if m.addprofit_ratio != nil {
		*m.addprofit_ratio += f
	} else {
		m.addprofit_ratio = &f
	}
}

// AddedProfitRatio returns the value that was added to the "profit_ratio" field in this mutation.
func (m *TradeMutation) AddedProfitRatio() (r float64, exists bool) {
	v := m.addprofit_ratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitRatio resets all changes to the "profit_ratio" field.
func (m *TradeMutation) ResetProfitRatio() {
	m.profit_ratio = nil
	m.addprofit_ratio = nil
}

// SetSellReason sets the "sell_reason" field.
func (m *TradeMutation) SetSellReason(s string) {
	m.sell_reason = &s
}

// SellReason returns the value of the "sell_reason" field in the mutation.
func (m *TradeMutation) SellReason() (r string, exists bool) {
	v := m.sell_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSellReason returns the old "sell_reason" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldSellReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellReason: %w", err)
	}
	return oldValue.SellReason, nil
}

// ClearSellReason clears the value of the "sell_reason" field.
func (m *TradeMutation) ClearSellReason() {
	m.sell_reason = nil
	m.clearedFields[trade.FieldSellReason] = struct{}{}
}

// SellReasonCleared returns if the "sell_reason" field was cleared in this mutation.
func (m *TradeMutation) SellReasonCleared() bool {
	_, ok := m.clearedFields[trade.FieldSellReason]
	return ok
}

// ResetSellReason resets all changes to the "sell_reason" field.
func (m *TradeMutation) ResetSellReason() {
	m.sell_reason = nil
	delete(m.clearedFields, trade.FieldSellReason)
}

// SetStrategyName sets the "strategy_name" field.
func (m *TradeMutation) SetStrategyName(s string) {
	m.strategy_name = &s
}

// StrategyName returns the value of the "strategy_name" field in the mutation.
func (m *TradeMutation) StrategyName() (r string, exists bool) {
	v := m.strategy_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyName returns the old "strategy_name" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldStrategyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyName: %w", err)
	}
	return oldValue.StrategyName, nil
}

// ClearStrategyName clears the value of the "strategy_name" field.
func (m *TradeMutation) ClearStrategyName() {
	m.strategy_name = nil
	m.clearedFields[trade.FieldStrategyName] = struct{}{}
}

// StrategyNameCleared returns if the "strategy_name" field was cleared in this mutation.
func (m *TradeMutation) StrategyNameCleared() bool {
	_, ok := m.clearedFields[trade.FieldStrategyName]
	return ok
}

// ResetStrategyName resets all changes to the "strategy_name" field.
func (m *TradeMutation) ResetStrategyName() {
	m.strategy_name = nil
	delete(m.clearedFields, trade.FieldStrategyName)
}

// SetTimeframe sets the "timeframe" field.
func (m *TradeMutation) SetTimeframe(s string) {
	m.timeframe = &s
}

// Timeframe returns the value of the "timeframe" field in the mutation.
func (m *TradeMutation) Timeframe() (r string, exists bool) {
	v := m.timeframe
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeframe returns the old "timeframe" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldTimeframe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeframe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeframe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeframe: %w", err)
	}
	return oldValue.Timeframe, nil
}

// ClearTimeframe clears the value of the "timeframe" field.
func (m *TradeMutation) ClearTimeframe() {
	m.timeframe = nil
	m.clearedFields[trade.FieldTimeframe] = struct{}{}
}

// TimeframeCleared returns if the "timeframe" field was cleared in this mutation.
func (m *TradeMutation) TimeframeCleared() bool {
	_, ok := m.clearedFields[trade.FieldTimeframe]
	return ok
}

// ResetTimeframe resets all changes to the "timeframe" field.
func (m *TradeMutation) ResetTimeframe() {
	m.timeframe = nil
	delete(m.clearedFields, trade.FieldTimeframe)
}

// SetBotID sets the "bot_id" field.
func (m *TradeMutation) SetBotID(u uuid.UUID) {
	m.bot = &u
}

// BotID returns the value of the "bot_id" field in the mutation.
func (m *TradeMutation) BotID() (r uuid.UUID, exists bool) {
	v := m.bot
	if v == nil {
		return
	}
	return *v, true
}

// OldBotID returns the old "bot_id" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldBotID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBotID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBotID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBotID: %w", err)
	}
	return oldValue.BotID, nil
}

// ResetBotID resets all changes to the "bot_id" field.
func (m *TradeMutation) ResetBotID() {
	m.bot = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TradeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TradeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TradeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TradeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TradeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TradeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearBot clears the "bot" edge to the Bot entity.
func (m *TradeMutation) ClearBot() {
	m.clearedbot = true
	m.clearedFields[trade.FieldBotID] = struct{}{}
}

// BotCleared reports if the "bot" edge to the Bot entity was cleared.
func (m *TradeMutation) BotCleared() bool {
	return m.clearedbot
}

// BotIDs returns the "bot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BotID instead. It exists only for internal usage by the builders.
func (m *TradeMutation) BotIDs() (ids []uuid.UUID) {
	if id := m.bot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBot resets all changes to the "bot" edge.
func (m *TradeMutation) ResetBot() {
	m.bot = nil
	m.clearedbot = false
}

// Where appends a list predicates to the TradeMutation builder.
func (m *TradeMutation) Where(ps ...predicate.Trade) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TradeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TradeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trade, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TradeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TradeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trade).
func (m *TradeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TradeMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.freqtrade_trade_id != nil {
		fields = append(fields, trade.FieldFreqtradeTradeID)
	}
	if m.pair != nil {
		fields = append(fields, trade.FieldPair)
	}
	if m.is_open != nil {
		fields = append(fields, trade.FieldIsOpen)
	}
	if m.open_date != nil {
		fields = append(fields, trade.FieldOpenDate)
	}
	if m.close_date != nil {
		fields = append(fields, trade.FieldCloseDate)
	}
	if m.open_rate != nil {
		fields = append(fields, trade.FieldOpenRate)
	}
	if m.close_rate != nil {
		fields = append(fields, trade.FieldCloseRate)
	}
	if m.amount != nil {
		fields = append(fields, trade.FieldAmount)
	}
	if m.stake_amount != nil {
		fields = append(fields, trade.FieldStakeAmount)
	}
	if m.profit_abs != nil {
		fields = append(fields, trade.FieldProfitAbs)
	}
	if m.profit_ratio != nil {
		fields = append(fields, trade.FieldProfitRatio)
	}
	if m.sell_reason != nil {
		fields = append(fields, trade.FieldSellReason)
	}
	if m.strategy_name != nil {
		fields = append(fields, trade.FieldStrategyName)
	}
	if m.timeframe != nil {
		fields = append(fields, trade.FieldTimeframe)
	}
	if m.bot != nil {
		fields = append(fields, trade.FieldBotID)
	}
	if m.created_at != nil {
		fields = append(fields, trade.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trade.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TradeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trade.FieldFreqtradeTradeID:
		return m.FreqtradeTradeID()
	case trade.FieldPair:
		return m.Pair()
	case trade.FieldIsOpen:
		return m.IsOpen()
	case trade.FieldOpenDate:
		return m.OpenDate()
	case trade.FieldCloseDate:
		return m.CloseDate()
	case trade.FieldOpenRate:
		return m.OpenRate()
	case trade.FieldCloseRate:
		return m.CloseRate()
	case trade.FieldAmount:
		return m.Amount()
	case trade.FieldStakeAmount:
		return m.StakeAmount()
	case trade.FieldProfitAbs:
		return m.ProfitAbs()
	case trade.FieldProfitRatio:
		return m.ProfitRatio()
	case trade.FieldSellReason:
		return m.SellReason()
	case trade.FieldStrategyName:
		return m.StrategyName()
	case trade.FieldTimeframe:
		return m.Timeframe()
	case trade.FieldBotID:
		return m.BotID()
	case trade.FieldCreatedAt:
		return m.CreatedAt()
	case trade.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TradeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trade.FieldFreqtradeTradeID:
		return m.OldFreqtradeTradeID(ctx)
	case trade.FieldPair:
		return m.OldPair(ctx)
	case trade.FieldIsOpen:
		return m.OldIsOpen(ctx)
	case trade.FieldOpenDate:
		return m.OldOpenDate(ctx)
	case trade.FieldCloseDate:
		return m.OldCloseDate(ctx)
	case trade.FieldOpenRate:
		return m.OldOpenRate(ctx)
	case trade.FieldCloseRate:
		return m.OldCloseRate(ctx)
	case trade.FieldAmount:
		return m.OldAmount(ctx)
	case trade.FieldStakeAmount:
		return m.OldStakeAmount(ctx)
	case trade.FieldProfitAbs:
		return m.OldProfitAbs(ctx)
	case trade.FieldProfitRatio:
		return m.OldProfitRatio(ctx)
	case trade.FieldSellReason:
		return m.OldSellReason(ctx)
	case trade.FieldStrategyName:
		return m.OldStrategyName(ctx)
	case trade.FieldTimeframe:
		return m.OldTimeframe(ctx)
	case trade.FieldBotID:
		return m.OldBotID(ctx)
	case trade.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trade.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Trade field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trade.FieldFreqtradeTradeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreqtradeTradeID(v)
		return nil
	case trade.FieldPair:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPair(v)
		return nil
	case trade.FieldIsOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOpen(v)
		return nil
	case trade.FieldOpenDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenDate(v)
		return nil
	case trade.FieldCloseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseDate(v)
		return nil
	case trade.FieldOpenRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenRate(v)
		return nil
	case trade.FieldCloseRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseRate(v)
		return nil
	case trade.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case trade.FieldStakeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakeAmount(v)
		return nil
	case trade.FieldProfitAbs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAbs(v)
		return nil
	case trade.FieldProfitRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitRatio(v)
		return nil
	case trade.FieldSellReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellReason(v)
		return nil
	case trade.FieldStrategyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyName(v)
		return nil
	case trade.FieldTimeframe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeframe(v)
		return nil
	case trade.FieldBotID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBotID(v)
		return nil
	case trade.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trade.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Trade field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TradeMutation) AddedFields() []string {
	var fields []string
	if m.addfreqtrade_trade_id != nil {
		fields = append(fields, trade.FieldFreqtradeTradeID)
	}
	if m.addopen_rate != nil {
		fields = append(fields, trade.FieldOpenRate)
	}
	if m.addclose_rate != nil {
		fields = append(fields, trade.FieldCloseRate)
	}
	if m.addamount != nil {
		fields = append(fields, trade.FieldAmount)
	}
	if m.addstake_amount != nil {
		fields = append(fields, trade.FieldStakeAmount)
	}
	if m.addprofit_abs != nil {
		fields = append(fields, trade.FieldProfitAbs)
	}
	if m.addprofit_ratio != nil {
		fields = append(fields, trade.FieldProfitRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TradeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trade.FieldFreqtradeTradeID:
		return m.AddedFreqtradeTradeID()
	case trade.FieldOpenRate:
		return m.AddedOpenRate()
	case trade.FieldCloseRate:
		return m.AddedCloseRate()
	case trade.FieldAmount:
		return m.AddedAmount()
	case trade.FieldStakeAmount:
		return m.AddedStakeAmount()
	case trade.FieldProfitAbs:
		return m.AddedProfitAbs()
	case trade.FieldProfitRatio:
		return m.AddedProfitRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trade.FieldFreqtradeTradeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreqtradeTradeID(v)
		return nil
	case trade.FieldOpenRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpenRate(v)
		return nil
	case trade.FieldCloseRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCloseRate(v)
		return nil
	case trade.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case trade.FieldStakeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStakeAmount(v)
		return nil
	case trade.FieldProfitAbs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitAbs(v)
		return nil
	case trade.FieldProfitRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitRatio(v)
		return nil
	}
	return fmt.Errorf("unknown Trade numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TradeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trade.FieldCloseDate) {
		fields = append(fields, trade.FieldCloseDate)
	}
	if m.FieldCleared(trade.FieldCloseRate) {
		fields = append(fields, trade.FieldCloseRate)
	}
	if m.FieldCleared(trade.FieldSellReason) {
		fields = append(fields, trade.FieldSellReason)
	}
	if m.FieldCleared(trade.FieldStrategyName) {
		fields = append(fields, trade.FieldStrategyName)
	}
	if m.FieldCleared(trade.FieldTimeframe) {
		fields = append(fields, trade.FieldTimeframe)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TradeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TradeMutation) ClearField(name string) error {
	switch name {
	case trade.FieldCloseDate:
		m.ClearCloseDate()
		return nil
	case trade.FieldCloseRate:
		m.ClearCloseRate()
		return nil
	case trade.FieldSellReason:
		m.ClearSellReason()
		return nil
	case trade.FieldStrategyName:
		m.ClearStrategyName()
		return nil
	case trade.FieldTimeframe:
		m.ClearTimeframe()
		return nil
	}
	return fmt.Errorf("unknown Trade nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TradeMutation) ResetField(name string) error {
	switch name {
	case trade.FieldFreqtradeTradeID:
		m.ResetFreqtradeTradeID()
		return nil
	case trade.FieldPair:
		m.ResetPair()
		return nil
	case trade.FieldIsOpen:
		m.ResetIsOpen()
		return nil
	case trade.FieldOpenDate:
		m.ResetOpenDate()
		return nil
	case trade.FieldCloseDate:
		m.ResetCloseDate()
		return nil
	case trade.FieldOpenRate:
		m.ResetOpenRate()
		return nil
	case trade.FieldCloseRate:
		m.ResetCloseRate()
		return nil
	case trade.FieldAmount:
		m.ResetAmount()
		return nil
	case trade.FieldStakeAmount:
		m.ResetStakeAmount()
		return nil
	case trade.FieldProfitAbs:
		m.ResetProfitAbs()
		return nil
	case trade.FieldProfitRatio:
		m.ResetProfitRatio()
		return nil
	case trade.FieldSellReason:
		m.ResetSellReason()
		return nil
	case trade.FieldStrategyName:
		m.ResetStrategyName()
		return nil
	case trade.FieldTimeframe:
		m.ResetTimeframe()
		return nil
	case trade.FieldBotID:
		m.ResetBotID()
		return nil
	case trade.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trade.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Trade field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TradeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bot != nil {
		edges = append(edges, trade.EdgeBot)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TradeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trade.EdgeBot:
		if id := m.bot; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TradeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TradeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TradeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbot {
		edges = append(edges, trade.EdgeBot)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TradeMutation) EdgeCleared(name string) bool {
	switch name {
	case trade.EdgeBot:
		return m.clearedbot
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TradeMutation) ClearEdge(name string) error {
	switch name {
	case trade.EdgeBot:
		m.ClearBot()
		return nil
	}
	return fmt.Errorf("unknown Trade unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TradeMutation) ResetEdge(name string) error {
	switch name {
	case trade.EdgeBot:
		m.ResetBot()
		return nil
	}
	return fmt.Errorf("unknown Trade edge %s", name)
}
