// Code generated by ent, DO NOT EDIT.

package ent

import (
	"anytrade/internal/ent/backtest"
	"anytrade/internal/ent/bot"
	"anytrade/internal/ent/botrunner"
	"anytrade/internal/ent/exchange"
	"anytrade/internal/ent/predicate"
	"anytrade/internal/ent/strategy"
	"anytrade/internal/ent/trade"
	"anytrade/internal/enum"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBacktest  = "Backtest"
	TypeBot       = "Bot"
	TypeBotRunner = "BotRunner"
	TypeExchange  = "Exchange"
	TypeStrategy  = "Strategy"
	TypeTrade     = "Trade"
)

// BacktestMutation represents an operation that mutates the Backtest nodes in the graph.
type BacktestMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	status          *enum.TaskStatus
	_config         *map[string]interface{}
	result          *map[string]interface{}
	container_id    *string
	error_message   *string
	created_at      *time.Time
	updated_at      *time.Time
	completed_at    *time.Time
	clearedFields   map[string]struct{}
	strategy        *uuid.UUID
	clearedstrategy bool
	runner          *uuid.UUID
	clearedrunner   bool
	done            bool
	oldValue        func(context.Context) (*Backtest, error)
	predicates      []predicate.Backtest
}

var _ ent.Mutation = (*BacktestMutation)(nil)

// backtestOption allows management of the mutation configuration using functional options.
type backtestOption func(*BacktestMutation)

// newBacktestMutation creates new mutation for the Backtest entity.
func newBacktestMutation(c config, op Op, opts ...backtestOption) *BacktestMutation {
	m := &BacktestMutation{
		config:        c,
		op:            op,
		typ:           TypeBacktest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBacktestID sets the ID field of the mutation.
func withBacktestID(id uuid.UUID) backtestOption {
	return func(m *BacktestMutation) {
		var (
			err   error
			once  sync.Once
			value *Backtest
		)
		m.oldValue = func(ctx context.Context) (*Backtest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Backtest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBacktest sets the old Backtest of the mutation.
func withBacktest(node *Backtest) backtestOption {
	return func(m *BacktestMutation) {
		m.oldValue = func(context.Context) (*Backtest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BacktestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BacktestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Backtest entities.
func (m *BacktestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BacktestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BacktestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Backtest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *BacktestMutation) SetStatus(es enum.TaskStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *BacktestMutation) Status() (r enum.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldStatus(ctx context.Context) (v enum.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BacktestMutation) ResetStatus() {
	m.status = nil
}

// SetConfig sets the "config" field.
func (m *BacktestMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *BacktestMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *BacktestMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[backtest.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *BacktestMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[backtest.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *BacktestMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, backtest.FieldConfig)
}

// SetResult sets the "result" field.
func (m *BacktestMutation) SetResult(value map[string]interface{}) {
	m.result = &value
}

// Result returns the value of the "result" field in the mutation.
func (m *BacktestMutation) Result() (r map[string]interface{}, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldResult(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *BacktestMutation) ClearResult() {
	m.result = nil
	m.clearedFields[backtest.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *BacktestMutation) ResultCleared() bool {
	_, ok := m.clearedFields[backtest.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *BacktestMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, backtest.FieldResult)
}

// SetContainerID sets the "container_id" field.
func (m *BacktestMutation) SetContainerID(s string) {
	m.container_id = &s
}

// ContainerID returns the value of the "container_id" field in the mutation.
func (m *BacktestMutation) ContainerID() (r string, exists bool) {
	v := m.container_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerID returns the old "container_id" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldContainerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerID: %w", err)
	}
	return oldValue.ContainerID, nil
}

// ClearContainerID clears the value of the "container_id" field.
func (m *BacktestMutation) ClearContainerID() {
	m.container_id = nil
	m.clearedFields[backtest.FieldContainerID] = struct{}{}
}

// ContainerIDCleared returns if the "container_id" field was cleared in this mutation.
func (m *BacktestMutation) ContainerIDCleared() bool {
	_, ok := m.clearedFields[backtest.FieldContainerID]
	return ok
}

// ResetContainerID resets all changes to the "container_id" field.
func (m *BacktestMutation) ResetContainerID() {
	m.container_id = nil
	delete(m.clearedFields, backtest.FieldContainerID)
}

// SetErrorMessage sets the "error_message" field.
func (m *BacktestMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *BacktestMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *BacktestMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[backtest.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *BacktestMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[backtest.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *BacktestMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, backtest.FieldErrorMessage)
}

// SetStrategyID sets the "strategy_id" field.
func (m *BacktestMutation) SetStrategyID(u uuid.UUID) {
	m.strategy = &u
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *BacktestMutation) StrategyID() (r uuid.UUID, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldStrategyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *BacktestMutation) ResetStrategyID() {
	m.strategy = nil
}

// SetRunnerID sets the "runner_id" field.
func (m *BacktestMutation) SetRunnerID(u uuid.UUID) {
	m.runner = &u
}

// RunnerID returns the value of the "runner_id" field in the mutation.
func (m *BacktestMutation) RunnerID() (r uuid.UUID, exists bool) {
	v := m.runner
	if v == nil {
		return
	}
	return *v, true
}

// OldRunnerID returns the old "runner_id" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldRunnerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunnerID: %w", err)
	}
	return oldValue.RunnerID, nil
}

// ResetRunnerID resets all changes to the "runner_id" field.
func (m *BacktestMutation) ResetRunnerID() {
	m.runner = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BacktestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BacktestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BacktestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BacktestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BacktestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BacktestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *BacktestMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *BacktestMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *BacktestMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[backtest.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *BacktestMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[backtest.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *BacktestMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, backtest.FieldCompletedAt)
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *BacktestMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[backtest.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *BacktestMutation) StrategyCleared() bool {
	return m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *BacktestMutation) StrategyIDs() (ids []uuid.UUID) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *BacktestMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// ClearRunner clears the "runner" edge to the BotRunner entity.
func (m *BacktestMutation) ClearRunner() {
	m.clearedrunner = true
	m.clearedFields[backtest.FieldRunnerID] = struct{}{}
}

// RunnerCleared reports if the "runner" edge to the BotRunner entity was cleared.
func (m *BacktestMutation) RunnerCleared() bool {
	return m.clearedrunner
}

// RunnerIDs returns the "runner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunnerID instead. It exists only for internal usage by the builders.
func (m *BacktestMutation) RunnerIDs() (ids []uuid.UUID) {
	if id := m.runner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRunner resets all changes to the "runner" edge.
func (m *BacktestMutation) ResetRunner() {
	m.runner = nil
	m.clearedrunner = false
}

// Where appends a list predicates to the BacktestMutation builder.
func (m *BacktestMutation) Where(ps ...predicate.Backtest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BacktestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BacktestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Backtest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BacktestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BacktestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Backtest).
func (m *BacktestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BacktestMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.status != nil {
		fields = append(fields, backtest.FieldStatus)
	}
	if m._config != nil {
		fields = append(fields, backtest.FieldConfig)
	}
	if m.result != nil {
		fields = append(fields, backtest.FieldResult)
	}
	if m.container_id != nil {
		fields = append(fields, backtest.FieldContainerID)
	}
	if m.error_message != nil {
		fields = append(fields, backtest.FieldErrorMessage)
	}
	if m.strategy != nil {
		fields = append(fields, backtest.FieldStrategyID)
	}
	if m.runner != nil {
		fields = append(fields, backtest.FieldRunnerID)
	}
	if m.created_at != nil {
		fields = append(fields, backtest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backtest.FieldUpdatedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, backtest.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BacktestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backtest.FieldStatus:
		return m.Status()
	case backtest.FieldConfig:
		return m.Config()
	case backtest.FieldResult:
		return m.Result()
	case backtest.FieldContainerID:
		return m.ContainerID()
	case backtest.FieldErrorMessage:
		return m.ErrorMessage()
	case backtest.FieldStrategyID:
		return m.StrategyID()
	case backtest.FieldRunnerID:
		return m.RunnerID()
	case backtest.FieldCreatedAt:
		return m.CreatedAt()
	case backtest.FieldUpdatedAt:
		return m.UpdatedAt()
	case backtest.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BacktestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backtest.FieldStatus:
		return m.OldStatus(ctx)
	case backtest.FieldConfig:
		return m.OldConfig(ctx)
	case backtest.FieldResult:
		return m.OldResult(ctx)
	case backtest.FieldContainerID:
		return m.OldContainerID(ctx)
	case backtest.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case backtest.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case backtest.FieldRunnerID:
		return m.OldRunnerID(ctx)
	case backtest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backtest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case backtest.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Backtest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BacktestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backtest.FieldStatus:
		v, ok := value.(enum.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case backtest.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case backtest.FieldResult:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case backtest.FieldContainerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerID(v)
		return nil
	case backtest.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case backtest.FieldStrategyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case backtest.FieldRunnerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunnerID(v)
		return nil
	case backtest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backtest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case backtest.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Backtest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BacktestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BacktestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BacktestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Backtest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BacktestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(backtest.FieldConfig) {
		fields = append(fields, backtest.FieldConfig)
	}
	if m.FieldCleared(backtest.FieldResult) {
		fields = append(fields, backtest.FieldResult)
	}
	if m.FieldCleared(backtest.FieldContainerID) {
		fields = append(fields, backtest.FieldContainerID)
	}
	if m.FieldCleared(backtest.FieldErrorMessage) {
		fields = append(fields, backtest.FieldErrorMessage)
	}
	if m.FieldCleared(backtest.FieldCompletedAt) {
		fields = append(fields, backtest.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BacktestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BacktestMutation) ClearField(name string) error {
	switch name {
	case backtest.FieldConfig:
		m.ClearConfig()
		return nil
	case backtest.FieldResult:
		m.ClearResult()
		return nil
	case backtest.FieldContainerID:
		m.ClearContainerID()
		return nil
	case backtest.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case backtest.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Backtest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BacktestMutation) ResetField(name string) error {
	switch name {
	case backtest.FieldStatus:
		m.ResetStatus()
		return nil
	case backtest.FieldConfig:
		m.ResetConfig()
		return nil
	case backtest.FieldResult:
		m.ResetResult()
		return nil
	case backtest.FieldContainerID:
		m.ResetContainerID()
		return nil
	case backtest.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case backtest.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case backtest.FieldRunnerID:
		m.ResetRunnerID()
		return nil
	case backtest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backtest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case backtest.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Backtest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BacktestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.strategy != nil {
		edges = append(edges, backtest.EdgeStrategy)
	}
	if m.runner != nil {
		edges = append(edges, backtest.EdgeRunner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BacktestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case backtest.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	case backtest.EdgeRunner:
		if id := m.runner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BacktestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BacktestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BacktestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstrategy {
		edges = append(edges, backtest.EdgeStrategy)
	}
	if m.clearedrunner {
		edges = append(edges, backtest.EdgeRunner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BacktestMutation) EdgeCleared(name string) bool {
	switch name {
	case backtest.EdgeStrategy:
		return m.clearedstrategy
	case backtest.EdgeRunner:
		return m.clearedrunner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BacktestMutation) ClearEdge(name string) error {
	switch name {
	case backtest.EdgeStrategy:
		m.ClearStrategy()
		return nil
	case backtest.EdgeRunner:
		m.ClearRunner()
		return nil
	}
	return fmt.Errorf("unknown Backtest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BacktestMutation) ResetEdge(name string) error {
	switch name {
	case backtest.EdgeStrategy:
		m.ResetStrategy()
		return nil
	case backtest.EdgeRunner:
		m.ResetRunner()
		return nil
	}
	return fmt.Errorf("unknown Backtest edge %s", name)
}

// BotMutation represents an operation that mutates the Bot nodes in the graph.
type BotMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	status            *enum.BotStatus
	mode              *enum.BotMode
	container_id      *string
	_config           *map[string]interface{}
	freqtrade_version *string
	last_seen_at      *time.Time
	error_message     *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	exchange          *uuid.UUID
	clearedexchange   bool
	strategy          *uuid.UUID
	clearedstrategy   bool
	runner            *uuid.UUID
	clearedrunner     bool
	trades            map[uuid.UUID]struct{}
	removedtrades     map[uuid.UUID]struct{}
	clearedtrades     bool
	done              bool
	oldValue          func(context.Context) (*Bot, error)
	predicates        []predicate.Bot
}

var _ ent.Mutation = (*BotMutation)(nil)

// botOption allows management of the mutation configuration using functional options.
type botOption func(*BotMutation)

// newBotMutation creates new mutation for the Bot entity.
func newBotMutation(c config, op Op, opts ...botOption) *BotMutation {
	m := &BotMutation{
		config:        c,
		op:            op,
		typ:           TypeBot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBotID sets the ID field of the mutation.
func withBotID(id uuid.UUID) botOption {
	return func(m *BotMutation) {
		var (
			err   error
			once  sync.Once
			value *Bot
		)
		m.oldValue = func(ctx context.Context) (*Bot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBot sets the old Bot of the mutation.
func withBot(node *Bot) botOption {
	return func(m *BotMutation) {
		m.oldValue = func(context.Context) (*Bot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bot entities.
func (m *BotMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BotMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BotMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BotMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *BotMutation) SetStatus(es enum.BotStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *BotMutation) Status() (r enum.BotStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldStatus(ctx context.Context) (v enum.BotStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BotMutation) ResetStatus() {
	m.status = nil
}

// SetMode sets the "mode" field.
func (m *BotMutation) SetMode(em enum.BotMode) {
	m.mode = &em
}

// Mode returns the value of the "mode" field in the mutation.
func (m *BotMutation) Mode() (r enum.BotMode, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldMode(ctx context.Context) (v enum.BotMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *BotMutation) ResetMode() {
	m.mode = nil
}

// SetContainerID sets the "container_id" field.
func (m *BotMutation) SetContainerID(s string) {
	m.container_id = &s
}

// ContainerID returns the value of the "container_id" field in the mutation.
func (m *BotMutation) ContainerID() (r string, exists bool) {
	v := m.container_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerID returns the old "container_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldContainerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerID: %w", err)
	}
	return oldValue.ContainerID, nil
}

// ClearContainerID clears the value of the "container_id" field.
func (m *BotMutation) ClearContainerID() {
	m.container_id = nil
	m.clearedFields[bot.FieldContainerID] = struct{}{}
}

// ContainerIDCleared returns if the "container_id" field was cleared in this mutation.
func (m *BotMutation) ContainerIDCleared() bool {
	_, ok := m.clearedFields[bot.FieldContainerID]
	return ok
}

// ResetContainerID resets all changes to the "container_id" field.
func (m *BotMutation) ResetContainerID() {
	m.container_id = nil
	delete(m.clearedFields, bot.FieldContainerID)
}

// SetConfig sets the "config" field.
func (m *BotMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *BotMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *BotMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[bot.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *BotMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[bot.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *BotMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, bot.FieldConfig)
}

// SetFreqtradeVersion sets the "freqtrade_version" field.
func (m *BotMutation) SetFreqtradeVersion(s string) {
	m.freqtrade_version = &s
}

// FreqtradeVersion returns the value of the "freqtrade_version" field in the mutation.
func (m *BotMutation) FreqtradeVersion() (r string, exists bool) {
	v := m.freqtrade_version
	if v == nil {
		return
	}
	return *v, true
}

// OldFreqtradeVersion returns the old "freqtrade_version" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldFreqtradeVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreqtradeVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreqtradeVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreqtradeVersion: %w", err)
	}
	return oldValue.FreqtradeVersion, nil
}

// ResetFreqtradeVersion resets all changes to the "freqtrade_version" field.
func (m *BotMutation) ResetFreqtradeVersion() {
	m.freqtrade_version = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *BotMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *BotMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ClearLastSeenAt clears the value of the "last_seen_at" field.
func (m *BotMutation) ClearLastSeenAt() {
	m.last_seen_at = nil
	m.clearedFields[bot.FieldLastSeenAt] = struct{}{}
}

// LastSeenAtCleared returns if the "last_seen_at" field was cleared in this mutation.
func (m *BotMutation) LastSeenAtCleared() bool {
	_, ok := m.clearedFields[bot.FieldLastSeenAt]
	return ok
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *BotMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
	delete(m.clearedFields, bot.FieldLastSeenAt)
}

// SetErrorMessage sets the "error_message" field.
func (m *BotMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *BotMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *BotMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[bot.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *BotMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[bot.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *BotMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, bot.FieldErrorMessage)
}

// SetExchangeID sets the "exchange_id" field.
func (m *BotMutation) SetExchangeID(u uuid.UUID) {
	m.exchange = &u
}

// ExchangeID returns the value of the "exchange_id" field in the mutation.
func (m *BotMutation) ExchangeID() (r uuid.UUID, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeID returns the old "exchange_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldExchangeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeID: %w", err)
	}
	return oldValue.ExchangeID, nil
}

// ResetExchangeID resets all changes to the "exchange_id" field.
func (m *BotMutation) ResetExchangeID() {
	m.exchange = nil
}

// SetStrategyID sets the "strategy_id" field.
func (m *BotMutation) SetStrategyID(u uuid.UUID) {
	m.strategy = &u
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *BotMutation) StrategyID() (r uuid.UUID, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldStrategyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *BotMutation) ResetStrategyID() {
	m.strategy = nil
}

// SetRunnerID sets the "runner_id" field.
func (m *BotMutation) SetRunnerID(u uuid.UUID) {
	m.runner = &u
}

// RunnerID returns the value of the "runner_id" field in the mutation.
func (m *BotMutation) RunnerID() (r uuid.UUID, exists bool) {
	v := m.runner
	if v == nil {
		return
	}
	return *v, true
}

// OldRunnerID returns the old "runner_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldRunnerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunnerID: %w", err)
	}
	return oldValue.RunnerID, nil
}

// ResetRunnerID resets all changes to the "runner_id" field.
func (m *BotMutation) ResetRunnerID() {
	m.runner = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearExchange clears the "exchange" edge to the Exchange entity.
func (m *BotMutation) ClearExchange() {
	m.clearedexchange = true
	m.clearedFields[bot.FieldExchangeID] = struct{}{}
}

// ExchangeCleared reports if the "exchange" edge to the Exchange entity was cleared.
func (m *BotMutation) ExchangeCleared() bool {
	return m.clearedexchange
}

// ExchangeIDs returns the "exchange" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExchangeID instead. It exists only for internal usage by the builders.
func (m *BotMutation) ExchangeIDs() (ids []uuid.UUID) {
	if id := m.exchange; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExchange resets all changes to the "exchange" edge.
func (m *BotMutation) ResetExchange() {
	m.exchange = nil
	m.clearedexchange = false
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *BotMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[bot.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *BotMutation) StrategyCleared() bool {
	return m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *BotMutation) StrategyIDs() (ids []uuid.UUID) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *BotMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// ClearRunner clears the "runner" edge to the BotRunner entity.
func (m *BotMutation) ClearRunner() {
	m.clearedrunner = true
	m.clearedFields[bot.FieldRunnerID] = struct{}{}
}

// RunnerCleared reports if the "runner" edge to the BotRunner entity was cleared.
func (m *BotMutation) RunnerCleared() bool {
	return m.clearedrunner
}

// RunnerIDs returns the "runner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunnerID instead. It exists only for internal usage by the builders.
func (m *BotMutation) RunnerIDs() (ids []uuid.UUID) {
	if id := m.runner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRunner resets all changes to the "runner" edge.
func (m *BotMutation) ResetRunner() {
	m.runner = nil
	m.clearedrunner = false
}

// AddTradeIDs adds the "trades" edge to the Trade entity by ids.
func (m *BotMutation) AddTradeIDs(ids ...uuid.UUID) {
	if m.trades == nil {
		m.trades = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.trades[ids[i]] = struct{}{}
	}
}

// ClearTrades clears the "trades" edge to the Trade entity.
func (m *BotMutation) ClearTrades() {
	m.clearedtrades = true
}

// TradesCleared reports if the "trades" edge to the Trade entity was cleared.
func (m *BotMutation) TradesCleared() bool {
	return m.clearedtrades
}

// RemoveTradeIDs removes the "trades" edge to the Trade entity by IDs.
func (m *BotMutation) RemoveTradeIDs(ids ...uuid.UUID) {
	if m.removedtrades == nil {
		m.removedtrades = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.trades, ids[i])
		m.removedtrades[ids[i]] = struct{}{}
	}
}

// RemovedTrades returns the removed IDs of the "trades" edge to the Trade entity.
func (m *BotMutation) RemovedTradesIDs() (ids []uuid.UUID) {
	for id := range m.removedtrades {
		ids = append(ids, id)
	}
	return
}

// TradesIDs returns the "trades" edge IDs in the mutation.
func (m *BotMutation) TradesIDs() (ids []uuid.UUID) {
	for id := range m.trades {
		ids = append(ids, id)
	}
	return
}

// ResetTrades resets all changes to the "trades" edge.
func (m *BotMutation) ResetTrades() {
	m.trades = nil
	m.clearedtrades = false
	m.removedtrades = nil
}

// Where appends a list predicates to the BotMutation builder.
func (m *BotMutation) Where(ps ...predicate.Bot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bot).
func (m *BotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BotMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, bot.FieldName)
	}
	if m.status != nil {
		fields = append(fields, bot.FieldStatus)
	}
	if m.mode != nil {
		fields = append(fields, bot.FieldMode)
	}
	if m.container_id != nil {
		fields = append(fields, bot.FieldContainerID)
	}
	if m._config != nil {
		fields = append(fields, bot.FieldConfig)
	}
	if m.freqtrade_version != nil {
		fields = append(fields, bot.FieldFreqtradeVersion)
	}
	if m.last_seen_at != nil {
		fields = append(fields, bot.FieldLastSeenAt)
	}
	if m.error_message != nil {
		fields = append(fields, bot.FieldErrorMessage)
	}
	if m.exchange != nil {
		fields = append(fields, bot.FieldExchangeID)
	}
	if m.strategy != nil {
		fields = append(fields, bot.FieldStrategyID)
	}
	if m.runner != nil {
		fields = append(fields, bot.FieldRunnerID)
	}
	if m.created_at != nil {
		fields = append(fields, bot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bot.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bot.FieldName:
		return m.Name()
	case bot.FieldStatus:
		return m.Status()
	case bot.FieldMode:
		return m.Mode()
	case bot.FieldContainerID:
		return m.ContainerID()
	case bot.FieldConfig:
		return m.Config()
	case bot.FieldFreqtradeVersion:
		return m.FreqtradeVersion()
	case bot.FieldLastSeenAt:
		return m.LastSeenAt()
	case bot.FieldErrorMessage:
		return m.ErrorMessage()
	case bot.FieldExchangeID:
		return m.ExchangeID()
	case bot.FieldStrategyID:
		return m.StrategyID()
	case bot.FieldRunnerID:
		return m.RunnerID()
	case bot.FieldCreatedAt:
		return m.CreatedAt()
	case bot.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bot.FieldName:
		return m.OldName(ctx)
	case bot.FieldStatus:
		return m.OldStatus(ctx)
	case bot.FieldMode:
		return m.OldMode(ctx)
	case bot.FieldContainerID:
		return m.OldContainerID(ctx)
	case bot.FieldConfig:
		return m.OldConfig(ctx)
	case bot.FieldFreqtradeVersion:
		return m.OldFreqtradeVersion(ctx)
	case bot.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	case bot.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case bot.FieldExchangeID:
		return m.OldExchangeID(ctx)
	case bot.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case bot.FieldRunnerID:
		return m.OldRunnerID(ctx)
	case bot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Bot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bot.FieldStatus:
		v, ok := value.(enum.BotStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bot.FieldMode:
		v, ok := value.(enum.BotMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case bot.FieldContainerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerID(v)
		return nil
	case bot.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case bot.FieldFreqtradeVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreqtradeVersion(v)
		return nil
	case bot.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	case bot.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case bot.FieldExchangeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeID(v)
		return nil
	case bot.FieldStrategyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case bot.FieldRunnerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunnerID(v)
		return nil
	case bot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Bot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bot.FieldContainerID) {
		fields = append(fields, bot.FieldContainerID)
	}
	if m.FieldCleared(bot.FieldConfig) {
		fields = append(fields, bot.FieldConfig)
	}
	if m.FieldCleared(bot.FieldLastSeenAt) {
		fields = append(fields, bot.FieldLastSeenAt)
	}
	if m.FieldCleared(bot.FieldErrorMessage) {
		fields = append(fields, bot.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BotMutation) ClearField(name string) error {
	switch name {
	case bot.FieldContainerID:
		m.ClearContainerID()
		return nil
	case bot.FieldConfig:
		m.ClearConfig()
		return nil
	case bot.FieldLastSeenAt:
		m.ClearLastSeenAt()
		return nil
	case bot.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown Bot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BotMutation) ResetField(name string) error {
	switch name {
	case bot.FieldName:
		m.ResetName()
		return nil
	case bot.FieldStatus:
		m.ResetStatus()
		return nil
	case bot.FieldMode:
		m.ResetMode()
		return nil
	case bot.FieldContainerID:
		m.ResetContainerID()
		return nil
	case bot.FieldConfig:
		m.ResetConfig()
		return nil
	case bot.FieldFreqtradeVersion:
		m.ResetFreqtradeVersion()
		return nil
	case bot.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	case bot.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case bot.FieldExchangeID:
		m.ResetExchangeID()
		return nil
	case bot.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case bot.FieldRunnerID:
		m.ResetRunnerID()
		return nil
	case bot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Bot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BotMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.exchange != nil {
		edges = append(edges, bot.EdgeExchange)
	}
	if m.strategy != nil {
		edges = append(edges, bot.EdgeStrategy)
	}
	if m.runner != nil {
		edges = append(edges, bot.EdgeRunner)
	}
	if m.trades != nil {
		edges = append(edges, bot.EdgeTrades)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bot.EdgeExchange:
		if id := m.exchange; id != nil {
			return []ent.Value{*id}
		}
	case bot.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	case bot.EdgeRunner:
		if id := m.runner; id != nil {
			return []ent.Value{*id}
		}
	case bot.EdgeTrades:
		ids := make([]ent.Value, 0, len(m.trades))
		for id := range m.trades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtrades != nil {
		edges = append(edges, bot.EdgeTrades)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BotMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bot.EdgeTrades:
		ids := make([]ent.Value, 0, len(m.removedtrades))
		for id := range m.removedtrades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedexchange {
		edges = append(edges, bot.EdgeExchange)
	}
	if m.clearedstrategy {
		edges = append(edges, bot.EdgeStrategy)
	}
	if m.clearedrunner {
		edges = append(edges, bot.EdgeRunner)
	}
	if m.clearedtrades {
		edges = append(edges, bot.EdgeTrades)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BotMutation) EdgeCleared(name string) bool {
	switch name {
	case bot.EdgeExchange:
		return m.clearedexchange
	case bot.EdgeStrategy:
		return m.clearedstrategy
	case bot.EdgeRunner:
		return m.clearedrunner
	case bot.EdgeTrades:
		return m.clearedtrades
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BotMutation) ClearEdge(name string) error {
	switch name {
	case bot.EdgeExchange:
		m.ClearExchange()
		return nil
	case bot.EdgeStrategy:
		m.ClearStrategy()
		return nil
	case bot.EdgeRunner:
		m.ClearRunner()
		return nil
	}
	return fmt.Errorf("unknown Bot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BotMutation) ResetEdge(name string) error {
	switch name {
	case bot.EdgeExchange:
		m.ResetExchange()
		return nil
	case bot.EdgeStrategy:
		m.ResetStrategy()
		return nil
	case bot.EdgeRunner:
		m.ResetRunner()
		return nil
	case bot.EdgeTrades:
		m.ResetTrades()
		return nil
	}
	return fmt.Errorf("unknown Bot edge %s", name)
}

// BotRunnerMutation represents an operation that mutates the BotRunner nodes in the graph.
type BotRunnerMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	_type            *enum.RunnerType
	_config          *map[string]interface{}
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	bots             map[uuid.UUID]struct{}
	removedbots      map[uuid.UUID]struct{}
	clearedbots      bool
	backtests        map[uuid.UUID]struct{}
	removedbacktests map[uuid.UUID]struct{}
	clearedbacktests bool
	done             bool
	oldValue         func(context.Context) (*BotRunner, error)
	predicates       []predicate.BotRunner
}

var _ ent.Mutation = (*BotRunnerMutation)(nil)

// botrunnerOption allows management of the mutation configuration using functional options.
type botrunnerOption func(*BotRunnerMutation)

// newBotRunnerMutation creates new mutation for the BotRunner entity.
func newBotRunnerMutation(c config, op Op, opts ...botrunnerOption) *BotRunnerMutation {
	m := &BotRunnerMutation{
		config:        c,
		op:            op,
		typ:           TypeBotRunner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBotRunnerID sets the ID field of the mutation.
func withBotRunnerID(id uuid.UUID) botrunnerOption {
	return func(m *BotRunnerMutation) {
		var (
			err   error
			once  sync.Once
			value *BotRunner
		)
		m.oldValue = func(ctx context.Context) (*BotRunner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BotRunner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBotRunner sets the old BotRunner of the mutation.
func withBotRunner(node *BotRunner) botrunnerOption {
	return func(m *BotRunnerMutation) {
		m.oldValue = func(context.Context) (*BotRunner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BotRunnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BotRunnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BotRunner entities.
func (m *BotRunnerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BotRunnerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BotRunnerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BotRunner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BotRunnerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BotRunnerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BotRunnerMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *BotRunnerMutation) SetType(et enum.RunnerType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *BotRunnerMutation) GetType() (r enum.RunnerType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldType(ctx context.Context) (v enum.RunnerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BotRunnerMutation) ResetType() {
	m._type = nil
}

// SetConfig sets the "config" field.
func (m *BotRunnerMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *BotRunnerMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *BotRunnerMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[botrunner.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *BotRunnerMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *BotRunnerMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, botrunner.FieldConfig)
}

// SetCreatedAt sets the "created_at" field.
func (m *BotRunnerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BotRunnerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BotRunnerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BotRunnerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BotRunnerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BotRunnerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBotIDs adds the "bots" edge to the Bot entity by ids.
func (m *BotRunnerMutation) AddBotIDs(ids ...uuid.UUID) {
	if m.bots == nil {
		m.bots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bots[ids[i]] = struct{}{}
	}
}

// ClearBots clears the "bots" edge to the Bot entity.
func (m *BotRunnerMutation) ClearBots() {
	m.clearedbots = true
}

// BotsCleared reports if the "bots" edge to the Bot entity was cleared.
func (m *BotRunnerMutation) BotsCleared() bool {
	return m.clearedbots
}

// RemoveBotIDs removes the "bots" edge to the Bot entity by IDs.
func (m *BotRunnerMutation) RemoveBotIDs(ids ...uuid.UUID) {
	if m.removedbots == nil {
		m.removedbots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bots, ids[i])
		m.removedbots[ids[i]] = struct{}{}
	}
}

// RemovedBots returns the removed IDs of the "bots" edge to the Bot entity.
func (m *BotRunnerMutation) RemovedBotsIDs() (ids []uuid.UUID) {
	for id := range m.removedbots {
		ids = append(ids, id)
	}
	return
}

// BotsIDs returns the "bots" edge IDs in the mutation.
func (m *BotRunnerMutation) BotsIDs() (ids []uuid.UUID) {
	for id := range m.bots {
		ids = append(ids, id)
	}
	return
}

// ResetBots resets all changes to the "bots" edge.
func (m *BotRunnerMutation) ResetBots() {
	m.bots = nil
	m.clearedbots = false
	m.removedbots = nil
}

// AddBacktestIDs adds the "backtests" edge to the Backtest entity by ids.
func (m *BotRunnerMutation) AddBacktestIDs(ids ...uuid.UUID) {
	if m.backtests == nil {
		m.backtests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.backtests[ids[i]] = struct{}{}
	}
}

// ClearBacktests clears the "backtests" edge to the Backtest entity.
func (m *BotRunnerMutation) ClearBacktests() {
	m.clearedbacktests = true
}

// BacktestsCleared reports if the "backtests" edge to the Backtest entity was cleared.
func (m *BotRunnerMutation) BacktestsCleared() bool {
	return m.clearedbacktests
}

// RemoveBacktestIDs removes the "backtests" edge to the Backtest entity by IDs.
func (m *BotRunnerMutation) RemoveBacktestIDs(ids ...uuid.UUID) {
	if m.removedbacktests == nil {
		m.removedbacktests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.backtests, ids[i])
		m.removedbacktests[ids[i]] = struct{}{}
	}
}

// RemovedBacktests returns the removed IDs of the "backtests" edge to the Backtest entity.
func (m *BotRunnerMutation) RemovedBacktestsIDs() (ids []uuid.UUID) {
	for id := range m.removedbacktests {
		ids = append(ids, id)
	}
	return
}

// BacktestsIDs returns the "backtests" edge IDs in the mutation.
func (m *BotRunnerMutation) BacktestsIDs() (ids []uuid.UUID) {
	for id := range m.backtests {
		ids = append(ids, id)
	}
	return
}

// ResetBacktests resets all changes to the "backtests" edge.
func (m *BotRunnerMutation) ResetBacktests() {
	m.backtests = nil
	m.clearedbacktests = false
	m.removedbacktests = nil
}

// Where appends a list predicates to the BotRunnerMutation builder.
func (m *BotRunnerMutation) Where(ps ...predicate.BotRunner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BotRunnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BotRunnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BotRunner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BotRunnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BotRunnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BotRunner).
func (m *BotRunnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BotRunnerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, botrunner.FieldName)
	}
	if m._type != nil {
		fields = append(fields, botrunner.FieldType)
	}
	if m._config != nil {
		fields = append(fields, botrunner.FieldConfig)
	}
	if m.created_at != nil {
		fields = append(fields, botrunner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, botrunner.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BotRunnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case botrunner.FieldName:
		return m.Name()
	case botrunner.FieldType:
		return m.GetType()
	case botrunner.FieldConfig:
		return m.Config()
	case botrunner.FieldCreatedAt:
		return m.CreatedAt()
	case botrunner.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BotRunnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case botrunner.FieldName:
		return m.OldName(ctx)
	case botrunner.FieldType:
		return m.OldType(ctx)
	case botrunner.FieldConfig:
		return m.OldConfig(ctx)
	case botrunner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case botrunner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BotRunner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotRunnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case botrunner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case botrunner.FieldType:
		v, ok := value.(enum.RunnerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case botrunner.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case botrunner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case botrunner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BotRunner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BotRunnerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BotRunnerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotRunnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BotRunner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BotRunnerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(botrunner.FieldConfig) {
		fields = append(fields, botrunner.FieldConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BotRunnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BotRunnerMutation) ClearField(name string) error {
	switch name {
	case botrunner.FieldConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown BotRunner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BotRunnerMutation) ResetField(name string) error {
	switch name {
	case botrunner.FieldName:
		m.ResetName()
		return nil
	case botrunner.FieldType:
		m.ResetType()
		return nil
	case botrunner.FieldConfig:
		m.ResetConfig()
		return nil
	case botrunner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case botrunner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BotRunner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BotRunnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.bots != nil {
		edges = append(edges, botrunner.EdgeBots)
	}
	if m.backtests != nil {
		edges = append(edges, botrunner.EdgeBacktests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BotRunnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case botrunner.EdgeBots:
		ids := make([]ent.Value, 0, len(m.bots))
		for id := range m.bots {
			ids = append(ids, id)
		}
		return ids
	case botrunner.EdgeBacktests:
		ids := make([]ent.Value, 0, len(m.backtests))
		for id := range m.backtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BotRunnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbots != nil {
		edges = append(edges, botrunner.EdgeBots)
	}
	if m.removedbacktests != nil {
		edges = append(edges, botrunner.EdgeBacktests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BotRunnerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case botrunner.EdgeBots:
		ids := make([]ent.Value, 0, len(m.removedbots))
		for id := range m.removedbots {
			ids = append(ids, id)
		}
		return ids
	case botrunner.EdgeBacktests:
		ids := make([]ent.Value, 0, len(m.removedbacktests))
		for id := range m.removedbacktests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BotRunnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbots {
		edges = append(edges, botrunner.EdgeBots)
	}
	if m.clearedbacktests {
		edges = append(edges, botrunner.EdgeBacktests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BotRunnerMutation) EdgeCleared(name string) bool {
	switch name {
	case botrunner.EdgeBots:
		return m.clearedbots
	case botrunner.EdgeBacktests:
		return m.clearedbacktests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BotRunnerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BotRunner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BotRunnerMutation) ResetEdge(name string) error {
	switch name {
	case botrunner.EdgeBots:
		m.ResetBots()
		return nil
	case botrunner.EdgeBacktests:
		m.ResetBacktests()
		return nil
	}
	return fmt.Errorf("unknown BotRunner edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	_config       *map[string]interface{}
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	bots          map[uuid.UUID]struct{}
	removedbots   map[uuid.UUID]struct{}
	clearedbots   bool
	done          bool
	oldValue      func(context.Context) (*Exchange, error)
	predicates    []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id uuid.UUID) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exchange entities.
func (m *ExchangeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ExchangeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExchangeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExchangeMutation) ResetName() {
	m.name = nil
}

// SetConfig sets the "config" field.
func (m *ExchangeMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *ExchangeMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *ExchangeMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[exchange.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *ExchangeMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[exchange.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *ExchangeMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, exchange.FieldConfig)
}

// SetCreatedAt sets the "created_at" field.
func (m *ExchangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExchangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExchangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExchangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExchangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExchangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBotIDs adds the "bots" edge to the Bot entity by ids.
func (m *ExchangeMutation) AddBotIDs(ids ...uuid.UUID) {
	if m.bots == nil {
		m.bots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bots[ids[i]] = struct{}{}
	}
}

// ClearBots clears the "bots" edge to the Bot entity.
func (m *ExchangeMutation) ClearBots() {
	m.clearedbots = true
}

// BotsCleared reports if the "bots" edge to the Bot entity was cleared.
func (m *ExchangeMutation) BotsCleared() bool {
	return m.clearedbots
}

// RemoveBotIDs removes the "bots" edge to the Bot entity by IDs.
func (m *ExchangeMutation) RemoveBotIDs(ids ...uuid.UUID) {
	if m.removedbots == nil {
		m.removedbots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bots, ids[i])
		m.removedbots[ids[i]] = struct{}{}
	}
}

// RemovedBots returns the removed IDs of the "bots" edge to the Bot entity.
func (m *ExchangeMutation) RemovedBotsIDs() (ids []uuid.UUID) {
	for id := range m.removedbots {
		ids = append(ids, id)
	}
	return
}

// BotsIDs returns the "bots" edge IDs in the mutation.
func (m *ExchangeMutation) BotsIDs() (ids []uuid.UUID) {
	for id := range m.bots {
		ids = append(ids, id)
	}
	return
}

// ResetBots resets all changes to the "bots" edge.
func (m *ExchangeMutation) ResetBots() {
	m.bots = nil
	m.clearedbots = false
	m.removedbots = nil
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExchangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExchangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exchange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExchangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, exchange.FieldName)
	}
	if m._config != nil {
		fields = append(fields, exchange.FieldConfig)
	}
	if m.created_at != nil {
		fields = append(fields, exchange.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exchange.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldName:
		return m.Name()
	case exchange.FieldConfig:
		return m.Config()
	case exchange.FieldCreatedAt:
		return m.CreatedAt()
	case exchange.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldName:
		return m.OldName(ctx)
	case exchange.FieldConfig:
		return m.OldConfig(ctx)
	case exchange.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exchange.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case exchange.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case exchange.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exchange.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exchange.FieldConfig) {
		fields = append(fields, exchange.FieldConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	switch name {
	case exchange.FieldConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldName:
		m.ResetName()
		return nil
	case exchange.FieldConfig:
		m.ResetConfig()
		return nil
	case exchange.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exchange.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bots != nil {
		edges = append(edges, exchange.EdgeBots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeBots:
		ids := make([]ent.Value, 0, len(m.bots))
		for id := range m.bots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbots != nil {
		edges = append(edges, exchange.EdgeBots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeBots:
		ids := make([]ent.Value, 0, len(m.removedbots))
		for id := range m.removedbots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbots {
		edges = append(edges, exchange.EdgeBots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	switch name {
	case exchange.EdgeBots:
		return m.clearedbots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	switch name {
	case exchange.EdgeBots:
		m.ResetBots()
		return nil
	}
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// StrategyMutation represents an operation that mutates the Strategy nodes in the graph.
type StrategyMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	description      *string
	code             *string
	version          *string
	_config          *map[string]interface{}
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	bots             map[uuid.UUID]struct{}
	removedbots      map[uuid.UUID]struct{}
	clearedbots      bool
	backtests        map[uuid.UUID]struct{}
	removedbacktests map[uuid.UUID]struct{}
	clearedbacktests bool
	done             bool
	oldValue         func(context.Context) (*Strategy, error)
	predicates       []predicate.Strategy
}

var _ ent.Mutation = (*StrategyMutation)(nil)

// strategyOption allows management of the mutation configuration using functional options.
type strategyOption func(*StrategyMutation)

// newStrategyMutation creates new mutation for the Strategy entity.
func newStrategyMutation(c config, op Op, opts ...strategyOption) *StrategyMutation {
	m := &StrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyID sets the ID field of the mutation.
func withStrategyID(id uuid.UUID) strategyOption {
	return func(m *StrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *Strategy
		)
		m.oldValue = func(ctx context.Context) (*Strategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Strategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategy sets the old Strategy of the mutation.
func withStrategy(node *Strategy) strategyOption {
	return func(m *StrategyMutation) {
		m.oldValue = func(context.Context) (*Strategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Strategy entities.
func (m *StrategyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Strategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *StrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[strategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[strategy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, strategy.FieldDescription)
}

// SetCode sets the "code" field.
func (m *StrategyMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *StrategyMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *StrategyMutation) ResetCode() {
	m.code = nil
}

// SetVersion sets the "version" field.
func (m *StrategyMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *StrategyMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *StrategyMutation) ResetVersion() {
	m.version = nil
}

// SetConfig sets the "config" field.
func (m *StrategyMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *StrategyMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *StrategyMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[strategy.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *StrategyMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[strategy.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *StrategyMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, strategy.FieldConfig)
}

// SetCreatedAt sets the "created_at" field.
func (m *StrategyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StrategyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StrategyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StrategyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StrategyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StrategyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBotIDs adds the "bots" edge to the Bot entity by ids.
func (m *StrategyMutation) AddBotIDs(ids ...uuid.UUID) {
	if m.bots == nil {
		m.bots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bots[ids[i]] = struct{}{}
	}
}

// ClearBots clears the "bots" edge to the Bot entity.
func (m *StrategyMutation) ClearBots() {
	m.clearedbots = true
}

// BotsCleared reports if the "bots" edge to the Bot entity was cleared.
func (m *StrategyMutation) BotsCleared() bool {
	return m.clearedbots
}

// RemoveBotIDs removes the "bots" edge to the Bot entity by IDs.
func (m *StrategyMutation) RemoveBotIDs(ids ...uuid.UUID) {
	if m.removedbots == nil {
		m.removedbots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bots, ids[i])
		m.removedbots[ids[i]] = struct{}{}
	}
}

// RemovedBots returns the removed IDs of the "bots" edge to the Bot entity.
func (m *StrategyMutation) RemovedBotsIDs() (ids []uuid.UUID) {
	for id := range m.removedbots {
		ids = append(ids, id)
	}
	return
}

// BotsIDs returns the "bots" edge IDs in the mutation.
func (m *StrategyMutation) BotsIDs() (ids []uuid.UUID) {
	for id := range m.bots {
		ids = append(ids, id)
	}
	return
}

// ResetBots resets all changes to the "bots" edge.
func (m *StrategyMutation) ResetBots() {
	m.bots = nil
	m.clearedbots = false
	m.removedbots = nil
}

// AddBacktestIDs adds the "backtests" edge to the Backtest entity by ids.
func (m *StrategyMutation) AddBacktestIDs(ids ...uuid.UUID) {
	if m.backtests == nil {
		m.backtests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.backtests[ids[i]] = struct{}{}
	}
}

// ClearBacktests clears the "backtests" edge to the Backtest entity.
func (m *StrategyMutation) ClearBacktests() {
	m.clearedbacktests = true
}

// BacktestsCleared reports if the "backtests" edge to the Backtest entity was cleared.
func (m *StrategyMutation) BacktestsCleared() bool {
	return m.clearedbacktests
}

// RemoveBacktestIDs removes the "backtests" edge to the Backtest entity by IDs.
func (m *StrategyMutation) RemoveBacktestIDs(ids ...uuid.UUID) {
	if m.removedbacktests == nil {
		m.removedbacktests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.backtests, ids[i])
		m.removedbacktests[ids[i]] = struct{}{}
	}
}

// RemovedBacktests returns the removed IDs of the "backtests" edge to the Backtest entity.
func (m *StrategyMutation) RemovedBacktestsIDs() (ids []uuid.UUID) {
	for id := range m.removedbacktests {
		ids = append(ids, id)
	}
	return
}

// BacktestsIDs returns the "backtests" edge IDs in the mutation.
func (m *StrategyMutation) BacktestsIDs() (ids []uuid.UUID) {
	for id := range m.backtests {
		ids = append(ids, id)
	}
	return
}

// ResetBacktests resets all changes to the "backtests" edge.
func (m *StrategyMutation) ResetBacktests() {
	m.backtests = nil
	m.clearedbacktests = false
	m.removedbacktests = nil
}

// Where appends a list predicates to the StrategyMutation builder.
func (m *StrategyMutation) Where(ps ...predicate.Strategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Strategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Strategy).
func (m *StrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, strategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, strategy.FieldDescription)
	}
	if m.code != nil {
		fields = append(fields, strategy.FieldCode)
	}
	if m.version != nil {
		fields = append(fields, strategy.FieldVersion)
	}
	if m._config != nil {
		fields = append(fields, strategy.FieldConfig)
	}
	if m.created_at != nil {
		fields = append(fields, strategy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, strategy.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldName:
		return m.Name()
	case strategy.FieldDescription:
		return m.Description()
	case strategy.FieldCode:
		return m.Code()
	case strategy.FieldVersion:
		return m.Version()
	case strategy.FieldConfig:
		return m.Config()
	case strategy.FieldCreatedAt:
		return m.CreatedAt()
	case strategy.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategy.FieldName:
		return m.OldName(ctx)
	case strategy.FieldDescription:
		return m.OldDescription(ctx)
	case strategy.FieldCode:
		return m.OldCode(ctx)
	case strategy.FieldVersion:
		return m.OldVersion(ctx)
	case strategy.FieldConfig:
		return m.OldConfig(ctx)
	case strategy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case strategy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Strategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case strategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case strategy.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case strategy.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case strategy.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case strategy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case strategy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Strategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategy.FieldDescription) {
		fields = append(fields, strategy.FieldDescription)
	}
	if m.FieldCleared(strategy.FieldConfig) {
		fields = append(fields, strategy.FieldConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyMutation) ClearField(name string) error {
	switch name {
	case strategy.FieldDescription:
		m.ClearDescription()
		return nil
	case strategy.FieldConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Strategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyMutation) ResetField(name string) error {
	switch name {
	case strategy.FieldName:
		m.ResetName()
		return nil
	case strategy.FieldDescription:
		m.ResetDescription()
		return nil
	case strategy.FieldCode:
		m.ResetCode()
		return nil
	case strategy.FieldVersion:
		m.ResetVersion()
		return nil
	case strategy.FieldConfig:
		m.ResetConfig()
		return nil
	case strategy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case strategy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.bots != nil {
		edges = append(edges, strategy.EdgeBots)
	}
	if m.backtests != nil {
		edges = append(edges, strategy.EdgeBacktests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeBots:
		ids := make([]ent.Value, 0, len(m.bots))
		for id := range m.bots {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeBacktests:
		ids := make([]ent.Value, 0, len(m.backtests))
		for id := range m.backtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbots != nil {
		edges = append(edges, strategy.EdgeBots)
	}
	if m.removedbacktests != nil {
		edges = append(edges, strategy.EdgeBacktests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeBots:
		ids := make([]ent.Value, 0, len(m.removedbots))
		for id := range m.removedbots {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeBacktests:
		ids := make([]ent.Value, 0, len(m.removedbacktests))
		for id := range m.removedbacktests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbots {
		edges = append(edges, strategy.EdgeBots)
	}
	if m.clearedbacktests {
		edges = append(edges, strategy.EdgeBacktests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyMutation) EdgeCleared(name string) bool {
	switch name {
	case strategy.EdgeBots:
		return m.clearedbots
	case strategy.EdgeBacktests:
		return m.clearedbacktests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Strategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyMutation) ResetEdge(name string) error {
	switch name {
	case strategy.EdgeBots:
		m.ResetBots()
		return nil
	case strategy.EdgeBacktests:
		m.ResetBacktests()
		return nil
	}
	return fmt.Errorf("unknown Strategy edge %s", name)
}

// TradeMutation represents an operation that mutates the Trade nodes in the graph.
type TradeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	freqtrade_trade_id    *int
	addfreqtrade_trade_id *int
	pair                  *string
	is_open               *bool
	open_date             *time.Time
	close_date            *time.Time
	open_rate             *float64
	addopen_rate          *float64
	close_rate            *float64
	addclose_rate         *float64
	amount                *float64
	addamount             *float64
	stake_amount          *float64
	addstake_amount       *float64
	profit_abs            *float64
	addprofit_abs         *float64
	profit_ratio          *float64
	addprofit_ratio       *float64
	sell_reason           *string
	strategy_name         *string
	timeframe             *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	bot                   *uuid.UUID
	clearedbot            bool
	done                  bool
	oldValue              func(context.Context) (*Trade, error)
	predicates            []predicate.Trade
}

var _ ent.Mutation = (*TradeMutation)(nil)

// tradeOption allows management of the mutation configuration using functional options.
type tradeOption func(*TradeMutation)

// newTradeMutation creates new mutation for the Trade entity.
func newTradeMutation(c config, op Op, opts ...tradeOption) *TradeMutation {
	m := &TradeMutation{
		config:        c,
		op:            op,
		typ:           TypeTrade,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTradeID sets the ID field of the mutation.
func withTradeID(id uuid.UUID) tradeOption {
	return func(m *TradeMutation) {
		var (
			err   error
			once  sync.Once
			value *Trade
		)
		m.oldValue = func(ctx context.Context) (*Trade, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trade.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrade sets the old Trade of the mutation.
func withTrade(node *Trade) tradeOption {
	return func(m *TradeMutation) {
		m.oldValue = func(context.Context) (*Trade, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TradeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TradeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Trade entities.
func (m *TradeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TradeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TradeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trade.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFreqtradeTradeID sets the "freqtrade_trade_id" field.
func (m *TradeMutation) SetFreqtradeTradeID(i int) {
	m.freqtrade_trade_id = &i
	m.addfreqtrade_trade_id = nil
}

// FreqtradeTradeID returns the value of the "freqtrade_trade_id" field in the mutation.
func (m *TradeMutation) FreqtradeTradeID() (r int, exists bool) {
	v := m.freqtrade_trade_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFreqtradeTradeID returns the old "freqtrade_trade_id" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldFreqtradeTradeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreqtradeTradeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreqtradeTradeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreqtradeTradeID: %w", err)
	}
	return oldValue.FreqtradeTradeID, nil
}

// AddFreqtradeTradeID adds i to the "freqtrade_trade_id" field.
func (m *TradeMutation) AddFreqtradeTradeID(i int) {
	if m.addfreqtrade_trade_id != nil {
		*m.addfreqtrade_trade_id += i
	} else {
		m.addfreqtrade_trade_id = &i
	}
}

// AddedFreqtradeTradeID returns the value that was added to the "freqtrade_trade_id" field in this mutation.
func (m *TradeMutation) AddedFreqtradeTradeID() (r int, exists bool) {
	v := m.addfreqtrade_trade_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFreqtradeTradeID resets all changes to the "freqtrade_trade_id" field.
func (m *TradeMutation) ResetFreqtradeTradeID() {
	m.freqtrade_trade_id = nil
	m.addfreqtrade_trade_id = nil
}

// SetPair sets the "pair" field.
func (m *TradeMutation) SetPair(s string) {
	m.pair = &s
}

// Pair returns the value of the "pair" field in the mutation.
func (m *TradeMutation) Pair() (r string, exists bool) {
	v := m.pair
	if v == nil {
		return
	}
	return *v, true
}

// OldPair returns the old "pair" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldPair(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPair is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPair requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPair: %w", err)
	}
	return oldValue.Pair, nil
}

// ResetPair resets all changes to the "pair" field.
func (m *TradeMutation) ResetPair() {
	m.pair = nil
}

// SetIsOpen sets the "is_open" field.
func (m *TradeMutation) SetIsOpen(b bool) {
	m.is_open = &b
}

// IsOpen returns the value of the "is_open" field in the mutation.
func (m *TradeMutation) IsOpen() (r bool, exists bool) {
	v := m.is_open
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOpen returns the old "is_open" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldIsOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOpen: %w", err)
	}
	return oldValue.IsOpen, nil
}

// ResetIsOpen resets all changes to the "is_open" field.
func (m *TradeMutation) ResetIsOpen() {
	m.is_open = nil
}

// SetOpenDate sets the "open_date" field.
func (m *TradeMutation) SetOpenDate(t time.Time) {
	m.open_date = &t
}

// OpenDate returns the value of the "open_date" field in the mutation.
func (m *TradeMutation) OpenDate() (r time.Time, exists bool) {
	v := m.open_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenDate returns the old "open_date" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldOpenDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenDate: %w", err)
	}
	return oldValue.OpenDate, nil
}

// ResetOpenDate resets all changes to the "open_date" field.
func (m *TradeMutation) ResetOpenDate() {
	m.open_date = nil
}

// SetCloseDate sets the "close_date" field.
func (m *TradeMutation) SetCloseDate(t time.Time) {
	m.close_date = &t
}

// CloseDate returns the value of the "close_date" field in the mutation.
func (m *TradeMutation) CloseDate() (r time.Time, exists bool) {
	v := m.close_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseDate returns the old "close_date" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldCloseDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseDate: %w", err)
	}
	return oldValue.CloseDate, nil
}

// ClearCloseDate clears the value of the "close_date" field.
func (m *TradeMutation) ClearCloseDate() {
	m.close_date = nil
	m.clearedFields[trade.FieldCloseDate] = struct{}{}
}

// CloseDateCleared returns if the "close_date" field was cleared in this mutation.
func (m *TradeMutation) CloseDateCleared() bool {
	_, ok := m.clearedFields[trade.FieldCloseDate]
	return ok
}

// ResetCloseDate resets all changes to the "close_date" field.
func (m *TradeMutation) ResetCloseDate() {
	m.close_date = nil
	delete(m.clearedFields, trade.FieldCloseDate)
}

// SetOpenRate sets the "open_rate" field.
func (m *TradeMutation) SetOpenRate(f float64) {
	m.open_rate = &f
	m.addopen_rate = nil
}

// OpenRate returns the value of the "open_rate" field in the mutation.
func (m *TradeMutation) OpenRate() (r float64, exists bool) {
	v := m.open_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenRate returns the old "open_rate" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldOpenRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenRate: %w", err)
	}
	return oldValue.OpenRate, nil
}

// AddOpenRate adds f to the "open_rate" field.
func (m *TradeMutation) AddOpenRate(f float64) {
	if m.addopen_rate != nil {
		*m.addopen_rate += f
	} else {
		m.addopen_rate = &f
	}
}

// AddedOpenRate returns the value that was added to the "open_rate" field in this mutation.
func (m *TradeMutation) AddedOpenRate() (r float64, exists bool) {
	v := m.addopen_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpenRate resets all changes to the "open_rate" field.
func (m *TradeMutation) ResetOpenRate() {
	m.open_rate = nil
	m.addopen_rate = nil
}

// SetCloseRate sets the "close_rate" field.
func (m *TradeMutation) SetCloseRate(f float64) {
	m.close_rate = &f
	m.addclose_rate = nil
}

// CloseRate returns the value of the "close_rate" field in the mutation.
func (m *TradeMutation) CloseRate() (r float64, exists bool) {
	v := m.close_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseRate returns the old "close_rate" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldCloseRate(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseRate: %w", err)
	}
	return oldValue.CloseRate, nil
}

// AddCloseRate adds f to the "close_rate" field.
func (m *TradeMutation) AddCloseRate(f float64) {
	if m.addclose_rate != nil {
		*m.addclose_rate += f
	} else {
		m.addclose_rate = &f
	}
}

// AddedCloseRate returns the value that was added to the "close_rate" field in this mutation.
func (m *TradeMutation) AddedCloseRate() (r float64, exists bool) {
	v := m.addclose_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearCloseRate clears the value of the "close_rate" field.
func (m *TradeMutation) ClearCloseRate() {
	m.close_rate = nil
	m.addclose_rate = nil
	m.clearedFields[trade.FieldCloseRate] = struct{}{}
}

// CloseRateCleared returns if the "close_rate" field was cleared in this mutation.
func (m *TradeMutation) CloseRateCleared() bool {
	_, ok := m.clearedFields[trade.FieldCloseRate]
	return ok
}

// ResetCloseRate resets all changes to the "close_rate" field.
func (m *TradeMutation) ResetCloseRate() {
	m.close_rate = nil
	m.addclose_rate = nil
	delete(m.clearedFields, trade.FieldCloseRate)
}

// SetAmount sets the "amount" field.
func (m *TradeMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TradeMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TradeMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TradeMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TradeMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStakeAmount sets the "stake_amount" field.
func (m *TradeMutation) SetStakeAmount(f float64) {
	m.stake_amount = &f
	m.addstake_amount = nil
}

// StakeAmount returns the value of the "stake_amount" field in the mutation.
func (m *TradeMutation) StakeAmount() (r float64, exists bool) {
	v := m.stake_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStakeAmount returns the old "stake_amount" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldStakeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakeAmount: %w", err)
	}
	return oldValue.StakeAmount, nil
}

// AddStakeAmount adds f to the "stake_amount" field.
func (m *TradeMutation) AddStakeAmount(f float64) {
	if m.addstake_amount != nil {
		*m.addstake_amount += f
	} else {
		m.addstake_amount = &f
	}
}

// AddedStakeAmount returns the value that was added to the "stake_amount" field in this mutation.
func (m *TradeMutation) AddedStakeAmount() (r float64, exists bool) {
	v := m.addstake_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetStakeAmount resets all changes to the "stake_amount" field.
func (m *TradeMutation) ResetStakeAmount() {
	m.stake_amount = nil
	m.addstake_amount = nil
}

// SetProfitAbs sets the "profit_abs" field.
func (m *TradeMutation) SetProfitAbs(f float64) {
	m.profit_abs = &f
	m.addprofit_abs = nil
}

// ProfitAbs returns the value of the "profit_abs" field in the mutation.
func (m *TradeMutation) ProfitAbs() (r float64, exists bool) {
	v := m.profit_abs
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAbs returns the old "profit_abs" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldProfitAbs(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAbs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAbs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAbs: %w", err)
	}
	return oldValue.ProfitAbs, nil
}

// AddProfitAbs adds f to the "profit_abs" field.
func (m *TradeMutation) AddProfitAbs(f float64) {
	if m.addprofit_abs != nil {
		*m.addprofit_abs += f
	} else {
		m.addprofit_abs = &f
	}
}

// AddedProfitAbs returns the value that was added to the "profit_abs" field in this mutation.
func (m *TradeMutation) AddedProfitAbs() (r float64, exists bool) {
	v := m.addprofit_abs
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitAbs resets all changes to the "profit_abs" field.
func (m *TradeMutation) ResetProfitAbs() {
	m.profit_abs = nil
	m.addprofit_abs = nil
}

// SetProfitRatio sets the "profit_ratio" field.
func (m *TradeMutation) SetProfitRatio(f float64) {
	m.profit_ratio = &f
	m.addprofit_ratio = nil
}

// ProfitRatio returns the value of the "profit_ratio" field in the mutation.
func (m *TradeMutation) ProfitRatio() (r float64, exists bool) {
	v := m.profit_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitRatio returns the old "profit_ratio" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldProfitRatio(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitRatio: %w", err)
	}
	return oldValue.ProfitRatio, nil
}

// AddProfitRatio adds f to the "profit_ratio" field.
func (m *TradeMutation) AddProfitRatio(f float64) {
	if m.addprofit_ratio != nil {
		*m.addprofit_ratio += f
	} else {
		m.addprofit_ratio = &f
	}
}

// AddedProfitRatio returns the value that was added to the "profit_ratio" field in this mutation.
func (m *TradeMutation) AddedProfitRatio() (r float64, exists bool) {
	v := m.addprofit_ratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitRatio resets all changes to the "profit_ratio" field.
func (m *TradeMutation) ResetProfitRatio() {
	m.profit_ratio = nil
	m.addprofit_ratio = nil
}

// SetSellReason sets the "sell_reason" field.
func (m *TradeMutation) SetSellReason(s string) {
	m.sell_reason = &s
}

// SellReason returns the value of the "sell_reason" field in the mutation.
func (m *TradeMutation) SellReason() (r string, exists bool) {
	v := m.sell_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSellReason returns the old "sell_reason" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldSellReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellReason: %w", err)
	}
	return oldValue.SellReason, nil
}

// ClearSellReason clears the value of the "sell_reason" field.
func (m *TradeMutation) ClearSellReason() {
	m.sell_reason = nil
	m.clearedFields[trade.FieldSellReason] = struct{}{}
}

// SellReasonCleared returns if the "sell_reason" field was cleared in this mutation.
func (m *TradeMutation) SellReasonCleared() bool {
	_, ok := m.clearedFields[trade.FieldSellReason]
	return ok
}

// ResetSellReason resets all changes to the "sell_reason" field.
func (m *TradeMutation) ResetSellReason() {
	m.sell_reason = nil
	delete(m.clearedFields, trade.FieldSellReason)
}

// SetStrategyName sets the "strategy_name" field.
func (m *TradeMutation) SetStrategyName(s string) {
	m.strategy_name = &s
}

// StrategyName returns the value of the "strategy_name" field in the mutation.
func (m *TradeMutation) StrategyName() (r string, exists bool) {
	v := m.strategy_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyName returns the old "strategy_name" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldStrategyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyName: %w", err)
	}
	return oldValue.StrategyName, nil
}

// ClearStrategyName clears the value of the "strategy_name" field.
func (m *TradeMutation) ClearStrategyName() {
	m.strategy_name = nil
	m.clearedFields[trade.FieldStrategyName] = struct{}{}
}

// StrategyNameCleared returns if the "strategy_name" field was cleared in this mutation.
func (m *TradeMutation) StrategyNameCleared() bool {
	_, ok := m.clearedFields[trade.FieldStrategyName]
	return ok
}

// ResetStrategyName resets all changes to the "strategy_name" field.
func (m *TradeMutation) ResetStrategyName() {
	m.strategy_name = nil
	delete(m.clearedFields, trade.FieldStrategyName)
}

// SetTimeframe sets the "timeframe" field.
func (m *TradeMutation) SetTimeframe(s string) {
	m.timeframe = &s
}

// Timeframe returns the value of the "timeframe" field in the mutation.
func (m *TradeMutation) Timeframe() (r string, exists bool) {
	v := m.timeframe
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeframe returns the old "timeframe" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldTimeframe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeframe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeframe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeframe: %w", err)
	}
	return oldValue.Timeframe, nil
}

// ClearTimeframe clears the value of the "timeframe" field.
func (m *TradeMutation) ClearTimeframe() {
	m.timeframe = nil
	m.clearedFields[trade.FieldTimeframe] = struct{}{}
}

// TimeframeCleared returns if the "timeframe" field was cleared in this mutation.
func (m *TradeMutation) TimeframeCleared() bool {
	_, ok := m.clearedFields[trade.FieldTimeframe]
	return ok
}

// ResetTimeframe resets all changes to the "timeframe" field.
func (m *TradeMutation) ResetTimeframe() {
	m.timeframe = nil
	delete(m.clearedFields, trade.FieldTimeframe)
}

// SetBotID sets the "bot_id" field.
func (m *TradeMutation) SetBotID(u uuid.UUID) {
	m.bot = &u
}

// BotID returns the value of the "bot_id" field in the mutation.
func (m *TradeMutation) BotID() (r uuid.UUID, exists bool) {
	v := m.bot
	if v == nil {
		return
	}
	return *v, true
}

// OldBotID returns the old "bot_id" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldBotID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBotID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBotID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBotID: %w", err)
	}
	return oldValue.BotID, nil
}

// ResetBotID resets all changes to the "bot_id" field.
func (m *TradeMutation) ResetBotID() {
	m.bot = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TradeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TradeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TradeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TradeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TradeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TradeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearBot clears the "bot" edge to the Bot entity.
func (m *TradeMutation) ClearBot() {
	m.clearedbot = true
	m.clearedFields[trade.FieldBotID] = struct{}{}
}

// BotCleared reports if the "bot" edge to the Bot entity was cleared.
func (m *TradeMutation) BotCleared() bool {
	return m.clearedbot
}

// BotIDs returns the "bot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BotID instead. It exists only for internal usage by the builders.
func (m *TradeMutation) BotIDs() (ids []uuid.UUID) {
	if id := m.bot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBot resets all changes to the "bot" edge.
func (m *TradeMutation) ResetBot() {
	m.bot = nil
	m.clearedbot = false
}

// Where appends a list predicates to the TradeMutation builder.
func (m *TradeMutation) Where(ps ...predicate.Trade) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TradeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TradeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trade, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TradeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TradeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trade).
func (m *TradeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TradeMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.freqtrade_trade_id != nil {
		fields = append(fields, trade.FieldFreqtradeTradeID)
	}
	if m.pair != nil {
		fields = append(fields, trade.FieldPair)
	}
	if m.is_open != nil {
		fields = append(fields, trade.FieldIsOpen)
	}
	if m.open_date != nil {
		fields = append(fields, trade.FieldOpenDate)
	}
	if m.close_date != nil {
		fields = append(fields, trade.FieldCloseDate)
	}
	if m.open_rate != nil {
		fields = append(fields, trade.FieldOpenRate)
	}
	if m.close_rate != nil {
		fields = append(fields, trade.FieldCloseRate)
	}
	if m.amount != nil {
		fields = append(fields, trade.FieldAmount)
	}
	if m.stake_amount != nil {
		fields = append(fields, trade.FieldStakeAmount)
	}
	if m.profit_abs != nil {
		fields = append(fields, trade.FieldProfitAbs)
	}
	if m.profit_ratio != nil {
		fields = append(fields, trade.FieldProfitRatio)
	}
	if m.sell_reason != nil {
		fields = append(fields, trade.FieldSellReason)
	}
	if m.strategy_name != nil {
		fields = append(fields, trade.FieldStrategyName)
	}
	if m.timeframe != nil {
		fields = append(fields, trade.FieldTimeframe)
	}
	if m.bot != nil {
		fields = append(fields, trade.FieldBotID)
	}
	if m.created_at != nil {
		fields = append(fields, trade.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trade.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TradeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trade.FieldFreqtradeTradeID:
		return m.FreqtradeTradeID()
	case trade.FieldPair:
		return m.Pair()
	case trade.FieldIsOpen:
		return m.IsOpen()
	case trade.FieldOpenDate:
		return m.OpenDate()
	case trade.FieldCloseDate:
		return m.CloseDate()
	case trade.FieldOpenRate:
		return m.OpenRate()
	case trade.FieldCloseRate:
		return m.CloseRate()
	case trade.FieldAmount:
		return m.Amount()
	case trade.FieldStakeAmount:
		return m.StakeAmount()
	case trade.FieldProfitAbs:
		return m.ProfitAbs()
	case trade.FieldProfitRatio:
		return m.ProfitRatio()
	case trade.FieldSellReason:
		return m.SellReason()
	case trade.FieldStrategyName:
		return m.StrategyName()
	case trade.FieldTimeframe:
		return m.Timeframe()
	case trade.FieldBotID:
		return m.BotID()
	case trade.FieldCreatedAt:
		return m.CreatedAt()
	case trade.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TradeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trade.FieldFreqtradeTradeID:
		return m.OldFreqtradeTradeID(ctx)
	case trade.FieldPair:
		return m.OldPair(ctx)
	case trade.FieldIsOpen:
		return m.OldIsOpen(ctx)
	case trade.FieldOpenDate:
		return m.OldOpenDate(ctx)
	case trade.FieldCloseDate:
		return m.OldCloseDate(ctx)
	case trade.FieldOpenRate:
		return m.OldOpenRate(ctx)
	case trade.FieldCloseRate:
		return m.OldCloseRate(ctx)
	case trade.FieldAmount:
		return m.OldAmount(ctx)
	case trade.FieldStakeAmount:
		return m.OldStakeAmount(ctx)
	case trade.FieldProfitAbs:
		return m.OldProfitAbs(ctx)
	case trade.FieldProfitRatio:
		return m.OldProfitRatio(ctx)
	case trade.FieldSellReason:
		return m.OldSellReason(ctx)
	case trade.FieldStrategyName:
		return m.OldStrategyName(ctx)
	case trade.FieldTimeframe:
		return m.OldTimeframe(ctx)
	case trade.FieldBotID:
		return m.OldBotID(ctx)
	case trade.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trade.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Trade field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trade.FieldFreqtradeTradeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreqtradeTradeID(v)
		return nil
	case trade.FieldPair:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPair(v)
		return nil
	case trade.FieldIsOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOpen(v)
		return nil
	case trade.FieldOpenDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenDate(v)
		return nil
	case trade.FieldCloseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseDate(v)
		return nil
	case trade.FieldOpenRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenRate(v)
		return nil
	case trade.FieldCloseRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseRate(v)
		return nil
	case trade.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case trade.FieldStakeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakeAmount(v)
		return nil
	case trade.FieldProfitAbs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAbs(v)
		return nil
	case trade.FieldProfitRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitRatio(v)
		return nil
	case trade.FieldSellReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellReason(v)
		return nil
	case trade.FieldStrategyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyName(v)
		return nil
	case trade.FieldTimeframe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeframe(v)
		return nil
	case trade.FieldBotID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBotID(v)
		return nil
	case trade.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trade.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Trade field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TradeMutation) AddedFields() []string {
	var fields []string
	if m.addfreqtrade_trade_id != nil {
		fields = append(fields, trade.FieldFreqtradeTradeID)
	}
	if m.addopen_rate != nil {
		fields = append(fields, trade.FieldOpenRate)
	}
	if m.addclose_rate != nil {
		fields = append(fields, trade.FieldCloseRate)
	}
	if m.addamount != nil {
		fields = append(fields, trade.FieldAmount)
	}
	if m.addstake_amount != nil {
		fields = append(fields, trade.FieldStakeAmount)
	}
	if m.addprofit_abs != nil {
		fields = append(fields, trade.FieldProfitAbs)
	}
	if m.addprofit_ratio != nil {
		fields = append(fields, trade.FieldProfitRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TradeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trade.FieldFreqtradeTradeID:
		return m.AddedFreqtradeTradeID()
	case trade.FieldOpenRate:
		return m.AddedOpenRate()
	case trade.FieldCloseRate:
		return m.AddedCloseRate()
	case trade.FieldAmount:
		return m.AddedAmount()
	case trade.FieldStakeAmount:
		return m.AddedStakeAmount()
	case trade.FieldProfitAbs:
		return m.AddedProfitAbs()
	case trade.FieldProfitRatio:
		return m.AddedProfitRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trade.FieldFreqtradeTradeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreqtradeTradeID(v)
		return nil
	case trade.FieldOpenRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpenRate(v)
		return nil
	case trade.FieldCloseRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCloseRate(v)
		return nil
	case trade.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case trade.FieldStakeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStakeAmount(v)
		return nil
	case trade.FieldProfitAbs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitAbs(v)
		return nil
	case trade.FieldProfitRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitRatio(v)
		return nil
	}
	return fmt.Errorf("unknown Trade numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TradeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trade.FieldCloseDate) {
		fields = append(fields, trade.FieldCloseDate)
	}
	if m.FieldCleared(trade.FieldCloseRate) {
		fields = append(fields, trade.FieldCloseRate)
	}
	if m.FieldCleared(trade.FieldSellReason) {
		fields = append(fields, trade.FieldSellReason)
	}
	if m.FieldCleared(trade.FieldStrategyName) {
		fields = append(fields, trade.FieldStrategyName)
	}
	if m.FieldCleared(trade.FieldTimeframe) {
		fields = append(fields, trade.FieldTimeframe)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TradeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TradeMutation) ClearField(name string) error {
	switch name {
	case trade.FieldCloseDate:
		m.ClearCloseDate()
		return nil
	case trade.FieldCloseRate:
		m.ClearCloseRate()
		return nil
	case trade.FieldSellReason:
		m.ClearSellReason()
		return nil
	case trade.FieldStrategyName:
		m.ClearStrategyName()
		return nil
	case trade.FieldTimeframe:
		m.ClearTimeframe()
		return nil
	}
	return fmt.Errorf("unknown Trade nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TradeMutation) ResetField(name string) error {
	switch name {
	case trade.FieldFreqtradeTradeID:
		m.ResetFreqtradeTradeID()
		return nil
	case trade.FieldPair:
		m.ResetPair()
		return nil
	case trade.FieldIsOpen:
		m.ResetIsOpen()
		return nil
	case trade.FieldOpenDate:
		m.ResetOpenDate()
		return nil
	case trade.FieldCloseDate:
		m.ResetCloseDate()
		return nil
	case trade.FieldOpenRate:
		m.ResetOpenRate()
		return nil
	case trade.FieldCloseRate:
		m.ResetCloseRate()
		return nil
	case trade.FieldAmount:
		m.ResetAmount()
		return nil
	case trade.FieldStakeAmount:
		m.ResetStakeAmount()
		return nil
	case trade.FieldProfitAbs:
		m.ResetProfitAbs()
		return nil
	case trade.FieldProfitRatio:
		m.ResetProfitRatio()
		return nil
	case trade.FieldSellReason:
		m.ResetSellReason()
		return nil
	case trade.FieldStrategyName:
		m.ResetStrategyName()
		return nil
	case trade.FieldTimeframe:
		m.ResetTimeframe()
		return nil
	case trade.FieldBotID:
		m.ResetBotID()
		return nil
	case trade.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trade.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Trade field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TradeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bot != nil {
		edges = append(edges, trade.EdgeBot)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TradeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trade.EdgeBot:
		if id := m.bot; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TradeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TradeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TradeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbot {
		edges = append(edges, trade.EdgeBot)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TradeMutation) EdgeCleared(name string) bool {
	switch name {
	case trade.EdgeBot:
		return m.clearedbot
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TradeMutation) ClearEdge(name string) error {
	switch name {
	case trade.EdgeBot:
		m.ClearBot()
		return nil
	}
	return fmt.Errorf("unknown Trade unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TradeMutation) ResetEdge(name string) error {
	switch name {
	case trade.EdgeBot:
		m.ResetBot()
		return nil
	}
	return fmt.Errorf("unknown Trade edge %s", name)
}
