// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"volaticloud/internal/ent/alertevent"
	"volaticloud/internal/ent/alertrule"
	"volaticloud/internal/ent/backtest"
	"volaticloud/internal/ent/bot"
	"volaticloud/internal/ent/botmetrics"
	"volaticloud/internal/ent/botrunner"
	"volaticloud/internal/ent/exchange"
	"volaticloud/internal/ent/predicate"
	"volaticloud/internal/ent/resourceusageaggregation"
	"volaticloud/internal/ent/resourceusagesample"
	"volaticloud/internal/ent/strategy"
	"volaticloud/internal/ent/trade"
	"volaticloud/internal/enum"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlertEvent               = "AlertEvent"
	TypeAlertRule                = "AlertRule"
	TypeBacktest                 = "Backtest"
	TypeBot                      = "Bot"
	TypeBotMetrics               = "BotMetrics"
	TypeBotRunner                = "BotRunner"
	TypeExchange                 = "Exchange"
	TypeResourceUsageAggregation = "ResourceUsageAggregation"
	TypeResourceUsageSample      = "ResourceUsageSample"
	TypeStrategy                 = "Strategy"
	TypeTrade                    = "Trade"
)

// AlertEventMutation represents an operation that mutates the AlertEvent nodes in the graph.
type AlertEventMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	status           *enum.AlertEventStatus
	alert_type       *enum.AlertType
	severity         *enum.AlertSeverity
	subject          *string
	body             *string
	context          *map[string]interface{}
	recipients       *[]string
	appendrecipients []string
	channel_type     *string
	sent_at          *time.Time
	error_message    *string
	resource_type    *enum.AlertResourceType
	resource_id      *string
	owner_id         *string
	read_at          *time.Time
	created_at       *time.Time
	clearedFields    map[string]struct{}
	rule             *uuid.UUID
	clearedrule      bool
	done             bool
	oldValue         func(context.Context) (*AlertEvent, error)
	predicates       []predicate.AlertEvent
}

var _ ent.Mutation = (*AlertEventMutation)(nil)

// alerteventOption allows management of the mutation configuration using functional options.
type alerteventOption func(*AlertEventMutation)

// newAlertEventMutation creates new mutation for the AlertEvent entity.
func newAlertEventMutation(c config, op Op, opts ...alerteventOption) *AlertEventMutation {
	m := &AlertEventMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertEventID sets the ID field of the mutation.
func withAlertEventID(id uuid.UUID) alerteventOption {
	return func(m *AlertEventMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertEvent
		)
		m.oldValue = func(ctx context.Context) (*AlertEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertEvent sets the old AlertEvent of the mutation.
func withAlertEvent(node *AlertEvent) alerteventOption {
	return func(m *AlertEventMutation) {
		m.oldValue = func(context.Context) (*AlertEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertEvent entities.
func (m *AlertEventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertEventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertEventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRuleID sets the "rule_id" field.
func (m *AlertEventMutation) SetRuleID(u uuid.UUID) {
	m.rule = &u
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *AlertEventMutation) RuleID() (r uuid.UUID, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldRuleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *AlertEventMutation) ResetRuleID() {
	m.rule = nil
}

// SetStatus sets the "status" field.
func (m *AlertEventMutation) SetStatus(ees enum.AlertEventStatus) {
	m.status = &ees
}

// Status returns the value of the "status" field in the mutation.
func (m *AlertEventMutation) Status() (r enum.AlertEventStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldStatus(ctx context.Context) (v enum.AlertEventStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AlertEventMutation) ResetStatus() {
	m.status = nil
}

// SetAlertType sets the "alert_type" field.
func (m *AlertEventMutation) SetAlertType(et enum.AlertType) {
	m.alert_type = &et
}

// AlertType returns the value of the "alert_type" field in the mutation.
func (m *AlertEventMutation) AlertType() (r enum.AlertType, exists bool) {
	v := m.alert_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertType returns the old "alert_type" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldAlertType(ctx context.Context) (v enum.AlertType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertType: %w", err)
	}
	return oldValue.AlertType, nil
}

// ResetAlertType resets all changes to the "alert_type" field.
func (m *AlertEventMutation) ResetAlertType() {
	m.alert_type = nil
}

// SetSeverity sets the "severity" field.
func (m *AlertEventMutation) SetSeverity(es enum.AlertSeverity) {
	m.severity = &es
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertEventMutation) Severity() (r enum.AlertSeverity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldSeverity(ctx context.Context) (v enum.AlertSeverity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertEventMutation) ResetSeverity() {
	m.severity = nil
}

// SetSubject sets the "subject" field.
func (m *AlertEventMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *AlertEventMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *AlertEventMutation) ResetSubject() {
	m.subject = nil
}

// SetBody sets the "body" field.
func (m *AlertEventMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *AlertEventMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *AlertEventMutation) ResetBody() {
	m.body = nil
}

// SetContext sets the "context" field.
func (m *AlertEventMutation) SetContext(value map[string]interface{}) {
	m.context = &value
}

// Context returns the value of the "context" field in the mutation.
func (m *AlertEventMutation) Context() (r map[string]interface{}, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldContext(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ClearContext clears the value of the "context" field.
func (m *AlertEventMutation) ClearContext() {
	m.context = nil
	m.clearedFields[alertevent.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *AlertEventMutation) ContextCleared() bool {
	_, ok := m.clearedFields[alertevent.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *AlertEventMutation) ResetContext() {
	m.context = nil
	delete(m.clearedFields, alertevent.FieldContext)
}

// SetRecipients sets the "recipients" field.
func (m *AlertEventMutation) SetRecipients(s []string) {
	m.recipients = &s
	m.appendrecipients = nil
}

// Recipients returns the value of the "recipients" field in the mutation.
func (m *AlertEventMutation) Recipients() (r []string, exists bool) {
	v := m.recipients
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipients returns the old "recipients" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldRecipients(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipients is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipients requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipients: %w", err)
	}
	return oldValue.Recipients, nil
}

// AppendRecipients adds s to the "recipients" field.
func (m *AlertEventMutation) AppendRecipients(s []string) {
	m.appendrecipients = append(m.appendrecipients, s...)
}

// AppendedRecipients returns the list of values that were appended to the "recipients" field in this mutation.
func (m *AlertEventMutation) AppendedRecipients() ([]string, bool) {
	if len(m.appendrecipients) == 0 {
		return nil, false
	}
	return m.appendrecipients, true
}

// ResetRecipients resets all changes to the "recipients" field.
func (m *AlertEventMutation) ResetRecipients() {
	m.recipients = nil
	m.appendrecipients = nil
}

// SetChannelType sets the "channel_type" field.
func (m *AlertEventMutation) SetChannelType(s string) {
	m.channel_type = &s
}

// ChannelType returns the value of the "channel_type" field in the mutation.
func (m *AlertEventMutation) ChannelType() (r string, exists bool) {
	v := m.channel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelType returns the old "channel_type" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldChannelType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelType: %w", err)
	}
	return oldValue.ChannelType, nil
}

// ResetChannelType resets all changes to the "channel_type" field.
func (m *AlertEventMutation) ResetChannelType() {
	m.channel_type = nil
}

// SetSentAt sets the "sent_at" field.
func (m *AlertEventMutation) SetSentAt(t time.Time) {
	m.sent_at = &t
}

// SentAt returns the value of the "sent_at" field in the mutation.
func (m *AlertEventMutation) SentAt() (r time.Time, exists bool) {
	v := m.sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sent_at" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldSentAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ClearSentAt clears the value of the "sent_at" field.
func (m *AlertEventMutation) ClearSentAt() {
	m.sent_at = nil
	m.clearedFields[alertevent.FieldSentAt] = struct{}{}
}

// SentAtCleared returns if the "sent_at" field was cleared in this mutation.
func (m *AlertEventMutation) SentAtCleared() bool {
	_, ok := m.clearedFields[alertevent.FieldSentAt]
	return ok
}

// ResetSentAt resets all changes to the "sent_at" field.
func (m *AlertEventMutation) ResetSentAt() {
	m.sent_at = nil
	delete(m.clearedFields, alertevent.FieldSentAt)
}

// SetErrorMessage sets the "error_message" field.
func (m *AlertEventMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AlertEventMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AlertEventMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[alertevent.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AlertEventMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[alertevent.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AlertEventMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, alertevent.FieldErrorMessage)
}

// SetResourceType sets the "resource_type" field.
func (m *AlertEventMutation) SetResourceType(ert enum.AlertResourceType) {
	m.resource_type = &ert
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *AlertEventMutation) ResourceType() (r enum.AlertResourceType, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldResourceType(ctx context.Context) (v enum.AlertResourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *AlertEventMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *AlertEventMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *AlertEventMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldResourceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *AlertEventMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[alertevent.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *AlertEventMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[alertevent.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *AlertEventMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, alertevent.FieldResourceID)
}

// SetOwnerID sets the "owner_id" field.
func (m *AlertEventMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *AlertEventMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *AlertEventMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetReadAt sets the "read_at" field.
func (m *AlertEventMutation) SetReadAt(t time.Time) {
	m.read_at = &t
}

// ReadAt returns the value of the "read_at" field in the mutation.
func (m *AlertEventMutation) ReadAt() (r time.Time, exists bool) {
	v := m.read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReadAt returns the old "read_at" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldReadAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadAt: %w", err)
	}
	return oldValue.ReadAt, nil
}

// ClearReadAt clears the value of the "read_at" field.
func (m *AlertEventMutation) ClearReadAt() {
	m.read_at = nil
	m.clearedFields[alertevent.FieldReadAt] = struct{}{}
}

// ReadAtCleared returns if the "read_at" field was cleared in this mutation.
func (m *AlertEventMutation) ReadAtCleared() bool {
	_, ok := m.clearedFields[alertevent.FieldReadAt]
	return ok
}

// ResetReadAt resets all changes to the "read_at" field.
func (m *AlertEventMutation) ResetReadAt() {
	m.read_at = nil
	delete(m.clearedFields, alertevent.FieldReadAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertEvent entity.
// If the AlertEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearRule clears the "rule" edge to the AlertRule entity.
func (m *AlertEventMutation) ClearRule() {
	m.clearedrule = true
	m.clearedFields[alertevent.FieldRuleID] = struct{}{}
}

// RuleCleared reports if the "rule" edge to the AlertRule entity was cleared.
func (m *AlertEventMutation) RuleCleared() bool {
	return m.clearedrule
}

// RuleIDs returns the "rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuleID instead. It exists only for internal usage by the builders.
func (m *AlertEventMutation) RuleIDs() (ids []uuid.UUID) {
	if id := m.rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRule resets all changes to the "rule" edge.
func (m *AlertEventMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
}

// Where appends a list predicates to the AlertEventMutation builder.
func (m *AlertEventMutation) Where(ps ...predicate.AlertEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertEvent).
func (m *AlertEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertEventMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.rule != nil {
		fields = append(fields, alertevent.FieldRuleID)
	}
	if m.status != nil {
		fields = append(fields, alertevent.FieldStatus)
	}
	if m.alert_type != nil {
		fields = append(fields, alertevent.FieldAlertType)
	}
	if m.severity != nil {
		fields = append(fields, alertevent.FieldSeverity)
	}
	if m.subject != nil {
		fields = append(fields, alertevent.FieldSubject)
	}
	if m.body != nil {
		fields = append(fields, alertevent.FieldBody)
	}
	if m.context != nil {
		fields = append(fields, alertevent.FieldContext)
	}
	if m.recipients != nil {
		fields = append(fields, alertevent.FieldRecipients)
	}
	if m.channel_type != nil {
		fields = append(fields, alertevent.FieldChannelType)
	}
	if m.sent_at != nil {
		fields = append(fields, alertevent.FieldSentAt)
	}
	if m.error_message != nil {
		fields = append(fields, alertevent.FieldErrorMessage)
	}
	if m.resource_type != nil {
		fields = append(fields, alertevent.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, alertevent.FieldResourceID)
	}
	if m.owner_id != nil {
		fields = append(fields, alertevent.FieldOwnerID)
	}
	if m.read_at != nil {
		fields = append(fields, alertevent.FieldReadAt)
	}
	if m.created_at != nil {
		fields = append(fields, alertevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertevent.FieldRuleID:
		return m.RuleID()
	case alertevent.FieldStatus:
		return m.Status()
	case alertevent.FieldAlertType:
		return m.AlertType()
	case alertevent.FieldSeverity:
		return m.Severity()
	case alertevent.FieldSubject:
		return m.Subject()
	case alertevent.FieldBody:
		return m.Body()
	case alertevent.FieldContext:
		return m.Context()
	case alertevent.FieldRecipients:
		return m.Recipients()
	case alertevent.FieldChannelType:
		return m.ChannelType()
	case alertevent.FieldSentAt:
		return m.SentAt()
	case alertevent.FieldErrorMessage:
		return m.ErrorMessage()
	case alertevent.FieldResourceType:
		return m.ResourceType()
	case alertevent.FieldResourceID:
		return m.ResourceID()
	case alertevent.FieldOwnerID:
		return m.OwnerID()
	case alertevent.FieldReadAt:
		return m.ReadAt()
	case alertevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertevent.FieldRuleID:
		return m.OldRuleID(ctx)
	case alertevent.FieldStatus:
		return m.OldStatus(ctx)
	case alertevent.FieldAlertType:
		return m.OldAlertType(ctx)
	case alertevent.FieldSeverity:
		return m.OldSeverity(ctx)
	case alertevent.FieldSubject:
		return m.OldSubject(ctx)
	case alertevent.FieldBody:
		return m.OldBody(ctx)
	case alertevent.FieldContext:
		return m.OldContext(ctx)
	case alertevent.FieldRecipients:
		return m.OldRecipients(ctx)
	case alertevent.FieldChannelType:
		return m.OldChannelType(ctx)
	case alertevent.FieldSentAt:
		return m.OldSentAt(ctx)
	case alertevent.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case alertevent.FieldResourceType:
		return m.OldResourceType(ctx)
	case alertevent.FieldResourceID:
		return m.OldResourceID(ctx)
	case alertevent.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case alertevent.FieldReadAt:
		return m.OldReadAt(ctx)
	case alertevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertevent.FieldRuleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case alertevent.FieldStatus:
		v, ok := value.(enum.AlertEventStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case alertevent.FieldAlertType:
		v, ok := value.(enum.AlertType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertType(v)
		return nil
	case alertevent.FieldSeverity:
		v, ok := value.(enum.AlertSeverity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alertevent.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case alertevent.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case alertevent.FieldContext:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case alertevent.FieldRecipients:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipients(v)
		return nil
	case alertevent.FieldChannelType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelType(v)
		return nil
	case alertevent.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case alertevent.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case alertevent.FieldResourceType:
		v, ok := value.(enum.AlertResourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case alertevent.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case alertevent.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case alertevent.FieldReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadAt(v)
		return nil
	case alertevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertevent.FieldContext) {
		fields = append(fields, alertevent.FieldContext)
	}
	if m.FieldCleared(alertevent.FieldSentAt) {
		fields = append(fields, alertevent.FieldSentAt)
	}
	if m.FieldCleared(alertevent.FieldErrorMessage) {
		fields = append(fields, alertevent.FieldErrorMessage)
	}
	if m.FieldCleared(alertevent.FieldResourceID) {
		fields = append(fields, alertevent.FieldResourceID)
	}
	if m.FieldCleared(alertevent.FieldReadAt) {
		fields = append(fields, alertevent.FieldReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertEventMutation) ClearField(name string) error {
	switch name {
	case alertevent.FieldContext:
		m.ClearContext()
		return nil
	case alertevent.FieldSentAt:
		m.ClearSentAt()
		return nil
	case alertevent.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case alertevent.FieldResourceID:
		m.ClearResourceID()
		return nil
	case alertevent.FieldReadAt:
		m.ClearReadAt()
		return nil
	}
	return fmt.Errorf("unknown AlertEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertEventMutation) ResetField(name string) error {
	switch name {
	case alertevent.FieldRuleID:
		m.ResetRuleID()
		return nil
	case alertevent.FieldStatus:
		m.ResetStatus()
		return nil
	case alertevent.FieldAlertType:
		m.ResetAlertType()
		return nil
	case alertevent.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alertevent.FieldSubject:
		m.ResetSubject()
		return nil
	case alertevent.FieldBody:
		m.ResetBody()
		return nil
	case alertevent.FieldContext:
		m.ResetContext()
		return nil
	case alertevent.FieldRecipients:
		m.ResetRecipients()
		return nil
	case alertevent.FieldChannelType:
		m.ResetChannelType()
		return nil
	case alertevent.FieldSentAt:
		m.ResetSentAt()
		return nil
	case alertevent.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case alertevent.FieldResourceType:
		m.ResetResourceType()
		return nil
	case alertevent.FieldResourceID:
		m.ResetResourceID()
		return nil
	case alertevent.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case alertevent.FieldReadAt:
		m.ResetReadAt()
		return nil
	case alertevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rule != nil {
		edges = append(edges, alertevent.EdgeRule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alertevent.EdgeRule:
		if id := m.rule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrule {
		edges = append(edges, alertevent.EdgeRule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertEventMutation) EdgeCleared(name string) bool {
	switch name {
	case alertevent.EdgeRule:
		return m.clearedrule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertEventMutation) ClearEdge(name string) error {
	switch name {
	case alertevent.EdgeRule:
		m.ClearRule()
		return nil
	}
	return fmt.Errorf("unknown AlertEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertEventMutation) ResetEdge(name string) error {
	switch name {
	case alertevent.EdgeRule:
		m.ResetRule()
		return nil
	}
	return fmt.Errorf("unknown AlertEvent edge %s", name)
}

// AlertRuleMutation represents an operation that mutates the AlertRule nodes in the graph.
type AlertRuleMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	deleted_at                *time.Time
	name                      *string
	alert_type                *enum.AlertType
	severity                  *enum.AlertSeverity
	enabled                   *bool
	resource_type             *enum.AlertResourceType
	resource_id               *string
	conditions                *map[string]interface{}
	delivery_mode             *enum.AlertDeliveryMode
	batch_interval_minutes    *int
	addbatch_interval_minutes *int
	recipients                *[]string
	appendrecipients          []string
	bot_mode_filter           *enum.AlertBotModeFilter
	cooldown_minutes          *int
	addcooldown_minutes       *int
	last_triggered_at         *time.Time
	owner_id                  *string
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	events                    map[uuid.UUID]struct{}
	removedevents             map[uuid.UUID]struct{}
	clearedevents             bool
	done                      bool
	oldValue                  func(context.Context) (*AlertRule, error)
	predicates                []predicate.AlertRule
}

var _ ent.Mutation = (*AlertRuleMutation)(nil)

// alertruleOption allows management of the mutation configuration using functional options.
type alertruleOption func(*AlertRuleMutation)

// newAlertRuleMutation creates new mutation for the AlertRule entity.
func newAlertRuleMutation(c config, op Op, opts ...alertruleOption) *AlertRuleMutation {
	m := &AlertRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertRuleID sets the ID field of the mutation.
func withAlertRuleID(id uuid.UUID) alertruleOption {
	return func(m *AlertRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertRule
		)
		m.oldValue = func(ctx context.Context) (*AlertRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertRule sets the old AlertRule of the mutation.
func withAlertRule(node *AlertRule) alertruleOption {
	return func(m *AlertRuleMutation) {
		m.oldValue = func(context.Context) (*AlertRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertRule entities.
func (m *AlertRuleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertRuleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertRuleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AlertRuleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AlertRuleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AlertRuleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[alertrule.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AlertRuleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AlertRuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, alertrule.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AlertRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlertRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlertRuleMutation) ResetName() {
	m.name = nil
}

// SetAlertType sets the "alert_type" field.
func (m *AlertRuleMutation) SetAlertType(et enum.AlertType) {
	m.alert_type = &et
}

// AlertType returns the value of the "alert_type" field in the mutation.
func (m *AlertRuleMutation) AlertType() (r enum.AlertType, exists bool) {
	v := m.alert_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertType returns the old "alert_type" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldAlertType(ctx context.Context) (v enum.AlertType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertType: %w", err)
	}
	return oldValue.AlertType, nil
}

// ResetAlertType resets all changes to the "alert_type" field.
func (m *AlertRuleMutation) ResetAlertType() {
	m.alert_type = nil
}

// SetSeverity sets the "severity" field.
func (m *AlertRuleMutation) SetSeverity(es enum.AlertSeverity) {
	m.severity = &es
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertRuleMutation) Severity() (r enum.AlertSeverity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldSeverity(ctx context.Context) (v enum.AlertSeverity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertRuleMutation) ResetSeverity() {
	m.severity = nil
}

// SetEnabled sets the "enabled" field.
func (m *AlertRuleMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *AlertRuleMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *AlertRuleMutation) ResetEnabled() {
	m.enabled = nil
}

// SetResourceType sets the "resource_type" field.
func (m *AlertRuleMutation) SetResourceType(ert enum.AlertResourceType) {
	m.resource_type = &ert
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *AlertRuleMutation) ResourceType() (r enum.AlertResourceType, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldResourceType(ctx context.Context) (v enum.AlertResourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *AlertRuleMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *AlertRuleMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *AlertRuleMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldResourceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *AlertRuleMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[alertrule.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *AlertRuleMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *AlertRuleMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, alertrule.FieldResourceID)
}

// SetConditions sets the "conditions" field.
func (m *AlertRuleMutation) SetConditions(value map[string]interface{}) {
	m.conditions = &value
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *AlertRuleMutation) Conditions() (r map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldConditions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// ClearConditions clears the value of the "conditions" field.
func (m *AlertRuleMutation) ClearConditions() {
	m.conditions = nil
	m.clearedFields[alertrule.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *AlertRuleMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *AlertRuleMutation) ResetConditions() {
	m.conditions = nil
	delete(m.clearedFields, alertrule.FieldConditions)
}

// SetDeliveryMode sets the "delivery_mode" field.
func (m *AlertRuleMutation) SetDeliveryMode(edm enum.AlertDeliveryMode) {
	m.delivery_mode = &edm
}

// DeliveryMode returns the value of the "delivery_mode" field in the mutation.
func (m *AlertRuleMutation) DeliveryMode() (r enum.AlertDeliveryMode, exists bool) {
	v := m.delivery_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryMode returns the old "delivery_mode" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldDeliveryMode(ctx context.Context) (v enum.AlertDeliveryMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryMode: %w", err)
	}
	return oldValue.DeliveryMode, nil
}

// ResetDeliveryMode resets all changes to the "delivery_mode" field.
func (m *AlertRuleMutation) ResetDeliveryMode() {
	m.delivery_mode = nil
}

// SetBatchIntervalMinutes sets the "batch_interval_minutes" field.
func (m *AlertRuleMutation) SetBatchIntervalMinutes(i int) {
	m.batch_interval_minutes = &i
	m.addbatch_interval_minutes = nil
}

// BatchIntervalMinutes returns the value of the "batch_interval_minutes" field in the mutation.
func (m *AlertRuleMutation) BatchIntervalMinutes() (r int, exists bool) {
	v := m.batch_interval_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldBatchIntervalMinutes returns the old "batch_interval_minutes" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldBatchIntervalMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatchIntervalMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatchIntervalMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatchIntervalMinutes: %w", err)
	}
	return oldValue.BatchIntervalMinutes, nil
}

// AddBatchIntervalMinutes adds i to the "batch_interval_minutes" field.
func (m *AlertRuleMutation) AddBatchIntervalMinutes(i int) {
	if m.addbatch_interval_minutes != nil {
		*m.addbatch_interval_minutes += i
	} else {
		m.addbatch_interval_minutes = &i
	}
}

// AddedBatchIntervalMinutes returns the value that was added to the "batch_interval_minutes" field in this mutation.
func (m *AlertRuleMutation) AddedBatchIntervalMinutes() (r int, exists bool) {
	v := m.addbatch_interval_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetBatchIntervalMinutes resets all changes to the "batch_interval_minutes" field.
func (m *AlertRuleMutation) ResetBatchIntervalMinutes() {
	m.batch_interval_minutes = nil
	m.addbatch_interval_minutes = nil
}

// SetRecipients sets the "recipients" field.
func (m *AlertRuleMutation) SetRecipients(s []string) {
	m.recipients = &s
	m.appendrecipients = nil
}

// Recipients returns the value of the "recipients" field in the mutation.
func (m *AlertRuleMutation) Recipients() (r []string, exists bool) {
	v := m.recipients
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipients returns the old "recipients" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldRecipients(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipients is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipients requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipients: %w", err)
	}
	return oldValue.Recipients, nil
}

// AppendRecipients adds s to the "recipients" field.
func (m *AlertRuleMutation) AppendRecipients(s []string) {
	m.appendrecipients = append(m.appendrecipients, s...)
}

// AppendedRecipients returns the list of values that were appended to the "recipients" field in this mutation.
func (m *AlertRuleMutation) AppendedRecipients() ([]string, bool) {
	if len(m.appendrecipients) == 0 {
		return nil, false
	}
	return m.appendrecipients, true
}

// ResetRecipients resets all changes to the "recipients" field.
func (m *AlertRuleMutation) ResetRecipients() {
	m.recipients = nil
	m.appendrecipients = nil
}

// SetBotModeFilter sets the "bot_mode_filter" field.
func (m *AlertRuleMutation) SetBotModeFilter(ebmf enum.AlertBotModeFilter) {
	m.bot_mode_filter = &ebmf
}

// BotModeFilter returns the value of the "bot_mode_filter" field in the mutation.
func (m *AlertRuleMutation) BotModeFilter() (r enum.AlertBotModeFilter, exists bool) {
	v := m.bot_mode_filter
	if v == nil {
		return
	}
	return *v, true
}

// OldBotModeFilter returns the old "bot_mode_filter" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldBotModeFilter(ctx context.Context) (v enum.AlertBotModeFilter, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBotModeFilter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBotModeFilter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBotModeFilter: %w", err)
	}
	return oldValue.BotModeFilter, nil
}

// ResetBotModeFilter resets all changes to the "bot_mode_filter" field.
func (m *AlertRuleMutation) ResetBotModeFilter() {
	m.bot_mode_filter = nil
}

// SetCooldownMinutes sets the "cooldown_minutes" field.
func (m *AlertRuleMutation) SetCooldownMinutes(i int) {
	m.cooldown_minutes = &i
	m.addcooldown_minutes = nil
}

// CooldownMinutes returns the value of the "cooldown_minutes" field in the mutation.
func (m *AlertRuleMutation) CooldownMinutes() (r int, exists bool) {
	v := m.cooldown_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldownMinutes returns the old "cooldown_minutes" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldCooldownMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCooldownMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCooldownMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldownMinutes: %w", err)
	}
	return oldValue.CooldownMinutes, nil
}

// AddCooldownMinutes adds i to the "cooldown_minutes" field.
func (m *AlertRuleMutation) AddCooldownMinutes(i int) {
	if m.addcooldown_minutes != nil {
		*m.addcooldown_minutes += i
	} else {
		m.addcooldown_minutes = &i
	}
}

// AddedCooldownMinutes returns the value that was added to the "cooldown_minutes" field in this mutation.
func (m *AlertRuleMutation) AddedCooldownMinutes() (r int, exists bool) {
	v := m.addcooldown_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetCooldownMinutes resets all changes to the "cooldown_minutes" field.
func (m *AlertRuleMutation) ResetCooldownMinutes() {
	m.cooldown_minutes = nil
	m.addcooldown_minutes = nil
}

// SetLastTriggeredAt sets the "last_triggered_at" field.
func (m *AlertRuleMutation) SetLastTriggeredAt(t time.Time) {
	m.last_triggered_at = &t
}

// LastTriggeredAt returns the value of the "last_triggered_at" field in the mutation.
func (m *AlertRuleMutation) LastTriggeredAt() (r time.Time, exists bool) {
	v := m.last_triggered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTriggeredAt returns the old "last_triggered_at" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldLastTriggeredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastTriggeredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastTriggeredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTriggeredAt: %w", err)
	}
	return oldValue.LastTriggeredAt, nil
}

// ClearLastTriggeredAt clears the value of the "last_triggered_at" field.
func (m *AlertRuleMutation) ClearLastTriggeredAt() {
	m.last_triggered_at = nil
	m.clearedFields[alertrule.FieldLastTriggeredAt] = struct{}{}
}

// LastTriggeredAtCleared returns if the "last_triggered_at" field was cleared in this mutation.
func (m *AlertRuleMutation) LastTriggeredAtCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldLastTriggeredAt]
	return ok
}

// ResetLastTriggeredAt resets all changes to the "last_triggered_at" field.
func (m *AlertRuleMutation) ResetLastTriggeredAt() {
	m.last_triggered_at = nil
	delete(m.clearedFields, alertrule.FieldLastTriggeredAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *AlertRuleMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *AlertRuleMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *AlertRuleMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddEventIDs adds the "events" edge to the AlertEvent entity by ids.
func (m *AlertRuleMutation) AddEventIDs(ids ...uuid.UUID) {
	if m.events == nil {
		m.events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the AlertEvent entity.
func (m *AlertRuleMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the AlertEvent entity was cleared.
func (m *AlertRuleMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the AlertEvent entity by IDs.
func (m *AlertRuleMutation) RemoveEventIDs(ids ...uuid.UUID) {
	if m.removedevents == nil {
		m.removedevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the AlertEvent entity.
func (m *AlertRuleMutation) RemovedEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *AlertRuleMutation) EventsIDs() (ids []uuid.UUID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *AlertRuleMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the AlertRuleMutation builder.
func (m *AlertRuleMutation) Where(ps ...predicate.AlertRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertRule).
func (m *AlertRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertRuleMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.deleted_at != nil {
		fields = append(fields, alertrule.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, alertrule.FieldName)
	}
	if m.alert_type != nil {
		fields = append(fields, alertrule.FieldAlertType)
	}
	if m.severity != nil {
		fields = append(fields, alertrule.FieldSeverity)
	}
	if m.enabled != nil {
		fields = append(fields, alertrule.FieldEnabled)
	}
	if m.resource_type != nil {
		fields = append(fields, alertrule.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, alertrule.FieldResourceID)
	}
	if m.conditions != nil {
		fields = append(fields, alertrule.FieldConditions)
	}
	if m.delivery_mode != nil {
		fields = append(fields, alertrule.FieldDeliveryMode)
	}
	if m.batch_interval_minutes != nil {
		fields = append(fields, alertrule.FieldBatchIntervalMinutes)
	}
	if m.recipients != nil {
		fields = append(fields, alertrule.FieldRecipients)
	}
	if m.bot_mode_filter != nil {
		fields = append(fields, alertrule.FieldBotModeFilter)
	}
	if m.cooldown_minutes != nil {
		fields = append(fields, alertrule.FieldCooldownMinutes)
	}
	if m.last_triggered_at != nil {
		fields = append(fields, alertrule.FieldLastTriggeredAt)
	}
	if m.owner_id != nil {
		fields = append(fields, alertrule.FieldOwnerID)
	}
	if m.created_at != nil {
		fields = append(fields, alertrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alertrule.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertrule.FieldDeletedAt:
		return m.DeletedAt()
	case alertrule.FieldName:
		return m.Name()
	case alertrule.FieldAlertType:
		return m.AlertType()
	case alertrule.FieldSeverity:
		return m.Severity()
	case alertrule.FieldEnabled:
		return m.Enabled()
	case alertrule.FieldResourceType:
		return m.ResourceType()
	case alertrule.FieldResourceID:
		return m.ResourceID()
	case alertrule.FieldConditions:
		return m.Conditions()
	case alertrule.FieldDeliveryMode:
		return m.DeliveryMode()
	case alertrule.FieldBatchIntervalMinutes:
		return m.BatchIntervalMinutes()
	case alertrule.FieldRecipients:
		return m.Recipients()
	case alertrule.FieldBotModeFilter:
		return m.BotModeFilter()
	case alertrule.FieldCooldownMinutes:
		return m.CooldownMinutes()
	case alertrule.FieldLastTriggeredAt:
		return m.LastTriggeredAt()
	case alertrule.FieldOwnerID:
		return m.OwnerID()
	case alertrule.FieldCreatedAt:
		return m.CreatedAt()
	case alertrule.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertrule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case alertrule.FieldName:
		return m.OldName(ctx)
	case alertrule.FieldAlertType:
		return m.OldAlertType(ctx)
	case alertrule.FieldSeverity:
		return m.OldSeverity(ctx)
	case alertrule.FieldEnabled:
		return m.OldEnabled(ctx)
	case alertrule.FieldResourceType:
		return m.OldResourceType(ctx)
	case alertrule.FieldResourceID:
		return m.OldResourceID(ctx)
	case alertrule.FieldConditions:
		return m.OldConditions(ctx)
	case alertrule.FieldDeliveryMode:
		return m.OldDeliveryMode(ctx)
	case alertrule.FieldBatchIntervalMinutes:
		return m.OldBatchIntervalMinutes(ctx)
	case alertrule.FieldRecipients:
		return m.OldRecipients(ctx)
	case alertrule.FieldBotModeFilter:
		return m.OldBotModeFilter(ctx)
	case alertrule.FieldCooldownMinutes:
		return m.OldCooldownMinutes(ctx)
	case alertrule.FieldLastTriggeredAt:
		return m.OldLastTriggeredAt(ctx)
	case alertrule.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case alertrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alertrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertrule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case alertrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case alertrule.FieldAlertType:
		v, ok := value.(enum.AlertType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertType(v)
		return nil
	case alertrule.FieldSeverity:
		v, ok := value.(enum.AlertSeverity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alertrule.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case alertrule.FieldResourceType:
		v, ok := value.(enum.AlertResourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case alertrule.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case alertrule.FieldConditions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case alertrule.FieldDeliveryMode:
		v, ok := value.(enum.AlertDeliveryMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryMode(v)
		return nil
	case alertrule.FieldBatchIntervalMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatchIntervalMinutes(v)
		return nil
	case alertrule.FieldRecipients:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipients(v)
		return nil
	case alertrule.FieldBotModeFilter:
		v, ok := value.(enum.AlertBotModeFilter)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBotModeFilter(v)
		return nil
	case alertrule.FieldCooldownMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldownMinutes(v)
		return nil
	case alertrule.FieldLastTriggeredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTriggeredAt(v)
		return nil
	case alertrule.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case alertrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alertrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertRuleMutation) AddedFields() []string {
	var fields []string
	if m.addbatch_interval_minutes != nil {
		fields = append(fields, alertrule.FieldBatchIntervalMinutes)
	}
	if m.addcooldown_minutes != nil {
		fields = append(fields, alertrule.FieldCooldownMinutes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alertrule.FieldBatchIntervalMinutes:
		return m.AddedBatchIntervalMinutes()
	case alertrule.FieldCooldownMinutes:
		return m.AddedCooldownMinutes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alertrule.FieldBatchIntervalMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBatchIntervalMinutes(v)
		return nil
	case alertrule.FieldCooldownMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldownMinutes(v)
		return nil
	}
	return fmt.Errorf("unknown AlertRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertrule.FieldDeletedAt) {
		fields = append(fields, alertrule.FieldDeletedAt)
	}
	if m.FieldCleared(alertrule.FieldResourceID) {
		fields = append(fields, alertrule.FieldResourceID)
	}
	if m.FieldCleared(alertrule.FieldConditions) {
		fields = append(fields, alertrule.FieldConditions)
	}
	if m.FieldCleared(alertrule.FieldLastTriggeredAt) {
		fields = append(fields, alertrule.FieldLastTriggeredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertRuleMutation) ClearField(name string) error {
	switch name {
	case alertrule.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case alertrule.FieldResourceID:
		m.ClearResourceID()
		return nil
	case alertrule.FieldConditions:
		m.ClearConditions()
		return nil
	case alertrule.FieldLastTriggeredAt:
		m.ClearLastTriggeredAt()
		return nil
	}
	return fmt.Errorf("unknown AlertRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertRuleMutation) ResetField(name string) error {
	switch name {
	case alertrule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case alertrule.FieldName:
		m.ResetName()
		return nil
	case alertrule.FieldAlertType:
		m.ResetAlertType()
		return nil
	case alertrule.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alertrule.FieldEnabled:
		m.ResetEnabled()
		return nil
	case alertrule.FieldResourceType:
		m.ResetResourceType()
		return nil
	case alertrule.FieldResourceID:
		m.ResetResourceID()
		return nil
	case alertrule.FieldConditions:
		m.ResetConditions()
		return nil
	case alertrule.FieldDeliveryMode:
		m.ResetDeliveryMode()
		return nil
	case alertrule.FieldBatchIntervalMinutes:
		m.ResetBatchIntervalMinutes()
		return nil
	case alertrule.FieldRecipients:
		m.ResetRecipients()
		return nil
	case alertrule.FieldBotModeFilter:
		m.ResetBotModeFilter()
		return nil
	case alertrule.FieldCooldownMinutes:
		m.ResetCooldownMinutes()
		return nil
	case alertrule.FieldLastTriggeredAt:
		m.ResetLastTriggeredAt()
		return nil
	case alertrule.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case alertrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alertrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, alertrule.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alertrule.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, alertrule.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alertrule.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, alertrule.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case alertrule.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertRuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertRuleMutation) ResetEdge(name string) error {
	switch name {
	case alertrule.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown AlertRule edge %s", name)
}

// BacktestMutation represents an operation that mutates the Backtest nodes in the graph.
type BacktestMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	deleted_at      *time.Time
	status          *enum.TaskStatus
	result          *map[string]interface{}
	summary         *map[string]interface{}
	error_message   *string
	logs            *string
	created_at      *time.Time
	updated_at      *time.Time
	completed_at    *time.Time
	start_date      *time.Time
	end_date        *time.Time
	_config         *map[string]interface{}
	clearedFields   map[string]struct{}
	strategy        *uuid.UUID
	clearedstrategy bool
	runner          *uuid.UUID
	clearedrunner   bool
	done            bool
	oldValue        func(context.Context) (*Backtest, error)
	predicates      []predicate.Backtest
}

var _ ent.Mutation = (*BacktestMutation)(nil)

// backtestOption allows management of the mutation configuration using functional options.
type backtestOption func(*BacktestMutation)

// newBacktestMutation creates new mutation for the Backtest entity.
func newBacktestMutation(c config, op Op, opts ...backtestOption) *BacktestMutation {
	m := &BacktestMutation{
		config:        c,
		op:            op,
		typ:           TypeBacktest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBacktestID sets the ID field of the mutation.
func withBacktestID(id uuid.UUID) backtestOption {
	return func(m *BacktestMutation) {
		var (
			err   error
			once  sync.Once
			value *Backtest
		)
		m.oldValue = func(ctx context.Context) (*Backtest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Backtest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBacktest sets the old Backtest of the mutation.
func withBacktest(node *Backtest) backtestOption {
	return func(m *BacktestMutation) {
		m.oldValue = func(context.Context) (*Backtest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BacktestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BacktestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Backtest entities.
func (m *BacktestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BacktestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BacktestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Backtest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BacktestMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BacktestMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BacktestMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[backtest.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BacktestMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[backtest.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BacktestMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, backtest.FieldDeletedAt)
}

// SetStatus sets the "status" field.
func (m *BacktestMutation) SetStatus(es enum.TaskStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *BacktestMutation) Status() (r enum.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldStatus(ctx context.Context) (v enum.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BacktestMutation) ResetStatus() {
	m.status = nil
}

// SetResult sets the "result" field.
func (m *BacktestMutation) SetResult(value map[string]interface{}) {
	m.result = &value
}

// Result returns the value of the "result" field in the mutation.
func (m *BacktestMutation) Result() (r map[string]interface{}, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldResult(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *BacktestMutation) ClearResult() {
	m.result = nil
	m.clearedFields[backtest.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *BacktestMutation) ResultCleared() bool {
	_, ok := m.clearedFields[backtest.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *BacktestMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, backtest.FieldResult)
}

// SetSummary sets the "summary" field.
func (m *BacktestMutation) SetSummary(value map[string]interface{}) {
	m.summary = &value
}

// Summary returns the value of the "summary" field in the mutation.
func (m *BacktestMutation) Summary() (r map[string]interface{}, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldSummary(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *BacktestMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[backtest.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *BacktestMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[backtest.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *BacktestMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, backtest.FieldSummary)
}

// SetErrorMessage sets the "error_message" field.
func (m *BacktestMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *BacktestMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *BacktestMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[backtest.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *BacktestMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[backtest.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *BacktestMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, backtest.FieldErrorMessage)
}

// SetLogs sets the "logs" field.
func (m *BacktestMutation) SetLogs(s string) {
	m.logs = &s
}

// Logs returns the value of the "logs" field in the mutation.
func (m *BacktestMutation) Logs() (r string, exists bool) {
	v := m.logs
	if v == nil {
		return
	}
	return *v, true
}

// OldLogs returns the old "logs" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldLogs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogs: %w", err)
	}
	return oldValue.Logs, nil
}

// ClearLogs clears the value of the "logs" field.
func (m *BacktestMutation) ClearLogs() {
	m.logs = nil
	m.clearedFields[backtest.FieldLogs] = struct{}{}
}

// LogsCleared returns if the "logs" field was cleared in this mutation.
func (m *BacktestMutation) LogsCleared() bool {
	_, ok := m.clearedFields[backtest.FieldLogs]
	return ok
}

// ResetLogs resets all changes to the "logs" field.
func (m *BacktestMutation) ResetLogs() {
	m.logs = nil
	delete(m.clearedFields, backtest.FieldLogs)
}

// SetStrategyID sets the "strategy_id" field.
func (m *BacktestMutation) SetStrategyID(u uuid.UUID) {
	m.strategy = &u
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *BacktestMutation) StrategyID() (r uuid.UUID, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldStrategyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *BacktestMutation) ResetStrategyID() {
	m.strategy = nil
}

// SetRunnerID sets the "runner_id" field.
func (m *BacktestMutation) SetRunnerID(u uuid.UUID) {
	m.runner = &u
}

// RunnerID returns the value of the "runner_id" field in the mutation.
func (m *BacktestMutation) RunnerID() (r uuid.UUID, exists bool) {
	v := m.runner
	if v == nil {
		return
	}
	return *v, true
}

// OldRunnerID returns the old "runner_id" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldRunnerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunnerID: %w", err)
	}
	return oldValue.RunnerID, nil
}

// ResetRunnerID resets all changes to the "runner_id" field.
func (m *BacktestMutation) ResetRunnerID() {
	m.runner = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BacktestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BacktestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BacktestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BacktestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BacktestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BacktestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *BacktestMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *BacktestMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *BacktestMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[backtest.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *BacktestMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[backtest.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *BacktestMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, backtest.FieldCompletedAt)
}

// SetStartDate sets the "start_date" field.
func (m *BacktestMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *BacktestMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *BacktestMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[backtest.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *BacktestMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[backtest.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *BacktestMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, backtest.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *BacktestMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *BacktestMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *BacktestMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[backtest.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *BacktestMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[backtest.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *BacktestMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, backtest.FieldEndDate)
}

// SetConfig sets the "config" field.
func (m *BacktestMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *BacktestMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Backtest entity.
// If the Backtest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BacktestMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *BacktestMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[backtest.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *BacktestMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[backtest.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *BacktestMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, backtest.FieldConfig)
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *BacktestMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[backtest.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *BacktestMutation) StrategyCleared() bool {
	return m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *BacktestMutation) StrategyIDs() (ids []uuid.UUID) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *BacktestMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// ClearRunner clears the "runner" edge to the BotRunner entity.
func (m *BacktestMutation) ClearRunner() {
	m.clearedrunner = true
	m.clearedFields[backtest.FieldRunnerID] = struct{}{}
}

// RunnerCleared reports if the "runner" edge to the BotRunner entity was cleared.
func (m *BacktestMutation) RunnerCleared() bool {
	return m.clearedrunner
}

// RunnerIDs returns the "runner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunnerID instead. It exists only for internal usage by the builders.
func (m *BacktestMutation) RunnerIDs() (ids []uuid.UUID) {
	if id := m.runner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRunner resets all changes to the "runner" edge.
func (m *BacktestMutation) ResetRunner() {
	m.runner = nil
	m.clearedrunner = false
}

// Where appends a list predicates to the BacktestMutation builder.
func (m *BacktestMutation) Where(ps ...predicate.Backtest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BacktestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BacktestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Backtest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BacktestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BacktestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Backtest).
func (m *BacktestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BacktestMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.deleted_at != nil {
		fields = append(fields, backtest.FieldDeletedAt)
	}
	if m.status != nil {
		fields = append(fields, backtest.FieldStatus)
	}
	if m.result != nil {
		fields = append(fields, backtest.FieldResult)
	}
	if m.summary != nil {
		fields = append(fields, backtest.FieldSummary)
	}
	if m.error_message != nil {
		fields = append(fields, backtest.FieldErrorMessage)
	}
	if m.logs != nil {
		fields = append(fields, backtest.FieldLogs)
	}
	if m.strategy != nil {
		fields = append(fields, backtest.FieldStrategyID)
	}
	if m.runner != nil {
		fields = append(fields, backtest.FieldRunnerID)
	}
	if m.created_at != nil {
		fields = append(fields, backtest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backtest.FieldUpdatedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, backtest.FieldCompletedAt)
	}
	if m.start_date != nil {
		fields = append(fields, backtest.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, backtest.FieldEndDate)
	}
	if m._config != nil {
		fields = append(fields, backtest.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BacktestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backtest.FieldDeletedAt:
		return m.DeletedAt()
	case backtest.FieldStatus:
		return m.Status()
	case backtest.FieldResult:
		return m.Result()
	case backtest.FieldSummary:
		return m.Summary()
	case backtest.FieldErrorMessage:
		return m.ErrorMessage()
	case backtest.FieldLogs:
		return m.Logs()
	case backtest.FieldStrategyID:
		return m.StrategyID()
	case backtest.FieldRunnerID:
		return m.RunnerID()
	case backtest.FieldCreatedAt:
		return m.CreatedAt()
	case backtest.FieldUpdatedAt:
		return m.UpdatedAt()
	case backtest.FieldCompletedAt:
		return m.CompletedAt()
	case backtest.FieldStartDate:
		return m.StartDate()
	case backtest.FieldEndDate:
		return m.EndDate()
	case backtest.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BacktestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backtest.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case backtest.FieldStatus:
		return m.OldStatus(ctx)
	case backtest.FieldResult:
		return m.OldResult(ctx)
	case backtest.FieldSummary:
		return m.OldSummary(ctx)
	case backtest.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case backtest.FieldLogs:
		return m.OldLogs(ctx)
	case backtest.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case backtest.FieldRunnerID:
		return m.OldRunnerID(ctx)
	case backtest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backtest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case backtest.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case backtest.FieldStartDate:
		return m.OldStartDate(ctx)
	case backtest.FieldEndDate:
		return m.OldEndDate(ctx)
	case backtest.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown Backtest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BacktestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backtest.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case backtest.FieldStatus:
		v, ok := value.(enum.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case backtest.FieldResult:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case backtest.FieldSummary:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case backtest.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case backtest.FieldLogs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogs(v)
		return nil
	case backtest.FieldStrategyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case backtest.FieldRunnerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunnerID(v)
		return nil
	case backtest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backtest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case backtest.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case backtest.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case backtest.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case backtest.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown Backtest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BacktestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BacktestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BacktestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Backtest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BacktestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(backtest.FieldDeletedAt) {
		fields = append(fields, backtest.FieldDeletedAt)
	}
	if m.FieldCleared(backtest.FieldResult) {
		fields = append(fields, backtest.FieldResult)
	}
	if m.FieldCleared(backtest.FieldSummary) {
		fields = append(fields, backtest.FieldSummary)
	}
	if m.FieldCleared(backtest.FieldErrorMessage) {
		fields = append(fields, backtest.FieldErrorMessage)
	}
	if m.FieldCleared(backtest.FieldLogs) {
		fields = append(fields, backtest.FieldLogs)
	}
	if m.FieldCleared(backtest.FieldCompletedAt) {
		fields = append(fields, backtest.FieldCompletedAt)
	}
	if m.FieldCleared(backtest.FieldStartDate) {
		fields = append(fields, backtest.FieldStartDate)
	}
	if m.FieldCleared(backtest.FieldEndDate) {
		fields = append(fields, backtest.FieldEndDate)
	}
	if m.FieldCleared(backtest.FieldConfig) {
		fields = append(fields, backtest.FieldConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BacktestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BacktestMutation) ClearField(name string) error {
	switch name {
	case backtest.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case backtest.FieldResult:
		m.ClearResult()
		return nil
	case backtest.FieldSummary:
		m.ClearSummary()
		return nil
	case backtest.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case backtest.FieldLogs:
		m.ClearLogs()
		return nil
	case backtest.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case backtest.FieldStartDate:
		m.ClearStartDate()
		return nil
	case backtest.FieldEndDate:
		m.ClearEndDate()
		return nil
	case backtest.FieldConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Backtest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BacktestMutation) ResetField(name string) error {
	switch name {
	case backtest.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case backtest.FieldStatus:
		m.ResetStatus()
		return nil
	case backtest.FieldResult:
		m.ResetResult()
		return nil
	case backtest.FieldSummary:
		m.ResetSummary()
		return nil
	case backtest.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case backtest.FieldLogs:
		m.ResetLogs()
		return nil
	case backtest.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case backtest.FieldRunnerID:
		m.ResetRunnerID()
		return nil
	case backtest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backtest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case backtest.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case backtest.FieldStartDate:
		m.ResetStartDate()
		return nil
	case backtest.FieldEndDate:
		m.ResetEndDate()
		return nil
	case backtest.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Backtest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BacktestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.strategy != nil {
		edges = append(edges, backtest.EdgeStrategy)
	}
	if m.runner != nil {
		edges = append(edges, backtest.EdgeRunner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BacktestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case backtest.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	case backtest.EdgeRunner:
		if id := m.runner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BacktestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BacktestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BacktestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstrategy {
		edges = append(edges, backtest.EdgeStrategy)
	}
	if m.clearedrunner {
		edges = append(edges, backtest.EdgeRunner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BacktestMutation) EdgeCleared(name string) bool {
	switch name {
	case backtest.EdgeStrategy:
		return m.clearedstrategy
	case backtest.EdgeRunner:
		return m.clearedrunner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BacktestMutation) ClearEdge(name string) error {
	switch name {
	case backtest.EdgeStrategy:
		m.ClearStrategy()
		return nil
	case backtest.EdgeRunner:
		m.ClearRunner()
		return nil
	}
	return fmt.Errorf("unknown Backtest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BacktestMutation) ResetEdge(name string) error {
	switch name {
	case backtest.EdgeStrategy:
		m.ResetStrategy()
		return nil
	case backtest.EdgeRunner:
		m.ResetRunner()
		return nil
	}
	return fmt.Errorf("unknown Backtest edge %s", name)
}

// BotMutation represents an operation that mutates the Bot nodes in the graph.
type BotMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	public            *bool
	deleted_at        *time.Time
	name              *string
	status            *enum.BotStatus
	mode              *enum.BotMode
	_config           *map[string]interface{}
	secure_config     *map[string]interface{}
	freqtrade_version *string
	last_seen_at      *time.Time
	error_message     *string
	owner_id          *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	exchange          *uuid.UUID
	clearedexchange   bool
	strategy          *uuid.UUID
	clearedstrategy   bool
	runner            *uuid.UUID
	clearedrunner     bool
	trades            map[uuid.UUID]struct{}
	removedtrades     map[uuid.UUID]struct{}
	clearedtrades     bool
	metrics           *uuid.UUID
	clearedmetrics    bool
	done              bool
	oldValue          func(context.Context) (*Bot, error)
	predicates        []predicate.Bot
}

var _ ent.Mutation = (*BotMutation)(nil)

// botOption allows management of the mutation configuration using functional options.
type botOption func(*BotMutation)

// newBotMutation creates new mutation for the Bot entity.
func newBotMutation(c config, op Op, opts ...botOption) *BotMutation {
	m := &BotMutation{
		config:        c,
		op:            op,
		typ:           TypeBot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBotID sets the ID field of the mutation.
func withBotID(id uuid.UUID) botOption {
	return func(m *BotMutation) {
		var (
			err   error
			once  sync.Once
			value *Bot
		)
		m.oldValue = func(ctx context.Context) (*Bot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBot sets the old Bot of the mutation.
func withBot(node *Bot) botOption {
	return func(m *BotMutation) {
		m.oldValue = func(context.Context) (*Bot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bot entities.
func (m *BotMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BotMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BotMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublic sets the "public" field.
func (m *BotMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *BotMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *BotMutation) ResetPublic() {
	m.public = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BotMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BotMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BotMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[bot.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BotMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[bot.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BotMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, bot.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BotMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *BotMutation) SetStatus(es enum.BotStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *BotMutation) Status() (r enum.BotStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldStatus(ctx context.Context) (v enum.BotStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BotMutation) ResetStatus() {
	m.status = nil
}

// SetMode sets the "mode" field.
func (m *BotMutation) SetMode(em enum.BotMode) {
	m.mode = &em
}

// Mode returns the value of the "mode" field in the mutation.
func (m *BotMutation) Mode() (r enum.BotMode, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldMode(ctx context.Context) (v enum.BotMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *BotMutation) ResetMode() {
	m.mode = nil
}

// SetConfig sets the "config" field.
func (m *BotMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *BotMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *BotMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[bot.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *BotMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[bot.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *BotMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, bot.FieldConfig)
}

// SetSecureConfig sets the "secure_config" field.
func (m *BotMutation) SetSecureConfig(value map[string]interface{}) {
	m.secure_config = &value
}

// SecureConfig returns the value of the "secure_config" field in the mutation.
func (m *BotMutation) SecureConfig() (r map[string]interface{}, exists bool) {
	v := m.secure_config
	if v == nil {
		return
	}
	return *v, true
}

// OldSecureConfig returns the old "secure_config" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldSecureConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecureConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecureConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecureConfig: %w", err)
	}
	return oldValue.SecureConfig, nil
}

// ClearSecureConfig clears the value of the "secure_config" field.
func (m *BotMutation) ClearSecureConfig() {
	m.secure_config = nil
	m.clearedFields[bot.FieldSecureConfig] = struct{}{}
}

// SecureConfigCleared returns if the "secure_config" field was cleared in this mutation.
func (m *BotMutation) SecureConfigCleared() bool {
	_, ok := m.clearedFields[bot.FieldSecureConfig]
	return ok
}

// ResetSecureConfig resets all changes to the "secure_config" field.
func (m *BotMutation) ResetSecureConfig() {
	m.secure_config = nil
	delete(m.clearedFields, bot.FieldSecureConfig)
}

// SetFreqtradeVersion sets the "freqtrade_version" field.
func (m *BotMutation) SetFreqtradeVersion(s string) {
	m.freqtrade_version = &s
}

// FreqtradeVersion returns the value of the "freqtrade_version" field in the mutation.
func (m *BotMutation) FreqtradeVersion() (r string, exists bool) {
	v := m.freqtrade_version
	if v == nil {
		return
	}
	return *v, true
}

// OldFreqtradeVersion returns the old "freqtrade_version" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldFreqtradeVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreqtradeVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreqtradeVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreqtradeVersion: %w", err)
	}
	return oldValue.FreqtradeVersion, nil
}

// ResetFreqtradeVersion resets all changes to the "freqtrade_version" field.
func (m *BotMutation) ResetFreqtradeVersion() {
	m.freqtrade_version = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *BotMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *BotMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ClearLastSeenAt clears the value of the "last_seen_at" field.
func (m *BotMutation) ClearLastSeenAt() {
	m.last_seen_at = nil
	m.clearedFields[bot.FieldLastSeenAt] = struct{}{}
}

// LastSeenAtCleared returns if the "last_seen_at" field was cleared in this mutation.
func (m *BotMutation) LastSeenAtCleared() bool {
	_, ok := m.clearedFields[bot.FieldLastSeenAt]
	return ok
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *BotMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
	delete(m.clearedFields, bot.FieldLastSeenAt)
}

// SetErrorMessage sets the "error_message" field.
func (m *BotMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *BotMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *BotMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[bot.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *BotMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[bot.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *BotMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, bot.FieldErrorMessage)
}

// SetExchangeID sets the "exchange_id" field.
func (m *BotMutation) SetExchangeID(u uuid.UUID) {
	m.exchange = &u
}

// ExchangeID returns the value of the "exchange_id" field in the mutation.
func (m *BotMutation) ExchangeID() (r uuid.UUID, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeID returns the old "exchange_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldExchangeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeID: %w", err)
	}
	return oldValue.ExchangeID, nil
}

// ResetExchangeID resets all changes to the "exchange_id" field.
func (m *BotMutation) ResetExchangeID() {
	m.exchange = nil
}

// SetStrategyID sets the "strategy_id" field.
func (m *BotMutation) SetStrategyID(u uuid.UUID) {
	m.strategy = &u
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *BotMutation) StrategyID() (r uuid.UUID, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldStrategyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *BotMutation) ResetStrategyID() {
	m.strategy = nil
}

// SetRunnerID sets the "runner_id" field.
func (m *BotMutation) SetRunnerID(u uuid.UUID) {
	m.runner = &u
}

// RunnerID returns the value of the "runner_id" field in the mutation.
func (m *BotMutation) RunnerID() (r uuid.UUID, exists bool) {
	v := m.runner
	if v == nil {
		return
	}
	return *v, true
}

// OldRunnerID returns the old "runner_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldRunnerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunnerID: %w", err)
	}
	return oldValue.RunnerID, nil
}

// ResetRunnerID resets all changes to the "runner_id" field.
func (m *BotMutation) ResetRunnerID() {
	m.runner = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *BotMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *BotMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *BotMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bot entity.
// If the Bot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearExchange clears the "exchange" edge to the Exchange entity.
func (m *BotMutation) ClearExchange() {
	m.clearedexchange = true
	m.clearedFields[bot.FieldExchangeID] = struct{}{}
}

// ExchangeCleared reports if the "exchange" edge to the Exchange entity was cleared.
func (m *BotMutation) ExchangeCleared() bool {
	return m.clearedexchange
}

// ExchangeIDs returns the "exchange" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExchangeID instead. It exists only for internal usage by the builders.
func (m *BotMutation) ExchangeIDs() (ids []uuid.UUID) {
	if id := m.exchange; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExchange resets all changes to the "exchange" edge.
func (m *BotMutation) ResetExchange() {
	m.exchange = nil
	m.clearedexchange = false
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *BotMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[bot.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *BotMutation) StrategyCleared() bool {
	return m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *BotMutation) StrategyIDs() (ids []uuid.UUID) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *BotMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// ClearRunner clears the "runner" edge to the BotRunner entity.
func (m *BotMutation) ClearRunner() {
	m.clearedrunner = true
	m.clearedFields[bot.FieldRunnerID] = struct{}{}
}

// RunnerCleared reports if the "runner" edge to the BotRunner entity was cleared.
func (m *BotMutation) RunnerCleared() bool {
	return m.clearedrunner
}

// RunnerIDs returns the "runner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunnerID instead. It exists only for internal usage by the builders.
func (m *BotMutation) RunnerIDs() (ids []uuid.UUID) {
	if id := m.runner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRunner resets all changes to the "runner" edge.
func (m *BotMutation) ResetRunner() {
	m.runner = nil
	m.clearedrunner = false
}

// AddTradeIDs adds the "trades" edge to the Trade entity by ids.
func (m *BotMutation) AddTradeIDs(ids ...uuid.UUID) {
	if m.trades == nil {
		m.trades = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.trades[ids[i]] = struct{}{}
	}
}

// ClearTrades clears the "trades" edge to the Trade entity.
func (m *BotMutation) ClearTrades() {
	m.clearedtrades = true
}

// TradesCleared reports if the "trades" edge to the Trade entity was cleared.
func (m *BotMutation) TradesCleared() bool {
	return m.clearedtrades
}

// RemoveTradeIDs removes the "trades" edge to the Trade entity by IDs.
func (m *BotMutation) RemoveTradeIDs(ids ...uuid.UUID) {
	if m.removedtrades == nil {
		m.removedtrades = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.trades, ids[i])
		m.removedtrades[ids[i]] = struct{}{}
	}
}

// RemovedTrades returns the removed IDs of the "trades" edge to the Trade entity.
func (m *BotMutation) RemovedTradesIDs() (ids []uuid.UUID) {
	for id := range m.removedtrades {
		ids = append(ids, id)
	}
	return
}

// TradesIDs returns the "trades" edge IDs in the mutation.
func (m *BotMutation) TradesIDs() (ids []uuid.UUID) {
	for id := range m.trades {
		ids = append(ids, id)
	}
	return
}

// ResetTrades resets all changes to the "trades" edge.
func (m *BotMutation) ResetTrades() {
	m.trades = nil
	m.clearedtrades = false
	m.removedtrades = nil
}

// SetMetricsID sets the "metrics" edge to the BotMetrics entity by id.
func (m *BotMutation) SetMetricsID(id uuid.UUID) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the BotMetrics entity.
func (m *BotMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the BotMetrics entity was cleared.
func (m *BotMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *BotMutation) MetricsID() (id uuid.UUID, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *BotMutation) MetricsIDs() (ids []uuid.UUID) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *BotMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// Where appends a list predicates to the BotMutation builder.
func (m *BotMutation) Where(ps ...predicate.Bot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bot).
func (m *BotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BotMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.public != nil {
		fields = append(fields, bot.FieldPublic)
	}
	if m.deleted_at != nil {
		fields = append(fields, bot.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, bot.FieldName)
	}
	if m.status != nil {
		fields = append(fields, bot.FieldStatus)
	}
	if m.mode != nil {
		fields = append(fields, bot.FieldMode)
	}
	if m._config != nil {
		fields = append(fields, bot.FieldConfig)
	}
	if m.secure_config != nil {
		fields = append(fields, bot.FieldSecureConfig)
	}
	if m.freqtrade_version != nil {
		fields = append(fields, bot.FieldFreqtradeVersion)
	}
	if m.last_seen_at != nil {
		fields = append(fields, bot.FieldLastSeenAt)
	}
	if m.error_message != nil {
		fields = append(fields, bot.FieldErrorMessage)
	}
	if m.exchange != nil {
		fields = append(fields, bot.FieldExchangeID)
	}
	if m.strategy != nil {
		fields = append(fields, bot.FieldStrategyID)
	}
	if m.runner != nil {
		fields = append(fields, bot.FieldRunnerID)
	}
	if m.owner_id != nil {
		fields = append(fields, bot.FieldOwnerID)
	}
	if m.created_at != nil {
		fields = append(fields, bot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bot.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bot.FieldPublic:
		return m.Public()
	case bot.FieldDeletedAt:
		return m.DeletedAt()
	case bot.FieldName:
		return m.Name()
	case bot.FieldStatus:
		return m.Status()
	case bot.FieldMode:
		return m.Mode()
	case bot.FieldConfig:
		return m.Config()
	case bot.FieldSecureConfig:
		return m.SecureConfig()
	case bot.FieldFreqtradeVersion:
		return m.FreqtradeVersion()
	case bot.FieldLastSeenAt:
		return m.LastSeenAt()
	case bot.FieldErrorMessage:
		return m.ErrorMessage()
	case bot.FieldExchangeID:
		return m.ExchangeID()
	case bot.FieldStrategyID:
		return m.StrategyID()
	case bot.FieldRunnerID:
		return m.RunnerID()
	case bot.FieldOwnerID:
		return m.OwnerID()
	case bot.FieldCreatedAt:
		return m.CreatedAt()
	case bot.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bot.FieldPublic:
		return m.OldPublic(ctx)
	case bot.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case bot.FieldName:
		return m.OldName(ctx)
	case bot.FieldStatus:
		return m.OldStatus(ctx)
	case bot.FieldMode:
		return m.OldMode(ctx)
	case bot.FieldConfig:
		return m.OldConfig(ctx)
	case bot.FieldSecureConfig:
		return m.OldSecureConfig(ctx)
	case bot.FieldFreqtradeVersion:
		return m.OldFreqtradeVersion(ctx)
	case bot.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	case bot.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case bot.FieldExchangeID:
		return m.OldExchangeID(ctx)
	case bot.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case bot.FieldRunnerID:
		return m.OldRunnerID(ctx)
	case bot.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case bot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Bot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bot.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case bot.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case bot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bot.FieldStatus:
		v, ok := value.(enum.BotStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bot.FieldMode:
		v, ok := value.(enum.BotMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case bot.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case bot.FieldSecureConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecureConfig(v)
		return nil
	case bot.FieldFreqtradeVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreqtradeVersion(v)
		return nil
	case bot.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	case bot.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case bot.FieldExchangeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeID(v)
		return nil
	case bot.FieldStrategyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case bot.FieldRunnerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunnerID(v)
		return nil
	case bot.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case bot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Bot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bot.FieldDeletedAt) {
		fields = append(fields, bot.FieldDeletedAt)
	}
	if m.FieldCleared(bot.FieldConfig) {
		fields = append(fields, bot.FieldConfig)
	}
	if m.FieldCleared(bot.FieldSecureConfig) {
		fields = append(fields, bot.FieldSecureConfig)
	}
	if m.FieldCleared(bot.FieldLastSeenAt) {
		fields = append(fields, bot.FieldLastSeenAt)
	}
	if m.FieldCleared(bot.FieldErrorMessage) {
		fields = append(fields, bot.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BotMutation) ClearField(name string) error {
	switch name {
	case bot.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case bot.FieldConfig:
		m.ClearConfig()
		return nil
	case bot.FieldSecureConfig:
		m.ClearSecureConfig()
		return nil
	case bot.FieldLastSeenAt:
		m.ClearLastSeenAt()
		return nil
	case bot.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown Bot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BotMutation) ResetField(name string) error {
	switch name {
	case bot.FieldPublic:
		m.ResetPublic()
		return nil
	case bot.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case bot.FieldName:
		m.ResetName()
		return nil
	case bot.FieldStatus:
		m.ResetStatus()
		return nil
	case bot.FieldMode:
		m.ResetMode()
		return nil
	case bot.FieldConfig:
		m.ResetConfig()
		return nil
	case bot.FieldSecureConfig:
		m.ResetSecureConfig()
		return nil
	case bot.FieldFreqtradeVersion:
		m.ResetFreqtradeVersion()
		return nil
	case bot.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	case bot.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case bot.FieldExchangeID:
		m.ResetExchangeID()
		return nil
	case bot.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case bot.FieldRunnerID:
		m.ResetRunnerID()
		return nil
	case bot.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case bot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Bot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BotMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.exchange != nil {
		edges = append(edges, bot.EdgeExchange)
	}
	if m.strategy != nil {
		edges = append(edges, bot.EdgeStrategy)
	}
	if m.runner != nil {
		edges = append(edges, bot.EdgeRunner)
	}
	if m.trades != nil {
		edges = append(edges, bot.EdgeTrades)
	}
	if m.metrics != nil {
		edges = append(edges, bot.EdgeMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bot.EdgeExchange:
		if id := m.exchange; id != nil {
			return []ent.Value{*id}
		}
	case bot.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	case bot.EdgeRunner:
		if id := m.runner; id != nil {
			return []ent.Value{*id}
		}
	case bot.EdgeTrades:
		ids := make([]ent.Value, 0, len(m.trades))
		for id := range m.trades {
			ids = append(ids, id)
		}
		return ids
	case bot.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtrades != nil {
		edges = append(edges, bot.EdgeTrades)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BotMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bot.EdgeTrades:
		ids := make([]ent.Value, 0, len(m.removedtrades))
		for id := range m.removedtrades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedexchange {
		edges = append(edges, bot.EdgeExchange)
	}
	if m.clearedstrategy {
		edges = append(edges, bot.EdgeStrategy)
	}
	if m.clearedrunner {
		edges = append(edges, bot.EdgeRunner)
	}
	if m.clearedtrades {
		edges = append(edges, bot.EdgeTrades)
	}
	if m.clearedmetrics {
		edges = append(edges, bot.EdgeMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BotMutation) EdgeCleared(name string) bool {
	switch name {
	case bot.EdgeExchange:
		return m.clearedexchange
	case bot.EdgeStrategy:
		return m.clearedstrategy
	case bot.EdgeRunner:
		return m.clearedrunner
	case bot.EdgeTrades:
		return m.clearedtrades
	case bot.EdgeMetrics:
		return m.clearedmetrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BotMutation) ClearEdge(name string) error {
	switch name {
	case bot.EdgeExchange:
		m.ClearExchange()
		return nil
	case bot.EdgeStrategy:
		m.ClearStrategy()
		return nil
	case bot.EdgeRunner:
		m.ClearRunner()
		return nil
	case bot.EdgeMetrics:
		m.ClearMetrics()
		return nil
	}
	return fmt.Errorf("unknown Bot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BotMutation) ResetEdge(name string) error {
	switch name {
	case bot.EdgeExchange:
		m.ResetExchange()
		return nil
	case bot.EdgeStrategy:
		m.ResetStrategy()
		return nil
	case bot.EdgeRunner:
		m.ResetRunner()
		return nil
	case bot.EdgeTrades:
		m.ResetTrades()
		return nil
	case bot.EdgeMetrics:
		m.ResetMetrics()
		return nil
	}
	return fmt.Errorf("unknown Bot edge %s", name)
}

// BotMetricsMutation represents an operation that mutates the BotMetrics nodes in the graph.
type BotMetricsMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	deleted_at                 *time.Time
	profit_closed_coin         *float64
	addprofit_closed_coin      *float64
	profit_closed_percent      *float64
	addprofit_closed_percent   *float64
	profit_all_coin            *float64
	addprofit_all_coin         *float64
	profit_all_percent         *float64
	addprofit_all_percent      *float64
	trade_count                *int
	addtrade_count             *int
	closed_trade_count         *int
	addclosed_trade_count      *int
	open_trade_count           *int
	addopen_trade_count        *int
	winning_trades             *int
	addwinning_trades          *int
	losing_trades              *int
	addlosing_trades           *int
	winrate                    *float64
	addwinrate                 *float64
	expectancy                 *float64
	addexpectancy              *float64
	profit_factor              *float64
	addprofit_factor           *float64
	max_drawdown               *float64
	addmax_drawdown            *float64
	max_drawdown_abs           *float64
	addmax_drawdown_abs        *float64
	best_pair                  *string
	best_rate                  *float64
	addbest_rate               *float64
	first_trade_timestamp      *time.Time
	latest_trade_timestamp     *time.Time
	fetched_at                 *time.Time
	updated_at                 *time.Time
	last_synced_trade_id       *int
	addlast_synced_trade_id    *int
	last_known_max_trade_id    *int
	addlast_known_max_trade_id *int
	last_trade_sync_at         *time.Time
	clearedFields              map[string]struct{}
	bot                        *uuid.UUID
	clearedbot                 bool
	done                       bool
	oldValue                   func(context.Context) (*BotMetrics, error)
	predicates                 []predicate.BotMetrics
}

var _ ent.Mutation = (*BotMetricsMutation)(nil)

// botmetricsOption allows management of the mutation configuration using functional options.
type botmetricsOption func(*BotMetricsMutation)

// newBotMetricsMutation creates new mutation for the BotMetrics entity.
func newBotMetricsMutation(c config, op Op, opts ...botmetricsOption) *BotMetricsMutation {
	m := &BotMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeBotMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBotMetricsID sets the ID field of the mutation.
func withBotMetricsID(id uuid.UUID) botmetricsOption {
	return func(m *BotMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *BotMetrics
		)
		m.oldValue = func(ctx context.Context) (*BotMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BotMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBotMetrics sets the old BotMetrics of the mutation.
func withBotMetrics(node *BotMetrics) botmetricsOption {
	return func(m *BotMetricsMutation) {
		m.oldValue = func(context.Context) (*BotMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BotMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BotMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BotMetrics entities.
func (m *BotMetricsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BotMetricsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BotMetricsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BotMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BotMetricsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BotMetricsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BotMetricsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[botmetrics.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BotMetricsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BotMetricsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, botmetrics.FieldDeletedAt)
}

// SetBotID sets the "bot_id" field.
func (m *BotMetricsMutation) SetBotID(u uuid.UUID) {
	m.bot = &u
}

// BotID returns the value of the "bot_id" field in the mutation.
func (m *BotMetricsMutation) BotID() (r uuid.UUID, exists bool) {
	v := m.bot
	if v == nil {
		return
	}
	return *v, true
}

// OldBotID returns the old "bot_id" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldBotID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBotID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBotID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBotID: %w", err)
	}
	return oldValue.BotID, nil
}

// ResetBotID resets all changes to the "bot_id" field.
func (m *BotMetricsMutation) ResetBotID() {
	m.bot = nil
}

// SetProfitClosedCoin sets the "profit_closed_coin" field.
func (m *BotMetricsMutation) SetProfitClosedCoin(f float64) {
	m.profit_closed_coin = &f
	m.addprofit_closed_coin = nil
}

// ProfitClosedCoin returns the value of the "profit_closed_coin" field in the mutation.
func (m *BotMetricsMutation) ProfitClosedCoin() (r float64, exists bool) {
	v := m.profit_closed_coin
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitClosedCoin returns the old "profit_closed_coin" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldProfitClosedCoin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitClosedCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitClosedCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitClosedCoin: %w", err)
	}
	return oldValue.ProfitClosedCoin, nil
}

// AddProfitClosedCoin adds f to the "profit_closed_coin" field.
func (m *BotMetricsMutation) AddProfitClosedCoin(f float64) {
	if m.addprofit_closed_coin != nil {
		*m.addprofit_closed_coin += f
	} else {
		m.addprofit_closed_coin = &f
	}
}

// AddedProfitClosedCoin returns the value that was added to the "profit_closed_coin" field in this mutation.
func (m *BotMetricsMutation) AddedProfitClosedCoin() (r float64, exists bool) {
	v := m.addprofit_closed_coin
	if v == nil {
		return
	}
	return *v, true
}

// ClearProfitClosedCoin clears the value of the "profit_closed_coin" field.
func (m *BotMetricsMutation) ClearProfitClosedCoin() {
	m.profit_closed_coin = nil
	m.addprofit_closed_coin = nil
	m.clearedFields[botmetrics.FieldProfitClosedCoin] = struct{}{}
}

// ProfitClosedCoinCleared returns if the "profit_closed_coin" field was cleared in this mutation.
func (m *BotMetricsMutation) ProfitClosedCoinCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldProfitClosedCoin]
	return ok
}

// ResetProfitClosedCoin resets all changes to the "profit_closed_coin" field.
func (m *BotMetricsMutation) ResetProfitClosedCoin() {
	m.profit_closed_coin = nil
	m.addprofit_closed_coin = nil
	delete(m.clearedFields, botmetrics.FieldProfitClosedCoin)
}

// SetProfitClosedPercent sets the "profit_closed_percent" field.
func (m *BotMetricsMutation) SetProfitClosedPercent(f float64) {
	m.profit_closed_percent = &f
	m.addprofit_closed_percent = nil
}

// ProfitClosedPercent returns the value of the "profit_closed_percent" field in the mutation.
func (m *BotMetricsMutation) ProfitClosedPercent() (r float64, exists bool) {
	v := m.profit_closed_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitClosedPercent returns the old "profit_closed_percent" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldProfitClosedPercent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitClosedPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitClosedPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitClosedPercent: %w", err)
	}
	return oldValue.ProfitClosedPercent, nil
}

// AddProfitClosedPercent adds f to the "profit_closed_percent" field.
func (m *BotMetricsMutation) AddProfitClosedPercent(f float64) {
	if m.addprofit_closed_percent != nil {
		*m.addprofit_closed_percent += f
	} else {
		m.addprofit_closed_percent = &f
	}
}

// AddedProfitClosedPercent returns the value that was added to the "profit_closed_percent" field in this mutation.
func (m *BotMetricsMutation) AddedProfitClosedPercent() (r float64, exists bool) {
	v := m.addprofit_closed_percent
	if v == nil {
		return
	}
	return *v, true
}

// ClearProfitClosedPercent clears the value of the "profit_closed_percent" field.
func (m *BotMetricsMutation) ClearProfitClosedPercent() {
	m.profit_closed_percent = nil
	m.addprofit_closed_percent = nil
	m.clearedFields[botmetrics.FieldProfitClosedPercent] = struct{}{}
}

// ProfitClosedPercentCleared returns if the "profit_closed_percent" field was cleared in this mutation.
func (m *BotMetricsMutation) ProfitClosedPercentCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldProfitClosedPercent]
	return ok
}

// ResetProfitClosedPercent resets all changes to the "profit_closed_percent" field.
func (m *BotMetricsMutation) ResetProfitClosedPercent() {
	m.profit_closed_percent = nil
	m.addprofit_closed_percent = nil
	delete(m.clearedFields, botmetrics.FieldProfitClosedPercent)
}

// SetProfitAllCoin sets the "profit_all_coin" field.
func (m *BotMetricsMutation) SetProfitAllCoin(f float64) {
	m.profit_all_coin = &f
	m.addprofit_all_coin = nil
}

// ProfitAllCoin returns the value of the "profit_all_coin" field in the mutation.
func (m *BotMetricsMutation) ProfitAllCoin() (r float64, exists bool) {
	v := m.profit_all_coin
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAllCoin returns the old "profit_all_coin" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldProfitAllCoin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAllCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAllCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAllCoin: %w", err)
	}
	return oldValue.ProfitAllCoin, nil
}

// AddProfitAllCoin adds f to the "profit_all_coin" field.
func (m *BotMetricsMutation) AddProfitAllCoin(f float64) {
	if m.addprofit_all_coin != nil {
		*m.addprofit_all_coin += f
	} else {
		m.addprofit_all_coin = &f
	}
}

// AddedProfitAllCoin returns the value that was added to the "profit_all_coin" field in this mutation.
func (m *BotMetricsMutation) AddedProfitAllCoin() (r float64, exists bool) {
	v := m.addprofit_all_coin
	if v == nil {
		return
	}
	return *v, true
}

// ClearProfitAllCoin clears the value of the "profit_all_coin" field.
func (m *BotMetricsMutation) ClearProfitAllCoin() {
	m.profit_all_coin = nil
	m.addprofit_all_coin = nil
	m.clearedFields[botmetrics.FieldProfitAllCoin] = struct{}{}
}

// ProfitAllCoinCleared returns if the "profit_all_coin" field was cleared in this mutation.
func (m *BotMetricsMutation) ProfitAllCoinCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldProfitAllCoin]
	return ok
}

// ResetProfitAllCoin resets all changes to the "profit_all_coin" field.
func (m *BotMetricsMutation) ResetProfitAllCoin() {
	m.profit_all_coin = nil
	m.addprofit_all_coin = nil
	delete(m.clearedFields, botmetrics.FieldProfitAllCoin)
}

// SetProfitAllPercent sets the "profit_all_percent" field.
func (m *BotMetricsMutation) SetProfitAllPercent(f float64) {
	m.profit_all_percent = &f
	m.addprofit_all_percent = nil
}

// ProfitAllPercent returns the value of the "profit_all_percent" field in the mutation.
func (m *BotMetricsMutation) ProfitAllPercent() (r float64, exists bool) {
	v := m.profit_all_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAllPercent returns the old "profit_all_percent" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldProfitAllPercent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAllPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAllPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAllPercent: %w", err)
	}
	return oldValue.ProfitAllPercent, nil
}

// AddProfitAllPercent adds f to the "profit_all_percent" field.
func (m *BotMetricsMutation) AddProfitAllPercent(f float64) {
	if m.addprofit_all_percent != nil {
		*m.addprofit_all_percent += f
	} else {
		m.addprofit_all_percent = &f
	}
}

// AddedProfitAllPercent returns the value that was added to the "profit_all_percent" field in this mutation.
func (m *BotMetricsMutation) AddedProfitAllPercent() (r float64, exists bool) {
	v := m.addprofit_all_percent
	if v == nil {
		return
	}
	return *v, true
}

// ClearProfitAllPercent clears the value of the "profit_all_percent" field.
func (m *BotMetricsMutation) ClearProfitAllPercent() {
	m.profit_all_percent = nil
	m.addprofit_all_percent = nil
	m.clearedFields[botmetrics.FieldProfitAllPercent] = struct{}{}
}

// ProfitAllPercentCleared returns if the "profit_all_percent" field was cleared in this mutation.
func (m *BotMetricsMutation) ProfitAllPercentCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldProfitAllPercent]
	return ok
}

// ResetProfitAllPercent resets all changes to the "profit_all_percent" field.
func (m *BotMetricsMutation) ResetProfitAllPercent() {
	m.profit_all_percent = nil
	m.addprofit_all_percent = nil
	delete(m.clearedFields, botmetrics.FieldProfitAllPercent)
}

// SetTradeCount sets the "trade_count" field.
func (m *BotMetricsMutation) SetTradeCount(i int) {
	m.trade_count = &i
	m.addtrade_count = nil
}

// TradeCount returns the value of the "trade_count" field in the mutation.
func (m *BotMetricsMutation) TradeCount() (r int, exists bool) {
	v := m.trade_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeCount returns the old "trade_count" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldTradeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeCount: %w", err)
	}
	return oldValue.TradeCount, nil
}

// AddTradeCount adds i to the "trade_count" field.
func (m *BotMetricsMutation) AddTradeCount(i int) {
	if m.addtrade_count != nil {
		*m.addtrade_count += i
	} else {
		m.addtrade_count = &i
	}
}

// AddedTradeCount returns the value that was added to the "trade_count" field in this mutation.
func (m *BotMetricsMutation) AddedTradeCount() (r int, exists bool) {
	v := m.addtrade_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTradeCount clears the value of the "trade_count" field.
func (m *BotMetricsMutation) ClearTradeCount() {
	m.trade_count = nil
	m.addtrade_count = nil
	m.clearedFields[botmetrics.FieldTradeCount] = struct{}{}
}

// TradeCountCleared returns if the "trade_count" field was cleared in this mutation.
func (m *BotMetricsMutation) TradeCountCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldTradeCount]
	return ok
}

// ResetTradeCount resets all changes to the "trade_count" field.
func (m *BotMetricsMutation) ResetTradeCount() {
	m.trade_count = nil
	m.addtrade_count = nil
	delete(m.clearedFields, botmetrics.FieldTradeCount)
}

// SetClosedTradeCount sets the "closed_trade_count" field.
func (m *BotMetricsMutation) SetClosedTradeCount(i int) {
	m.closed_trade_count = &i
	m.addclosed_trade_count = nil
}

// ClosedTradeCount returns the value of the "closed_trade_count" field in the mutation.
func (m *BotMetricsMutation) ClosedTradeCount() (r int, exists bool) {
	v := m.closed_trade_count
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedTradeCount returns the old "closed_trade_count" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldClosedTradeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedTradeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedTradeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedTradeCount: %w", err)
	}
	return oldValue.ClosedTradeCount, nil
}

// AddClosedTradeCount adds i to the "closed_trade_count" field.
func (m *BotMetricsMutation) AddClosedTradeCount(i int) {
	if m.addclosed_trade_count != nil {
		*m.addclosed_trade_count += i
	} else {
		m.addclosed_trade_count = &i
	}
}

// AddedClosedTradeCount returns the value that was added to the "closed_trade_count" field in this mutation.
func (m *BotMetricsMutation) AddedClosedTradeCount() (r int, exists bool) {
	v := m.addclosed_trade_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearClosedTradeCount clears the value of the "closed_trade_count" field.
func (m *BotMetricsMutation) ClearClosedTradeCount() {
	m.closed_trade_count = nil
	m.addclosed_trade_count = nil
	m.clearedFields[botmetrics.FieldClosedTradeCount] = struct{}{}
}

// ClosedTradeCountCleared returns if the "closed_trade_count" field was cleared in this mutation.
func (m *BotMetricsMutation) ClosedTradeCountCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldClosedTradeCount]
	return ok
}

// ResetClosedTradeCount resets all changes to the "closed_trade_count" field.
func (m *BotMetricsMutation) ResetClosedTradeCount() {
	m.closed_trade_count = nil
	m.addclosed_trade_count = nil
	delete(m.clearedFields, botmetrics.FieldClosedTradeCount)
}

// SetOpenTradeCount sets the "open_trade_count" field.
func (m *BotMetricsMutation) SetOpenTradeCount(i int) {
	m.open_trade_count = &i
	m.addopen_trade_count = nil
}

// OpenTradeCount returns the value of the "open_trade_count" field in the mutation.
func (m *BotMetricsMutation) OpenTradeCount() (r int, exists bool) {
	v := m.open_trade_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenTradeCount returns the old "open_trade_count" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldOpenTradeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenTradeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenTradeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenTradeCount: %w", err)
	}
	return oldValue.OpenTradeCount, nil
}

// AddOpenTradeCount adds i to the "open_trade_count" field.
func (m *BotMetricsMutation) AddOpenTradeCount(i int) {
	if m.addopen_trade_count != nil {
		*m.addopen_trade_count += i
	} else {
		m.addopen_trade_count = &i
	}
}

// AddedOpenTradeCount returns the value that was added to the "open_trade_count" field in this mutation.
func (m *BotMetricsMutation) AddedOpenTradeCount() (r int, exists bool) {
	v := m.addopen_trade_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpenTradeCount clears the value of the "open_trade_count" field.
func (m *BotMetricsMutation) ClearOpenTradeCount() {
	m.open_trade_count = nil
	m.addopen_trade_count = nil
	m.clearedFields[botmetrics.FieldOpenTradeCount] = struct{}{}
}

// OpenTradeCountCleared returns if the "open_trade_count" field was cleared in this mutation.
func (m *BotMetricsMutation) OpenTradeCountCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldOpenTradeCount]
	return ok
}

// ResetOpenTradeCount resets all changes to the "open_trade_count" field.
func (m *BotMetricsMutation) ResetOpenTradeCount() {
	m.open_trade_count = nil
	m.addopen_trade_count = nil
	delete(m.clearedFields, botmetrics.FieldOpenTradeCount)
}

// SetWinningTrades sets the "winning_trades" field.
func (m *BotMetricsMutation) SetWinningTrades(i int) {
	m.winning_trades = &i
	m.addwinning_trades = nil
}

// WinningTrades returns the value of the "winning_trades" field in the mutation.
func (m *BotMetricsMutation) WinningTrades() (r int, exists bool) {
	v := m.winning_trades
	if v == nil {
		return
	}
	return *v, true
}

// OldWinningTrades returns the old "winning_trades" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldWinningTrades(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinningTrades is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinningTrades requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinningTrades: %w", err)
	}
	return oldValue.WinningTrades, nil
}

// AddWinningTrades adds i to the "winning_trades" field.
func (m *BotMetricsMutation) AddWinningTrades(i int) {
	if m.addwinning_trades != nil {
		*m.addwinning_trades += i
	} else {
		m.addwinning_trades = &i
	}
}

// AddedWinningTrades returns the value that was added to the "winning_trades" field in this mutation.
func (m *BotMetricsMutation) AddedWinningTrades() (r int, exists bool) {
	v := m.addwinning_trades
	if v == nil {
		return
	}
	return *v, true
}

// ClearWinningTrades clears the value of the "winning_trades" field.
func (m *BotMetricsMutation) ClearWinningTrades() {
	m.winning_trades = nil
	m.addwinning_trades = nil
	m.clearedFields[botmetrics.FieldWinningTrades] = struct{}{}
}

// WinningTradesCleared returns if the "winning_trades" field was cleared in this mutation.
func (m *BotMetricsMutation) WinningTradesCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldWinningTrades]
	return ok
}

// ResetWinningTrades resets all changes to the "winning_trades" field.
func (m *BotMetricsMutation) ResetWinningTrades() {
	m.winning_trades = nil
	m.addwinning_trades = nil
	delete(m.clearedFields, botmetrics.FieldWinningTrades)
}

// SetLosingTrades sets the "losing_trades" field.
func (m *BotMetricsMutation) SetLosingTrades(i int) {
	m.losing_trades = &i
	m.addlosing_trades = nil
}

// LosingTrades returns the value of the "losing_trades" field in the mutation.
func (m *BotMetricsMutation) LosingTrades() (r int, exists bool) {
	v := m.losing_trades
	if v == nil {
		return
	}
	return *v, true
}

// OldLosingTrades returns the old "losing_trades" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldLosingTrades(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLosingTrades is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLosingTrades requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLosingTrades: %w", err)
	}
	return oldValue.LosingTrades, nil
}

// AddLosingTrades adds i to the "losing_trades" field.
func (m *BotMetricsMutation) AddLosingTrades(i int) {
	if m.addlosing_trades != nil {
		*m.addlosing_trades += i
	} else {
		m.addlosing_trades = &i
	}
}

// AddedLosingTrades returns the value that was added to the "losing_trades" field in this mutation.
func (m *BotMetricsMutation) AddedLosingTrades() (r int, exists bool) {
	v := m.addlosing_trades
	if v == nil {
		return
	}
	return *v, true
}

// ClearLosingTrades clears the value of the "losing_trades" field.
func (m *BotMetricsMutation) ClearLosingTrades() {
	m.losing_trades = nil
	m.addlosing_trades = nil
	m.clearedFields[botmetrics.FieldLosingTrades] = struct{}{}
}

// LosingTradesCleared returns if the "losing_trades" field was cleared in this mutation.
func (m *BotMetricsMutation) LosingTradesCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldLosingTrades]
	return ok
}

// ResetLosingTrades resets all changes to the "losing_trades" field.
func (m *BotMetricsMutation) ResetLosingTrades() {
	m.losing_trades = nil
	m.addlosing_trades = nil
	delete(m.clearedFields, botmetrics.FieldLosingTrades)
}

// SetWinrate sets the "winrate" field.
func (m *BotMetricsMutation) SetWinrate(f float64) {
	m.winrate = &f
	m.addwinrate = nil
}

// Winrate returns the value of the "winrate" field in the mutation.
func (m *BotMetricsMutation) Winrate() (r float64, exists bool) {
	v := m.winrate
	if v == nil {
		return
	}
	return *v, true
}

// OldWinrate returns the old "winrate" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldWinrate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinrate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinrate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinrate: %w", err)
	}
	return oldValue.Winrate, nil
}

// AddWinrate adds f to the "winrate" field.
func (m *BotMetricsMutation) AddWinrate(f float64) {
	if m.addwinrate != nil {
		*m.addwinrate += f
	} else {
		m.addwinrate = &f
	}
}

// AddedWinrate returns the value that was added to the "winrate" field in this mutation.
func (m *BotMetricsMutation) AddedWinrate() (r float64, exists bool) {
	v := m.addwinrate
	if v == nil {
		return
	}
	return *v, true
}

// ClearWinrate clears the value of the "winrate" field.
func (m *BotMetricsMutation) ClearWinrate() {
	m.winrate = nil
	m.addwinrate = nil
	m.clearedFields[botmetrics.FieldWinrate] = struct{}{}
}

// WinrateCleared returns if the "winrate" field was cleared in this mutation.
func (m *BotMetricsMutation) WinrateCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldWinrate]
	return ok
}

// ResetWinrate resets all changes to the "winrate" field.
func (m *BotMetricsMutation) ResetWinrate() {
	m.winrate = nil
	m.addwinrate = nil
	delete(m.clearedFields, botmetrics.FieldWinrate)
}

// SetExpectancy sets the "expectancy" field.
func (m *BotMetricsMutation) SetExpectancy(f float64) {
	m.expectancy = &f
	m.addexpectancy = nil
}

// Expectancy returns the value of the "expectancy" field in the mutation.
func (m *BotMetricsMutation) Expectancy() (r float64, exists bool) {
	v := m.expectancy
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectancy returns the old "expectancy" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldExpectancy(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectancy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectancy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectancy: %w", err)
	}
	return oldValue.Expectancy, nil
}

// AddExpectancy adds f to the "expectancy" field.
func (m *BotMetricsMutation) AddExpectancy(f float64) {
	if m.addexpectancy != nil {
		*m.addexpectancy += f
	} else {
		m.addexpectancy = &f
	}
}

// AddedExpectancy returns the value that was added to the "expectancy" field in this mutation.
func (m *BotMetricsMutation) AddedExpectancy() (r float64, exists bool) {
	v := m.addexpectancy
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpectancy clears the value of the "expectancy" field.
func (m *BotMetricsMutation) ClearExpectancy() {
	m.expectancy = nil
	m.addexpectancy = nil
	m.clearedFields[botmetrics.FieldExpectancy] = struct{}{}
}

// ExpectancyCleared returns if the "expectancy" field was cleared in this mutation.
func (m *BotMetricsMutation) ExpectancyCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldExpectancy]
	return ok
}

// ResetExpectancy resets all changes to the "expectancy" field.
func (m *BotMetricsMutation) ResetExpectancy() {
	m.expectancy = nil
	m.addexpectancy = nil
	delete(m.clearedFields, botmetrics.FieldExpectancy)
}

// SetProfitFactor sets the "profit_factor" field.
func (m *BotMetricsMutation) SetProfitFactor(f float64) {
	m.profit_factor = &f
	m.addprofit_factor = nil
}

// ProfitFactor returns the value of the "profit_factor" field in the mutation.
func (m *BotMetricsMutation) ProfitFactor() (r float64, exists bool) {
	v := m.profit_factor
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitFactor returns the old "profit_factor" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldProfitFactor(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitFactor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitFactor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitFactor: %w", err)
	}
	return oldValue.ProfitFactor, nil
}

// AddProfitFactor adds f to the "profit_factor" field.
func (m *BotMetricsMutation) AddProfitFactor(f float64) {
	if m.addprofit_factor != nil {
		*m.addprofit_factor += f
	} else {
		m.addprofit_factor = &f
	}
}

// AddedProfitFactor returns the value that was added to the "profit_factor" field in this mutation.
func (m *BotMetricsMutation) AddedProfitFactor() (r float64, exists bool) {
	v := m.addprofit_factor
	if v == nil {
		return
	}
	return *v, true
}

// ClearProfitFactor clears the value of the "profit_factor" field.
func (m *BotMetricsMutation) ClearProfitFactor() {
	m.profit_factor = nil
	m.addprofit_factor = nil
	m.clearedFields[botmetrics.FieldProfitFactor] = struct{}{}
}

// ProfitFactorCleared returns if the "profit_factor" field was cleared in this mutation.
func (m *BotMetricsMutation) ProfitFactorCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldProfitFactor]
	return ok
}

// ResetProfitFactor resets all changes to the "profit_factor" field.
func (m *BotMetricsMutation) ResetProfitFactor() {
	m.profit_factor = nil
	m.addprofit_factor = nil
	delete(m.clearedFields, botmetrics.FieldProfitFactor)
}

// SetMaxDrawdown sets the "max_drawdown" field.
func (m *BotMetricsMutation) SetMaxDrawdown(f float64) {
	m.max_drawdown = &f
	m.addmax_drawdown = nil
}

// MaxDrawdown returns the value of the "max_drawdown" field in the mutation.
func (m *BotMetricsMutation) MaxDrawdown() (r float64, exists bool) {
	v := m.max_drawdown
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDrawdown returns the old "max_drawdown" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldMaxDrawdown(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxDrawdown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxDrawdown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDrawdown: %w", err)
	}
	return oldValue.MaxDrawdown, nil
}

// AddMaxDrawdown adds f to the "max_drawdown" field.
func (m *BotMetricsMutation) AddMaxDrawdown(f float64) {
	if m.addmax_drawdown != nil {
		*m.addmax_drawdown += f
	} else {
		m.addmax_drawdown = &f
	}
}

// AddedMaxDrawdown returns the value that was added to the "max_drawdown" field in this mutation.
func (m *BotMetricsMutation) AddedMaxDrawdown() (r float64, exists bool) {
	v := m.addmax_drawdown
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxDrawdown clears the value of the "max_drawdown" field.
func (m *BotMetricsMutation) ClearMaxDrawdown() {
	m.max_drawdown = nil
	m.addmax_drawdown = nil
	m.clearedFields[botmetrics.FieldMaxDrawdown] = struct{}{}
}

// MaxDrawdownCleared returns if the "max_drawdown" field was cleared in this mutation.
func (m *BotMetricsMutation) MaxDrawdownCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldMaxDrawdown]
	return ok
}

// ResetMaxDrawdown resets all changes to the "max_drawdown" field.
func (m *BotMetricsMutation) ResetMaxDrawdown() {
	m.max_drawdown = nil
	m.addmax_drawdown = nil
	delete(m.clearedFields, botmetrics.FieldMaxDrawdown)
}

// SetMaxDrawdownAbs sets the "max_drawdown_abs" field.
func (m *BotMetricsMutation) SetMaxDrawdownAbs(f float64) {
	m.max_drawdown_abs = &f
	m.addmax_drawdown_abs = nil
}

// MaxDrawdownAbs returns the value of the "max_drawdown_abs" field in the mutation.
func (m *BotMetricsMutation) MaxDrawdownAbs() (r float64, exists bool) {
	v := m.max_drawdown_abs
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDrawdownAbs returns the old "max_drawdown_abs" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldMaxDrawdownAbs(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxDrawdownAbs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxDrawdownAbs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDrawdownAbs: %w", err)
	}
	return oldValue.MaxDrawdownAbs, nil
}

// AddMaxDrawdownAbs adds f to the "max_drawdown_abs" field.
func (m *BotMetricsMutation) AddMaxDrawdownAbs(f float64) {
	if m.addmax_drawdown_abs != nil {
		*m.addmax_drawdown_abs += f
	} else {
		m.addmax_drawdown_abs = &f
	}
}

// AddedMaxDrawdownAbs returns the value that was added to the "max_drawdown_abs" field in this mutation.
func (m *BotMetricsMutation) AddedMaxDrawdownAbs() (r float64, exists bool) {
	v := m.addmax_drawdown_abs
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxDrawdownAbs clears the value of the "max_drawdown_abs" field.
func (m *BotMetricsMutation) ClearMaxDrawdownAbs() {
	m.max_drawdown_abs = nil
	m.addmax_drawdown_abs = nil
	m.clearedFields[botmetrics.FieldMaxDrawdownAbs] = struct{}{}
}

// MaxDrawdownAbsCleared returns if the "max_drawdown_abs" field was cleared in this mutation.
func (m *BotMetricsMutation) MaxDrawdownAbsCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldMaxDrawdownAbs]
	return ok
}

// ResetMaxDrawdownAbs resets all changes to the "max_drawdown_abs" field.
func (m *BotMetricsMutation) ResetMaxDrawdownAbs() {
	m.max_drawdown_abs = nil
	m.addmax_drawdown_abs = nil
	delete(m.clearedFields, botmetrics.FieldMaxDrawdownAbs)
}

// SetBestPair sets the "best_pair" field.
func (m *BotMetricsMutation) SetBestPair(s string) {
	m.best_pair = &s
}

// BestPair returns the value of the "best_pair" field in the mutation.
func (m *BotMetricsMutation) BestPair() (r string, exists bool) {
	v := m.best_pair
	if v == nil {
		return
	}
	return *v, true
}

// OldBestPair returns the old "best_pair" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldBestPair(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBestPair is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBestPair requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBestPair: %w", err)
	}
	return oldValue.BestPair, nil
}

// ClearBestPair clears the value of the "best_pair" field.
func (m *BotMetricsMutation) ClearBestPair() {
	m.best_pair = nil
	m.clearedFields[botmetrics.FieldBestPair] = struct{}{}
}

// BestPairCleared returns if the "best_pair" field was cleared in this mutation.
func (m *BotMetricsMutation) BestPairCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldBestPair]
	return ok
}

// ResetBestPair resets all changes to the "best_pair" field.
func (m *BotMetricsMutation) ResetBestPair() {
	m.best_pair = nil
	delete(m.clearedFields, botmetrics.FieldBestPair)
}

// SetBestRate sets the "best_rate" field.
func (m *BotMetricsMutation) SetBestRate(f float64) {
	m.best_rate = &f
	m.addbest_rate = nil
}

// BestRate returns the value of the "best_rate" field in the mutation.
func (m *BotMetricsMutation) BestRate() (r float64, exists bool) {
	v := m.best_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldBestRate returns the old "best_rate" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldBestRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBestRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBestRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBestRate: %w", err)
	}
	return oldValue.BestRate, nil
}

// AddBestRate adds f to the "best_rate" field.
func (m *BotMetricsMutation) AddBestRate(f float64) {
	if m.addbest_rate != nil {
		*m.addbest_rate += f
	} else {
		m.addbest_rate = &f
	}
}

// AddedBestRate returns the value that was added to the "best_rate" field in this mutation.
func (m *BotMetricsMutation) AddedBestRate() (r float64, exists bool) {
	v := m.addbest_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearBestRate clears the value of the "best_rate" field.
func (m *BotMetricsMutation) ClearBestRate() {
	m.best_rate = nil
	m.addbest_rate = nil
	m.clearedFields[botmetrics.FieldBestRate] = struct{}{}
}

// BestRateCleared returns if the "best_rate" field was cleared in this mutation.
func (m *BotMetricsMutation) BestRateCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldBestRate]
	return ok
}

// ResetBestRate resets all changes to the "best_rate" field.
func (m *BotMetricsMutation) ResetBestRate() {
	m.best_rate = nil
	m.addbest_rate = nil
	delete(m.clearedFields, botmetrics.FieldBestRate)
}

// SetFirstTradeTimestamp sets the "first_trade_timestamp" field.
func (m *BotMetricsMutation) SetFirstTradeTimestamp(t time.Time) {
	m.first_trade_timestamp = &t
}

// FirstTradeTimestamp returns the value of the "first_trade_timestamp" field in the mutation.
func (m *BotMetricsMutation) FirstTradeTimestamp() (r time.Time, exists bool) {
	v := m.first_trade_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstTradeTimestamp returns the old "first_trade_timestamp" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldFirstTradeTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstTradeTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstTradeTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstTradeTimestamp: %w", err)
	}
	return oldValue.FirstTradeTimestamp, nil
}

// ClearFirstTradeTimestamp clears the value of the "first_trade_timestamp" field.
func (m *BotMetricsMutation) ClearFirstTradeTimestamp() {
	m.first_trade_timestamp = nil
	m.clearedFields[botmetrics.FieldFirstTradeTimestamp] = struct{}{}
}

// FirstTradeTimestampCleared returns if the "first_trade_timestamp" field was cleared in this mutation.
func (m *BotMetricsMutation) FirstTradeTimestampCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldFirstTradeTimestamp]
	return ok
}

// ResetFirstTradeTimestamp resets all changes to the "first_trade_timestamp" field.
func (m *BotMetricsMutation) ResetFirstTradeTimestamp() {
	m.first_trade_timestamp = nil
	delete(m.clearedFields, botmetrics.FieldFirstTradeTimestamp)
}

// SetLatestTradeTimestamp sets the "latest_trade_timestamp" field.
func (m *BotMetricsMutation) SetLatestTradeTimestamp(t time.Time) {
	m.latest_trade_timestamp = &t
}

// LatestTradeTimestamp returns the value of the "latest_trade_timestamp" field in the mutation.
func (m *BotMetricsMutation) LatestTradeTimestamp() (r time.Time, exists bool) {
	v := m.latest_trade_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestTradeTimestamp returns the old "latest_trade_timestamp" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldLatestTradeTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestTradeTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestTradeTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestTradeTimestamp: %w", err)
	}
	return oldValue.LatestTradeTimestamp, nil
}

// ClearLatestTradeTimestamp clears the value of the "latest_trade_timestamp" field.
func (m *BotMetricsMutation) ClearLatestTradeTimestamp() {
	m.latest_trade_timestamp = nil
	m.clearedFields[botmetrics.FieldLatestTradeTimestamp] = struct{}{}
}

// LatestTradeTimestampCleared returns if the "latest_trade_timestamp" field was cleared in this mutation.
func (m *BotMetricsMutation) LatestTradeTimestampCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldLatestTradeTimestamp]
	return ok
}

// ResetLatestTradeTimestamp resets all changes to the "latest_trade_timestamp" field.
func (m *BotMetricsMutation) ResetLatestTradeTimestamp() {
	m.latest_trade_timestamp = nil
	delete(m.clearedFields, botmetrics.FieldLatestTradeTimestamp)
}

// SetFetchedAt sets the "fetched_at" field.
func (m *BotMetricsMutation) SetFetchedAt(t time.Time) {
	m.fetched_at = &t
}

// FetchedAt returns the value of the "fetched_at" field in the mutation.
func (m *BotMetricsMutation) FetchedAt() (r time.Time, exists bool) {
	v := m.fetched_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFetchedAt returns the old "fetched_at" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldFetchedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFetchedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFetchedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFetchedAt: %w", err)
	}
	return oldValue.FetchedAt, nil
}

// ResetFetchedAt resets all changes to the "fetched_at" field.
func (m *BotMetricsMutation) ResetFetchedAt() {
	m.fetched_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BotMetricsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BotMetricsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BotMetricsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastSyncedTradeID sets the "last_synced_trade_id" field.
func (m *BotMetricsMutation) SetLastSyncedTradeID(i int) {
	m.last_synced_trade_id = &i
	m.addlast_synced_trade_id = nil
}

// LastSyncedTradeID returns the value of the "last_synced_trade_id" field in the mutation.
func (m *BotMetricsMutation) LastSyncedTradeID() (r int, exists bool) {
	v := m.last_synced_trade_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncedTradeID returns the old "last_synced_trade_id" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldLastSyncedTradeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncedTradeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncedTradeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncedTradeID: %w", err)
	}
	return oldValue.LastSyncedTradeID, nil
}

// AddLastSyncedTradeID adds i to the "last_synced_trade_id" field.
func (m *BotMetricsMutation) AddLastSyncedTradeID(i int) {
	if m.addlast_synced_trade_id != nil {
		*m.addlast_synced_trade_id += i
	} else {
		m.addlast_synced_trade_id = &i
	}
}

// AddedLastSyncedTradeID returns the value that was added to the "last_synced_trade_id" field in this mutation.
func (m *BotMetricsMutation) AddedLastSyncedTradeID() (r int, exists bool) {
	v := m.addlast_synced_trade_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastSyncedTradeID resets all changes to the "last_synced_trade_id" field.
func (m *BotMetricsMutation) ResetLastSyncedTradeID() {
	m.last_synced_trade_id = nil
	m.addlast_synced_trade_id = nil
}

// SetLastKnownMaxTradeID sets the "last_known_max_trade_id" field.
func (m *BotMetricsMutation) SetLastKnownMaxTradeID(i int) {
	m.last_known_max_trade_id = &i
	m.addlast_known_max_trade_id = nil
}

// LastKnownMaxTradeID returns the value of the "last_known_max_trade_id" field in the mutation.
func (m *BotMetricsMutation) LastKnownMaxTradeID() (r int, exists bool) {
	v := m.last_known_max_trade_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastKnownMaxTradeID returns the old "last_known_max_trade_id" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldLastKnownMaxTradeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastKnownMaxTradeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastKnownMaxTradeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastKnownMaxTradeID: %w", err)
	}
	return oldValue.LastKnownMaxTradeID, nil
}

// AddLastKnownMaxTradeID adds i to the "last_known_max_trade_id" field.
func (m *BotMetricsMutation) AddLastKnownMaxTradeID(i int) {
	if m.addlast_known_max_trade_id != nil {
		*m.addlast_known_max_trade_id += i
	} else {
		m.addlast_known_max_trade_id = &i
	}
}

// AddedLastKnownMaxTradeID returns the value that was added to the "last_known_max_trade_id" field in this mutation.
func (m *BotMetricsMutation) AddedLastKnownMaxTradeID() (r int, exists bool) {
	v := m.addlast_known_max_trade_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastKnownMaxTradeID resets all changes to the "last_known_max_trade_id" field.
func (m *BotMetricsMutation) ResetLastKnownMaxTradeID() {
	m.last_known_max_trade_id = nil
	m.addlast_known_max_trade_id = nil
}

// SetLastTradeSyncAt sets the "last_trade_sync_at" field.
func (m *BotMetricsMutation) SetLastTradeSyncAt(t time.Time) {
	m.last_trade_sync_at = &t
}

// LastTradeSyncAt returns the value of the "last_trade_sync_at" field in the mutation.
func (m *BotMetricsMutation) LastTradeSyncAt() (r time.Time, exists bool) {
	v := m.last_trade_sync_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTradeSyncAt returns the old "last_trade_sync_at" field's value of the BotMetrics entity.
// If the BotMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotMetricsMutation) OldLastTradeSyncAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastTradeSyncAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastTradeSyncAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTradeSyncAt: %w", err)
	}
	return oldValue.LastTradeSyncAt, nil
}

// ClearLastTradeSyncAt clears the value of the "last_trade_sync_at" field.
func (m *BotMetricsMutation) ClearLastTradeSyncAt() {
	m.last_trade_sync_at = nil
	m.clearedFields[botmetrics.FieldLastTradeSyncAt] = struct{}{}
}

// LastTradeSyncAtCleared returns if the "last_trade_sync_at" field was cleared in this mutation.
func (m *BotMetricsMutation) LastTradeSyncAtCleared() bool {
	_, ok := m.clearedFields[botmetrics.FieldLastTradeSyncAt]
	return ok
}

// ResetLastTradeSyncAt resets all changes to the "last_trade_sync_at" field.
func (m *BotMetricsMutation) ResetLastTradeSyncAt() {
	m.last_trade_sync_at = nil
	delete(m.clearedFields, botmetrics.FieldLastTradeSyncAt)
}

// ClearBot clears the "bot" edge to the Bot entity.
func (m *BotMetricsMutation) ClearBot() {
	m.clearedbot = true
	m.clearedFields[botmetrics.FieldBotID] = struct{}{}
}

// BotCleared reports if the "bot" edge to the Bot entity was cleared.
func (m *BotMetricsMutation) BotCleared() bool {
	return m.clearedbot
}

// BotIDs returns the "bot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BotID instead. It exists only for internal usage by the builders.
func (m *BotMetricsMutation) BotIDs() (ids []uuid.UUID) {
	if id := m.bot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBot resets all changes to the "bot" edge.
func (m *BotMetricsMutation) ResetBot() {
	m.bot = nil
	m.clearedbot = false
}

// Where appends a list predicates to the BotMetricsMutation builder.
func (m *BotMetricsMutation) Where(ps ...predicate.BotMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BotMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BotMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BotMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BotMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BotMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BotMetrics).
func (m *BotMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BotMetricsMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.deleted_at != nil {
		fields = append(fields, botmetrics.FieldDeletedAt)
	}
	if m.bot != nil {
		fields = append(fields, botmetrics.FieldBotID)
	}
	if m.profit_closed_coin != nil {
		fields = append(fields, botmetrics.FieldProfitClosedCoin)
	}
	if m.profit_closed_percent != nil {
		fields = append(fields, botmetrics.FieldProfitClosedPercent)
	}
	if m.profit_all_coin != nil {
		fields = append(fields, botmetrics.FieldProfitAllCoin)
	}
	if m.profit_all_percent != nil {
		fields = append(fields, botmetrics.FieldProfitAllPercent)
	}
	if m.trade_count != nil {
		fields = append(fields, botmetrics.FieldTradeCount)
	}
	if m.closed_trade_count != nil {
		fields = append(fields, botmetrics.FieldClosedTradeCount)
	}
	if m.open_trade_count != nil {
		fields = append(fields, botmetrics.FieldOpenTradeCount)
	}
	if m.winning_trades != nil {
		fields = append(fields, botmetrics.FieldWinningTrades)
	}
	if m.losing_trades != nil {
		fields = append(fields, botmetrics.FieldLosingTrades)
	}
	if m.winrate != nil {
		fields = append(fields, botmetrics.FieldWinrate)
	}
	if m.expectancy != nil {
		fields = append(fields, botmetrics.FieldExpectancy)
	}
	if m.profit_factor != nil {
		fields = append(fields, botmetrics.FieldProfitFactor)
	}
	if m.max_drawdown != nil {
		fields = append(fields, botmetrics.FieldMaxDrawdown)
	}
	if m.max_drawdown_abs != nil {
		fields = append(fields, botmetrics.FieldMaxDrawdownAbs)
	}
	if m.best_pair != nil {
		fields = append(fields, botmetrics.FieldBestPair)
	}
	if m.best_rate != nil {
		fields = append(fields, botmetrics.FieldBestRate)
	}
	if m.first_trade_timestamp != nil {
		fields = append(fields, botmetrics.FieldFirstTradeTimestamp)
	}
	if m.latest_trade_timestamp != nil {
		fields = append(fields, botmetrics.FieldLatestTradeTimestamp)
	}
	if m.fetched_at != nil {
		fields = append(fields, botmetrics.FieldFetchedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, botmetrics.FieldUpdatedAt)
	}
	if m.last_synced_trade_id != nil {
		fields = append(fields, botmetrics.FieldLastSyncedTradeID)
	}
	if m.last_known_max_trade_id != nil {
		fields = append(fields, botmetrics.FieldLastKnownMaxTradeID)
	}
	if m.last_trade_sync_at != nil {
		fields = append(fields, botmetrics.FieldLastTradeSyncAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BotMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case botmetrics.FieldDeletedAt:
		return m.DeletedAt()
	case botmetrics.FieldBotID:
		return m.BotID()
	case botmetrics.FieldProfitClosedCoin:
		return m.ProfitClosedCoin()
	case botmetrics.FieldProfitClosedPercent:
		return m.ProfitClosedPercent()
	case botmetrics.FieldProfitAllCoin:
		return m.ProfitAllCoin()
	case botmetrics.FieldProfitAllPercent:
		return m.ProfitAllPercent()
	case botmetrics.FieldTradeCount:
		return m.TradeCount()
	case botmetrics.FieldClosedTradeCount:
		return m.ClosedTradeCount()
	case botmetrics.FieldOpenTradeCount:
		return m.OpenTradeCount()
	case botmetrics.FieldWinningTrades:
		return m.WinningTrades()
	case botmetrics.FieldLosingTrades:
		return m.LosingTrades()
	case botmetrics.FieldWinrate:
		return m.Winrate()
	case botmetrics.FieldExpectancy:
		return m.Expectancy()
	case botmetrics.FieldProfitFactor:
		return m.ProfitFactor()
	case botmetrics.FieldMaxDrawdown:
		return m.MaxDrawdown()
	case botmetrics.FieldMaxDrawdownAbs:
		return m.MaxDrawdownAbs()
	case botmetrics.FieldBestPair:
		return m.BestPair()
	case botmetrics.FieldBestRate:
		return m.BestRate()
	case botmetrics.FieldFirstTradeTimestamp:
		return m.FirstTradeTimestamp()
	case botmetrics.FieldLatestTradeTimestamp:
		return m.LatestTradeTimestamp()
	case botmetrics.FieldFetchedAt:
		return m.FetchedAt()
	case botmetrics.FieldUpdatedAt:
		return m.UpdatedAt()
	case botmetrics.FieldLastSyncedTradeID:
		return m.LastSyncedTradeID()
	case botmetrics.FieldLastKnownMaxTradeID:
		return m.LastKnownMaxTradeID()
	case botmetrics.FieldLastTradeSyncAt:
		return m.LastTradeSyncAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BotMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case botmetrics.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case botmetrics.FieldBotID:
		return m.OldBotID(ctx)
	case botmetrics.FieldProfitClosedCoin:
		return m.OldProfitClosedCoin(ctx)
	case botmetrics.FieldProfitClosedPercent:
		return m.OldProfitClosedPercent(ctx)
	case botmetrics.FieldProfitAllCoin:
		return m.OldProfitAllCoin(ctx)
	case botmetrics.FieldProfitAllPercent:
		return m.OldProfitAllPercent(ctx)
	case botmetrics.FieldTradeCount:
		return m.OldTradeCount(ctx)
	case botmetrics.FieldClosedTradeCount:
		return m.OldClosedTradeCount(ctx)
	case botmetrics.FieldOpenTradeCount:
		return m.OldOpenTradeCount(ctx)
	case botmetrics.FieldWinningTrades:
		return m.OldWinningTrades(ctx)
	case botmetrics.FieldLosingTrades:
		return m.OldLosingTrades(ctx)
	case botmetrics.FieldWinrate:
		return m.OldWinrate(ctx)
	case botmetrics.FieldExpectancy:
		return m.OldExpectancy(ctx)
	case botmetrics.FieldProfitFactor:
		return m.OldProfitFactor(ctx)
	case botmetrics.FieldMaxDrawdown:
		return m.OldMaxDrawdown(ctx)
	case botmetrics.FieldMaxDrawdownAbs:
		return m.OldMaxDrawdownAbs(ctx)
	case botmetrics.FieldBestPair:
		return m.OldBestPair(ctx)
	case botmetrics.FieldBestRate:
		return m.OldBestRate(ctx)
	case botmetrics.FieldFirstTradeTimestamp:
		return m.OldFirstTradeTimestamp(ctx)
	case botmetrics.FieldLatestTradeTimestamp:
		return m.OldLatestTradeTimestamp(ctx)
	case botmetrics.FieldFetchedAt:
		return m.OldFetchedAt(ctx)
	case botmetrics.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case botmetrics.FieldLastSyncedTradeID:
		return m.OldLastSyncedTradeID(ctx)
	case botmetrics.FieldLastKnownMaxTradeID:
		return m.OldLastKnownMaxTradeID(ctx)
	case botmetrics.FieldLastTradeSyncAt:
		return m.OldLastTradeSyncAt(ctx)
	}
	return nil, fmt.Errorf("unknown BotMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case botmetrics.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case botmetrics.FieldBotID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBotID(v)
		return nil
	case botmetrics.FieldProfitClosedCoin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitClosedCoin(v)
		return nil
	case botmetrics.FieldProfitClosedPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitClosedPercent(v)
		return nil
	case botmetrics.FieldProfitAllCoin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAllCoin(v)
		return nil
	case botmetrics.FieldProfitAllPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAllPercent(v)
		return nil
	case botmetrics.FieldTradeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeCount(v)
		return nil
	case botmetrics.FieldClosedTradeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedTradeCount(v)
		return nil
	case botmetrics.FieldOpenTradeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenTradeCount(v)
		return nil
	case botmetrics.FieldWinningTrades:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinningTrades(v)
		return nil
	case botmetrics.FieldLosingTrades:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLosingTrades(v)
		return nil
	case botmetrics.FieldWinrate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinrate(v)
		return nil
	case botmetrics.FieldExpectancy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectancy(v)
		return nil
	case botmetrics.FieldProfitFactor:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitFactor(v)
		return nil
	case botmetrics.FieldMaxDrawdown:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDrawdown(v)
		return nil
	case botmetrics.FieldMaxDrawdownAbs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDrawdownAbs(v)
		return nil
	case botmetrics.FieldBestPair:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBestPair(v)
		return nil
	case botmetrics.FieldBestRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBestRate(v)
		return nil
	case botmetrics.FieldFirstTradeTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstTradeTimestamp(v)
		return nil
	case botmetrics.FieldLatestTradeTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestTradeTimestamp(v)
		return nil
	case botmetrics.FieldFetchedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFetchedAt(v)
		return nil
	case botmetrics.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case botmetrics.FieldLastSyncedTradeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncedTradeID(v)
		return nil
	case botmetrics.FieldLastKnownMaxTradeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastKnownMaxTradeID(v)
		return nil
	case botmetrics.FieldLastTradeSyncAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTradeSyncAt(v)
		return nil
	}
	return fmt.Errorf("unknown BotMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BotMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addprofit_closed_coin != nil {
		fields = append(fields, botmetrics.FieldProfitClosedCoin)
	}
	if m.addprofit_closed_percent != nil {
		fields = append(fields, botmetrics.FieldProfitClosedPercent)
	}
	if m.addprofit_all_coin != nil {
		fields = append(fields, botmetrics.FieldProfitAllCoin)
	}
	if m.addprofit_all_percent != nil {
		fields = append(fields, botmetrics.FieldProfitAllPercent)
	}
	if m.addtrade_count != nil {
		fields = append(fields, botmetrics.FieldTradeCount)
	}
	if m.addclosed_trade_count != nil {
		fields = append(fields, botmetrics.FieldClosedTradeCount)
	}
	if m.addopen_trade_count != nil {
		fields = append(fields, botmetrics.FieldOpenTradeCount)
	}
	if m.addwinning_trades != nil {
		fields = append(fields, botmetrics.FieldWinningTrades)
	}
	if m.addlosing_trades != nil {
		fields = append(fields, botmetrics.FieldLosingTrades)
	}
	if m.addwinrate != nil {
		fields = append(fields, botmetrics.FieldWinrate)
	}
	if m.addexpectancy != nil {
		fields = append(fields, botmetrics.FieldExpectancy)
	}
	if m.addprofit_factor != nil {
		fields = append(fields, botmetrics.FieldProfitFactor)
	}
	if m.addmax_drawdown != nil {
		fields = append(fields, botmetrics.FieldMaxDrawdown)
	}
	if m.addmax_drawdown_abs != nil {
		fields = append(fields, botmetrics.FieldMaxDrawdownAbs)
	}
	if m.addbest_rate != nil {
		fields = append(fields, botmetrics.FieldBestRate)
	}
	if m.addlast_synced_trade_id != nil {
		fields = append(fields, botmetrics.FieldLastSyncedTradeID)
	}
	if m.addlast_known_max_trade_id != nil {
		fields = append(fields, botmetrics.FieldLastKnownMaxTradeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BotMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case botmetrics.FieldProfitClosedCoin:
		return m.AddedProfitClosedCoin()
	case botmetrics.FieldProfitClosedPercent:
		return m.AddedProfitClosedPercent()
	case botmetrics.FieldProfitAllCoin:
		return m.AddedProfitAllCoin()
	case botmetrics.FieldProfitAllPercent:
		return m.AddedProfitAllPercent()
	case botmetrics.FieldTradeCount:
		return m.AddedTradeCount()
	case botmetrics.FieldClosedTradeCount:
		return m.AddedClosedTradeCount()
	case botmetrics.FieldOpenTradeCount:
		return m.AddedOpenTradeCount()
	case botmetrics.FieldWinningTrades:
		return m.AddedWinningTrades()
	case botmetrics.FieldLosingTrades:
		return m.AddedLosingTrades()
	case botmetrics.FieldWinrate:
		return m.AddedWinrate()
	case botmetrics.FieldExpectancy:
		return m.AddedExpectancy()
	case botmetrics.FieldProfitFactor:
		return m.AddedProfitFactor()
	case botmetrics.FieldMaxDrawdown:
		return m.AddedMaxDrawdown()
	case botmetrics.FieldMaxDrawdownAbs:
		return m.AddedMaxDrawdownAbs()
	case botmetrics.FieldBestRate:
		return m.AddedBestRate()
	case botmetrics.FieldLastSyncedTradeID:
		return m.AddedLastSyncedTradeID()
	case botmetrics.FieldLastKnownMaxTradeID:
		return m.AddedLastKnownMaxTradeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case botmetrics.FieldProfitClosedCoin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitClosedCoin(v)
		return nil
	case botmetrics.FieldProfitClosedPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitClosedPercent(v)
		return nil
	case botmetrics.FieldProfitAllCoin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitAllCoin(v)
		return nil
	case botmetrics.FieldProfitAllPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitAllPercent(v)
		return nil
	case botmetrics.FieldTradeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTradeCount(v)
		return nil
	case botmetrics.FieldClosedTradeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClosedTradeCount(v)
		return nil
	case botmetrics.FieldOpenTradeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpenTradeCount(v)
		return nil
	case botmetrics.FieldWinningTrades:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWinningTrades(v)
		return nil
	case botmetrics.FieldLosingTrades:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLosingTrades(v)
		return nil
	case botmetrics.FieldWinrate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWinrate(v)
		return nil
	case botmetrics.FieldExpectancy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpectancy(v)
		return nil
	case botmetrics.FieldProfitFactor:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitFactor(v)
		return nil
	case botmetrics.FieldMaxDrawdown:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDrawdown(v)
		return nil
	case botmetrics.FieldMaxDrawdownAbs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDrawdownAbs(v)
		return nil
	case botmetrics.FieldBestRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBestRate(v)
		return nil
	case botmetrics.FieldLastSyncedTradeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastSyncedTradeID(v)
		return nil
	case botmetrics.FieldLastKnownMaxTradeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastKnownMaxTradeID(v)
		return nil
	}
	return fmt.Errorf("unknown BotMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BotMetricsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(botmetrics.FieldDeletedAt) {
		fields = append(fields, botmetrics.FieldDeletedAt)
	}
	if m.FieldCleared(botmetrics.FieldProfitClosedCoin) {
		fields = append(fields, botmetrics.FieldProfitClosedCoin)
	}
	if m.FieldCleared(botmetrics.FieldProfitClosedPercent) {
		fields = append(fields, botmetrics.FieldProfitClosedPercent)
	}
	if m.FieldCleared(botmetrics.FieldProfitAllCoin) {
		fields = append(fields, botmetrics.FieldProfitAllCoin)
	}
	if m.FieldCleared(botmetrics.FieldProfitAllPercent) {
		fields = append(fields, botmetrics.FieldProfitAllPercent)
	}
	if m.FieldCleared(botmetrics.FieldTradeCount) {
		fields = append(fields, botmetrics.FieldTradeCount)
	}
	if m.FieldCleared(botmetrics.FieldClosedTradeCount) {
		fields = append(fields, botmetrics.FieldClosedTradeCount)
	}
	if m.FieldCleared(botmetrics.FieldOpenTradeCount) {
		fields = append(fields, botmetrics.FieldOpenTradeCount)
	}
	if m.FieldCleared(botmetrics.FieldWinningTrades) {
		fields = append(fields, botmetrics.FieldWinningTrades)
	}
	if m.FieldCleared(botmetrics.FieldLosingTrades) {
		fields = append(fields, botmetrics.FieldLosingTrades)
	}
	if m.FieldCleared(botmetrics.FieldWinrate) {
		fields = append(fields, botmetrics.FieldWinrate)
	}
	if m.FieldCleared(botmetrics.FieldExpectancy) {
		fields = append(fields, botmetrics.FieldExpectancy)
	}
	if m.FieldCleared(botmetrics.FieldProfitFactor) {
		fields = append(fields, botmetrics.FieldProfitFactor)
	}
	if m.FieldCleared(botmetrics.FieldMaxDrawdown) {
		fields = append(fields, botmetrics.FieldMaxDrawdown)
	}
	if m.FieldCleared(botmetrics.FieldMaxDrawdownAbs) {
		fields = append(fields, botmetrics.FieldMaxDrawdownAbs)
	}
	if m.FieldCleared(botmetrics.FieldBestPair) {
		fields = append(fields, botmetrics.FieldBestPair)
	}
	if m.FieldCleared(botmetrics.FieldBestRate) {
		fields = append(fields, botmetrics.FieldBestRate)
	}
	if m.FieldCleared(botmetrics.FieldFirstTradeTimestamp) {
		fields = append(fields, botmetrics.FieldFirstTradeTimestamp)
	}
	if m.FieldCleared(botmetrics.FieldLatestTradeTimestamp) {
		fields = append(fields, botmetrics.FieldLatestTradeTimestamp)
	}
	if m.FieldCleared(botmetrics.FieldLastTradeSyncAt) {
		fields = append(fields, botmetrics.FieldLastTradeSyncAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BotMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BotMetricsMutation) ClearField(name string) error {
	switch name {
	case botmetrics.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case botmetrics.FieldProfitClosedCoin:
		m.ClearProfitClosedCoin()
		return nil
	case botmetrics.FieldProfitClosedPercent:
		m.ClearProfitClosedPercent()
		return nil
	case botmetrics.FieldProfitAllCoin:
		m.ClearProfitAllCoin()
		return nil
	case botmetrics.FieldProfitAllPercent:
		m.ClearProfitAllPercent()
		return nil
	case botmetrics.FieldTradeCount:
		m.ClearTradeCount()
		return nil
	case botmetrics.FieldClosedTradeCount:
		m.ClearClosedTradeCount()
		return nil
	case botmetrics.FieldOpenTradeCount:
		m.ClearOpenTradeCount()
		return nil
	case botmetrics.FieldWinningTrades:
		m.ClearWinningTrades()
		return nil
	case botmetrics.FieldLosingTrades:
		m.ClearLosingTrades()
		return nil
	case botmetrics.FieldWinrate:
		m.ClearWinrate()
		return nil
	case botmetrics.FieldExpectancy:
		m.ClearExpectancy()
		return nil
	case botmetrics.FieldProfitFactor:
		m.ClearProfitFactor()
		return nil
	case botmetrics.FieldMaxDrawdown:
		m.ClearMaxDrawdown()
		return nil
	case botmetrics.FieldMaxDrawdownAbs:
		m.ClearMaxDrawdownAbs()
		return nil
	case botmetrics.FieldBestPair:
		m.ClearBestPair()
		return nil
	case botmetrics.FieldBestRate:
		m.ClearBestRate()
		return nil
	case botmetrics.FieldFirstTradeTimestamp:
		m.ClearFirstTradeTimestamp()
		return nil
	case botmetrics.FieldLatestTradeTimestamp:
		m.ClearLatestTradeTimestamp()
		return nil
	case botmetrics.FieldLastTradeSyncAt:
		m.ClearLastTradeSyncAt()
		return nil
	}
	return fmt.Errorf("unknown BotMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BotMetricsMutation) ResetField(name string) error {
	switch name {
	case botmetrics.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case botmetrics.FieldBotID:
		m.ResetBotID()
		return nil
	case botmetrics.FieldProfitClosedCoin:
		m.ResetProfitClosedCoin()
		return nil
	case botmetrics.FieldProfitClosedPercent:
		m.ResetProfitClosedPercent()
		return nil
	case botmetrics.FieldProfitAllCoin:
		m.ResetProfitAllCoin()
		return nil
	case botmetrics.FieldProfitAllPercent:
		m.ResetProfitAllPercent()
		return nil
	case botmetrics.FieldTradeCount:
		m.ResetTradeCount()
		return nil
	case botmetrics.FieldClosedTradeCount:
		m.ResetClosedTradeCount()
		return nil
	case botmetrics.FieldOpenTradeCount:
		m.ResetOpenTradeCount()
		return nil
	case botmetrics.FieldWinningTrades:
		m.ResetWinningTrades()
		return nil
	case botmetrics.FieldLosingTrades:
		m.ResetLosingTrades()
		return nil
	case botmetrics.FieldWinrate:
		m.ResetWinrate()
		return nil
	case botmetrics.FieldExpectancy:
		m.ResetExpectancy()
		return nil
	case botmetrics.FieldProfitFactor:
		m.ResetProfitFactor()
		return nil
	case botmetrics.FieldMaxDrawdown:
		m.ResetMaxDrawdown()
		return nil
	case botmetrics.FieldMaxDrawdownAbs:
		m.ResetMaxDrawdownAbs()
		return nil
	case botmetrics.FieldBestPair:
		m.ResetBestPair()
		return nil
	case botmetrics.FieldBestRate:
		m.ResetBestRate()
		return nil
	case botmetrics.FieldFirstTradeTimestamp:
		m.ResetFirstTradeTimestamp()
		return nil
	case botmetrics.FieldLatestTradeTimestamp:
		m.ResetLatestTradeTimestamp()
		return nil
	case botmetrics.FieldFetchedAt:
		m.ResetFetchedAt()
		return nil
	case botmetrics.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case botmetrics.FieldLastSyncedTradeID:
		m.ResetLastSyncedTradeID()
		return nil
	case botmetrics.FieldLastKnownMaxTradeID:
		m.ResetLastKnownMaxTradeID()
		return nil
	case botmetrics.FieldLastTradeSyncAt:
		m.ResetLastTradeSyncAt()
		return nil
	}
	return fmt.Errorf("unknown BotMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BotMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bot != nil {
		edges = append(edges, botmetrics.EdgeBot)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BotMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case botmetrics.EdgeBot:
		if id := m.bot; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BotMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BotMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BotMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbot {
		edges = append(edges, botmetrics.EdgeBot)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BotMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case botmetrics.EdgeBot:
		return m.clearedbot
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BotMetricsMutation) ClearEdge(name string) error {
	switch name {
	case botmetrics.EdgeBot:
		m.ClearBot()
		return nil
	}
	return fmt.Errorf("unknown BotMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BotMetricsMutation) ResetEdge(name string) error {
	switch name {
	case botmetrics.EdgeBot:
		m.ResetBot()
		return nil
	}
	return fmt.Errorf("unknown BotMetrics edge %s", name)
}

// BotRunnerMutation represents an operation that mutates the BotRunner nodes in the graph.
type BotRunnerMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	public                      *bool
	deleted_at                  *time.Time
	name                        *string
	_type                       *enum.RunnerType
	_config                     *map[string]interface{}
	data_is_ready               *bool
	data_last_updated           *time.Time
	data_download_status        *enum.DataDownloadStatus
	data_download_started_at    *time.Time
	data_download_progress      *map[string]interface{}
	data_error_message          *string
	data_download_config        *map[string]interface{}
	s3_config                   *map[string]interface{}
	s3_data_key                 *string
	s3_data_uploaded_at         *time.Time
	data_available              *map[string]interface{}
	owner_id                    *string
	billing_enabled             *bool
	cpu_price_per_core_hour     *float64
	addcpu_price_per_core_hour  *float64
	memory_price_per_gb_hour    *float64
	addmemory_price_per_gb_hour *float64
	network_price_per_gb        *float64
	addnetwork_price_per_gb     *float64
	storage_price_per_gb        *float64
	addstorage_price_per_gb     *float64
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	bots                        map[uuid.UUID]struct{}
	removedbots                 map[uuid.UUID]struct{}
	clearedbots                 bool
	backtests                   map[uuid.UUID]struct{}
	removedbacktests            map[uuid.UUID]struct{}
	clearedbacktests            bool
	usage_samples               map[uuid.UUID]struct{}
	removedusage_samples        map[uuid.UUID]struct{}
	clearedusage_samples        bool
	usage_aggregations          map[uuid.UUID]struct{}
	removedusage_aggregations   map[uuid.UUID]struct{}
	clearedusage_aggregations   bool
	done                        bool
	oldValue                    func(context.Context) (*BotRunner, error)
	predicates                  []predicate.BotRunner
}

var _ ent.Mutation = (*BotRunnerMutation)(nil)

// botrunnerOption allows management of the mutation configuration using functional options.
type botrunnerOption func(*BotRunnerMutation)

// newBotRunnerMutation creates new mutation for the BotRunner entity.
func newBotRunnerMutation(c config, op Op, opts ...botrunnerOption) *BotRunnerMutation {
	m := &BotRunnerMutation{
		config:        c,
		op:            op,
		typ:           TypeBotRunner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBotRunnerID sets the ID field of the mutation.
func withBotRunnerID(id uuid.UUID) botrunnerOption {
	return func(m *BotRunnerMutation) {
		var (
			err   error
			once  sync.Once
			value *BotRunner
		)
		m.oldValue = func(ctx context.Context) (*BotRunner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BotRunner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBotRunner sets the old BotRunner of the mutation.
func withBotRunner(node *BotRunner) botrunnerOption {
	return func(m *BotRunnerMutation) {
		m.oldValue = func(context.Context) (*BotRunner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BotRunnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BotRunnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BotRunner entities.
func (m *BotRunnerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BotRunnerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BotRunnerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BotRunner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublic sets the "public" field.
func (m *BotRunnerMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *BotRunnerMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *BotRunnerMutation) ResetPublic() {
	m.public = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BotRunnerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BotRunnerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BotRunnerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[botrunner.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BotRunnerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BotRunnerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, botrunner.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BotRunnerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BotRunnerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BotRunnerMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *BotRunnerMutation) SetType(et enum.RunnerType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *BotRunnerMutation) GetType() (r enum.RunnerType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldType(ctx context.Context) (v enum.RunnerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BotRunnerMutation) ResetType() {
	m._type = nil
}

// SetConfig sets the "config" field.
func (m *BotRunnerMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *BotRunnerMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *BotRunnerMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[botrunner.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *BotRunnerMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *BotRunnerMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, botrunner.FieldConfig)
}

// SetDataIsReady sets the "data_is_ready" field.
func (m *BotRunnerMutation) SetDataIsReady(b bool) {
	m.data_is_ready = &b
}

// DataIsReady returns the value of the "data_is_ready" field in the mutation.
func (m *BotRunnerMutation) DataIsReady() (r bool, exists bool) {
	v := m.data_is_ready
	if v == nil {
		return
	}
	return *v, true
}

// OldDataIsReady returns the old "data_is_ready" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldDataIsReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataIsReady is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataIsReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataIsReady: %w", err)
	}
	return oldValue.DataIsReady, nil
}

// ResetDataIsReady resets all changes to the "data_is_ready" field.
func (m *BotRunnerMutation) ResetDataIsReady() {
	m.data_is_ready = nil
}

// SetDataLastUpdated sets the "data_last_updated" field.
func (m *BotRunnerMutation) SetDataLastUpdated(t time.Time) {
	m.data_last_updated = &t
}

// DataLastUpdated returns the value of the "data_last_updated" field in the mutation.
func (m *BotRunnerMutation) DataLastUpdated() (r time.Time, exists bool) {
	v := m.data_last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldDataLastUpdated returns the old "data_last_updated" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldDataLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataLastUpdated: %w", err)
	}
	return oldValue.DataLastUpdated, nil
}

// ClearDataLastUpdated clears the value of the "data_last_updated" field.
func (m *BotRunnerMutation) ClearDataLastUpdated() {
	m.data_last_updated = nil
	m.clearedFields[botrunner.FieldDataLastUpdated] = struct{}{}
}

// DataLastUpdatedCleared returns if the "data_last_updated" field was cleared in this mutation.
func (m *BotRunnerMutation) DataLastUpdatedCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldDataLastUpdated]
	return ok
}

// ResetDataLastUpdated resets all changes to the "data_last_updated" field.
func (m *BotRunnerMutation) ResetDataLastUpdated() {
	m.data_last_updated = nil
	delete(m.clearedFields, botrunner.FieldDataLastUpdated)
}

// SetDataDownloadStatus sets the "data_download_status" field.
func (m *BotRunnerMutation) SetDataDownloadStatus(eds enum.DataDownloadStatus) {
	m.data_download_status = &eds
}

// DataDownloadStatus returns the value of the "data_download_status" field in the mutation.
func (m *BotRunnerMutation) DataDownloadStatus() (r enum.DataDownloadStatus, exists bool) {
	v := m.data_download_status
	if v == nil {
		return
	}
	return *v, true
}

// OldDataDownloadStatus returns the old "data_download_status" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldDataDownloadStatus(ctx context.Context) (v enum.DataDownloadStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataDownloadStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataDownloadStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataDownloadStatus: %w", err)
	}
	return oldValue.DataDownloadStatus, nil
}

// ResetDataDownloadStatus resets all changes to the "data_download_status" field.
func (m *BotRunnerMutation) ResetDataDownloadStatus() {
	m.data_download_status = nil
}

// SetDataDownloadStartedAt sets the "data_download_started_at" field.
func (m *BotRunnerMutation) SetDataDownloadStartedAt(t time.Time) {
	m.data_download_started_at = &t
}

// DataDownloadStartedAt returns the value of the "data_download_started_at" field in the mutation.
func (m *BotRunnerMutation) DataDownloadStartedAt() (r time.Time, exists bool) {
	v := m.data_download_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDataDownloadStartedAt returns the old "data_download_started_at" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldDataDownloadStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataDownloadStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataDownloadStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataDownloadStartedAt: %w", err)
	}
	return oldValue.DataDownloadStartedAt, nil
}

// ClearDataDownloadStartedAt clears the value of the "data_download_started_at" field.
func (m *BotRunnerMutation) ClearDataDownloadStartedAt() {
	m.data_download_started_at = nil
	m.clearedFields[botrunner.FieldDataDownloadStartedAt] = struct{}{}
}

// DataDownloadStartedAtCleared returns if the "data_download_started_at" field was cleared in this mutation.
func (m *BotRunnerMutation) DataDownloadStartedAtCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldDataDownloadStartedAt]
	return ok
}

// ResetDataDownloadStartedAt resets all changes to the "data_download_started_at" field.
func (m *BotRunnerMutation) ResetDataDownloadStartedAt() {
	m.data_download_started_at = nil
	delete(m.clearedFields, botrunner.FieldDataDownloadStartedAt)
}

// SetDataDownloadProgress sets the "data_download_progress" field.
func (m *BotRunnerMutation) SetDataDownloadProgress(value map[string]interface{}) {
	m.data_download_progress = &value
}

// DataDownloadProgress returns the value of the "data_download_progress" field in the mutation.
func (m *BotRunnerMutation) DataDownloadProgress() (r map[string]interface{}, exists bool) {
	v := m.data_download_progress
	if v == nil {
		return
	}
	return *v, true
}

// OldDataDownloadProgress returns the old "data_download_progress" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldDataDownloadProgress(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataDownloadProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataDownloadProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataDownloadProgress: %w", err)
	}
	return oldValue.DataDownloadProgress, nil
}

// ClearDataDownloadProgress clears the value of the "data_download_progress" field.
func (m *BotRunnerMutation) ClearDataDownloadProgress() {
	m.data_download_progress = nil
	m.clearedFields[botrunner.FieldDataDownloadProgress] = struct{}{}
}

// DataDownloadProgressCleared returns if the "data_download_progress" field was cleared in this mutation.
func (m *BotRunnerMutation) DataDownloadProgressCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldDataDownloadProgress]
	return ok
}

// ResetDataDownloadProgress resets all changes to the "data_download_progress" field.
func (m *BotRunnerMutation) ResetDataDownloadProgress() {
	m.data_download_progress = nil
	delete(m.clearedFields, botrunner.FieldDataDownloadProgress)
}

// SetDataErrorMessage sets the "data_error_message" field.
func (m *BotRunnerMutation) SetDataErrorMessage(s string) {
	m.data_error_message = &s
}

// DataErrorMessage returns the value of the "data_error_message" field in the mutation.
func (m *BotRunnerMutation) DataErrorMessage() (r string, exists bool) {
	v := m.data_error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldDataErrorMessage returns the old "data_error_message" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldDataErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataErrorMessage: %w", err)
	}
	return oldValue.DataErrorMessage, nil
}

// ClearDataErrorMessage clears the value of the "data_error_message" field.
func (m *BotRunnerMutation) ClearDataErrorMessage() {
	m.data_error_message = nil
	m.clearedFields[botrunner.FieldDataErrorMessage] = struct{}{}
}

// DataErrorMessageCleared returns if the "data_error_message" field was cleared in this mutation.
func (m *BotRunnerMutation) DataErrorMessageCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldDataErrorMessage]
	return ok
}

// ResetDataErrorMessage resets all changes to the "data_error_message" field.
func (m *BotRunnerMutation) ResetDataErrorMessage() {
	m.data_error_message = nil
	delete(m.clearedFields, botrunner.FieldDataErrorMessage)
}

// SetDataDownloadConfig sets the "data_download_config" field.
func (m *BotRunnerMutation) SetDataDownloadConfig(value map[string]interface{}) {
	m.data_download_config = &value
}

// DataDownloadConfig returns the value of the "data_download_config" field in the mutation.
func (m *BotRunnerMutation) DataDownloadConfig() (r map[string]interface{}, exists bool) {
	v := m.data_download_config
	if v == nil {
		return
	}
	return *v, true
}

// OldDataDownloadConfig returns the old "data_download_config" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldDataDownloadConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataDownloadConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataDownloadConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataDownloadConfig: %w", err)
	}
	return oldValue.DataDownloadConfig, nil
}

// ClearDataDownloadConfig clears the value of the "data_download_config" field.
func (m *BotRunnerMutation) ClearDataDownloadConfig() {
	m.data_download_config = nil
	m.clearedFields[botrunner.FieldDataDownloadConfig] = struct{}{}
}

// DataDownloadConfigCleared returns if the "data_download_config" field was cleared in this mutation.
func (m *BotRunnerMutation) DataDownloadConfigCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldDataDownloadConfig]
	return ok
}

// ResetDataDownloadConfig resets all changes to the "data_download_config" field.
func (m *BotRunnerMutation) ResetDataDownloadConfig() {
	m.data_download_config = nil
	delete(m.clearedFields, botrunner.FieldDataDownloadConfig)
}

// SetS3Config sets the "s3_config" field.
func (m *BotRunnerMutation) SetS3Config(value map[string]interface{}) {
	m.s3_config = &value
}

// S3Config returns the value of the "s3_config" field in the mutation.
func (m *BotRunnerMutation) S3Config() (r map[string]interface{}, exists bool) {
	v := m.s3_config
	if v == nil {
		return
	}
	return *v, true
}

// OldS3Config returns the old "s3_config" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldS3Config(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3Config is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3Config requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3Config: %w", err)
	}
	return oldValue.S3Config, nil
}

// ClearS3Config clears the value of the "s3_config" field.
func (m *BotRunnerMutation) ClearS3Config() {
	m.s3_config = nil
	m.clearedFields[botrunner.FieldS3Config] = struct{}{}
}

// S3ConfigCleared returns if the "s3_config" field was cleared in this mutation.
func (m *BotRunnerMutation) S3ConfigCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldS3Config]
	return ok
}

// ResetS3Config resets all changes to the "s3_config" field.
func (m *BotRunnerMutation) ResetS3Config() {
	m.s3_config = nil
	delete(m.clearedFields, botrunner.FieldS3Config)
}

// SetS3DataKey sets the "s3_data_key" field.
func (m *BotRunnerMutation) SetS3DataKey(s string) {
	m.s3_data_key = &s
}

// S3DataKey returns the value of the "s3_data_key" field in the mutation.
func (m *BotRunnerMutation) S3DataKey() (r string, exists bool) {
	v := m.s3_data_key
	if v == nil {
		return
	}
	return *v, true
}

// OldS3DataKey returns the old "s3_data_key" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldS3DataKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3DataKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3DataKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3DataKey: %w", err)
	}
	return oldValue.S3DataKey, nil
}

// ClearS3DataKey clears the value of the "s3_data_key" field.
func (m *BotRunnerMutation) ClearS3DataKey() {
	m.s3_data_key = nil
	m.clearedFields[botrunner.FieldS3DataKey] = struct{}{}
}

// S3DataKeyCleared returns if the "s3_data_key" field was cleared in this mutation.
func (m *BotRunnerMutation) S3DataKeyCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldS3DataKey]
	return ok
}

// ResetS3DataKey resets all changes to the "s3_data_key" field.
func (m *BotRunnerMutation) ResetS3DataKey() {
	m.s3_data_key = nil
	delete(m.clearedFields, botrunner.FieldS3DataKey)
}

// SetS3DataUploadedAt sets the "s3_data_uploaded_at" field.
func (m *BotRunnerMutation) SetS3DataUploadedAt(t time.Time) {
	m.s3_data_uploaded_at = &t
}

// S3DataUploadedAt returns the value of the "s3_data_uploaded_at" field in the mutation.
func (m *BotRunnerMutation) S3DataUploadedAt() (r time.Time, exists bool) {
	v := m.s3_data_uploaded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldS3DataUploadedAt returns the old "s3_data_uploaded_at" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldS3DataUploadedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3DataUploadedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3DataUploadedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3DataUploadedAt: %w", err)
	}
	return oldValue.S3DataUploadedAt, nil
}

// ClearS3DataUploadedAt clears the value of the "s3_data_uploaded_at" field.
func (m *BotRunnerMutation) ClearS3DataUploadedAt() {
	m.s3_data_uploaded_at = nil
	m.clearedFields[botrunner.FieldS3DataUploadedAt] = struct{}{}
}

// S3DataUploadedAtCleared returns if the "s3_data_uploaded_at" field was cleared in this mutation.
func (m *BotRunnerMutation) S3DataUploadedAtCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldS3DataUploadedAt]
	return ok
}

// ResetS3DataUploadedAt resets all changes to the "s3_data_uploaded_at" field.
func (m *BotRunnerMutation) ResetS3DataUploadedAt() {
	m.s3_data_uploaded_at = nil
	delete(m.clearedFields, botrunner.FieldS3DataUploadedAt)
}

// SetDataAvailable sets the "data_available" field.
func (m *BotRunnerMutation) SetDataAvailable(value map[string]interface{}) {
	m.data_available = &value
}

// DataAvailable returns the value of the "data_available" field in the mutation.
func (m *BotRunnerMutation) DataAvailable() (r map[string]interface{}, exists bool) {
	v := m.data_available
	if v == nil {
		return
	}
	return *v, true
}

// OldDataAvailable returns the old "data_available" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldDataAvailable(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataAvailable: %w", err)
	}
	return oldValue.DataAvailable, nil
}

// ClearDataAvailable clears the value of the "data_available" field.
func (m *BotRunnerMutation) ClearDataAvailable() {
	m.data_available = nil
	m.clearedFields[botrunner.FieldDataAvailable] = struct{}{}
}

// DataAvailableCleared returns if the "data_available" field was cleared in this mutation.
func (m *BotRunnerMutation) DataAvailableCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldDataAvailable]
	return ok
}

// ResetDataAvailable resets all changes to the "data_available" field.
func (m *BotRunnerMutation) ResetDataAvailable() {
	m.data_available = nil
	delete(m.clearedFields, botrunner.FieldDataAvailable)
}

// SetOwnerID sets the "owner_id" field.
func (m *BotRunnerMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *BotRunnerMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *BotRunnerMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetBillingEnabled sets the "billing_enabled" field.
func (m *BotRunnerMutation) SetBillingEnabled(b bool) {
	m.billing_enabled = &b
}

// BillingEnabled returns the value of the "billing_enabled" field in the mutation.
func (m *BotRunnerMutation) BillingEnabled() (r bool, exists bool) {
	v := m.billing_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingEnabled returns the old "billing_enabled" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldBillingEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingEnabled: %w", err)
	}
	return oldValue.BillingEnabled, nil
}

// ResetBillingEnabled resets all changes to the "billing_enabled" field.
func (m *BotRunnerMutation) ResetBillingEnabled() {
	m.billing_enabled = nil
}

// SetCPUPricePerCoreHour sets the "cpu_price_per_core_hour" field.
func (m *BotRunnerMutation) SetCPUPricePerCoreHour(f float64) {
	m.cpu_price_per_core_hour = &f
	m.addcpu_price_per_core_hour = nil
}

// CPUPricePerCoreHour returns the value of the "cpu_price_per_core_hour" field in the mutation.
func (m *BotRunnerMutation) CPUPricePerCoreHour() (r float64, exists bool) {
	v := m.cpu_price_per_core_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUPricePerCoreHour returns the old "cpu_price_per_core_hour" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldCPUPricePerCoreHour(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUPricePerCoreHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUPricePerCoreHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUPricePerCoreHour: %w", err)
	}
	return oldValue.CPUPricePerCoreHour, nil
}

// AddCPUPricePerCoreHour adds f to the "cpu_price_per_core_hour" field.
func (m *BotRunnerMutation) AddCPUPricePerCoreHour(f float64) {
	if m.addcpu_price_per_core_hour != nil {
		*m.addcpu_price_per_core_hour += f
	} else {
		m.addcpu_price_per_core_hour = &f
	}
}

// AddedCPUPricePerCoreHour returns the value that was added to the "cpu_price_per_core_hour" field in this mutation.
func (m *BotRunnerMutation) AddedCPUPricePerCoreHour() (r float64, exists bool) {
	v := m.addcpu_price_per_core_hour
	if v == nil {
		return
	}
	return *v, true
}

// ClearCPUPricePerCoreHour clears the value of the "cpu_price_per_core_hour" field.
func (m *BotRunnerMutation) ClearCPUPricePerCoreHour() {
	m.cpu_price_per_core_hour = nil
	m.addcpu_price_per_core_hour = nil
	m.clearedFields[botrunner.FieldCPUPricePerCoreHour] = struct{}{}
}

// CPUPricePerCoreHourCleared returns if the "cpu_price_per_core_hour" field was cleared in this mutation.
func (m *BotRunnerMutation) CPUPricePerCoreHourCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldCPUPricePerCoreHour]
	return ok
}

// ResetCPUPricePerCoreHour resets all changes to the "cpu_price_per_core_hour" field.
func (m *BotRunnerMutation) ResetCPUPricePerCoreHour() {
	m.cpu_price_per_core_hour = nil
	m.addcpu_price_per_core_hour = nil
	delete(m.clearedFields, botrunner.FieldCPUPricePerCoreHour)
}

// SetMemoryPricePerGBHour sets the "memory_price_per_gb_hour" field.
func (m *BotRunnerMutation) SetMemoryPricePerGBHour(f float64) {
	m.memory_price_per_gb_hour = &f
	m.addmemory_price_per_gb_hour = nil
}

// MemoryPricePerGBHour returns the value of the "memory_price_per_gb_hour" field in the mutation.
func (m *BotRunnerMutation) MemoryPricePerGBHour() (r float64, exists bool) {
	v := m.memory_price_per_gb_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldMemoryPricePerGBHour returns the old "memory_price_per_gb_hour" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldMemoryPricePerGBHour(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemoryPricePerGBHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemoryPricePerGBHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemoryPricePerGBHour: %w", err)
	}
	return oldValue.MemoryPricePerGBHour, nil
}

// AddMemoryPricePerGBHour adds f to the "memory_price_per_gb_hour" field.
func (m *BotRunnerMutation) AddMemoryPricePerGBHour(f float64) {
	if m.addmemory_price_per_gb_hour != nil {
		*m.addmemory_price_per_gb_hour += f
	} else {
		m.addmemory_price_per_gb_hour = &f
	}
}

// AddedMemoryPricePerGBHour returns the value that was added to the "memory_price_per_gb_hour" field in this mutation.
func (m *BotRunnerMutation) AddedMemoryPricePerGBHour() (r float64, exists bool) {
	v := m.addmemory_price_per_gb_hour
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemoryPricePerGBHour clears the value of the "memory_price_per_gb_hour" field.
func (m *BotRunnerMutation) ClearMemoryPricePerGBHour() {
	m.memory_price_per_gb_hour = nil
	m.addmemory_price_per_gb_hour = nil
	m.clearedFields[botrunner.FieldMemoryPricePerGBHour] = struct{}{}
}

// MemoryPricePerGBHourCleared returns if the "memory_price_per_gb_hour" field was cleared in this mutation.
func (m *BotRunnerMutation) MemoryPricePerGBHourCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldMemoryPricePerGBHour]
	return ok
}

// ResetMemoryPricePerGBHour resets all changes to the "memory_price_per_gb_hour" field.
func (m *BotRunnerMutation) ResetMemoryPricePerGBHour() {
	m.memory_price_per_gb_hour = nil
	m.addmemory_price_per_gb_hour = nil
	delete(m.clearedFields, botrunner.FieldMemoryPricePerGBHour)
}

// SetNetworkPricePerGB sets the "network_price_per_gb" field.
func (m *BotRunnerMutation) SetNetworkPricePerGB(f float64) {
	m.network_price_per_gb = &f
	m.addnetwork_price_per_gb = nil
}

// NetworkPricePerGB returns the value of the "network_price_per_gb" field in the mutation.
func (m *BotRunnerMutation) NetworkPricePerGB() (r float64, exists bool) {
	v := m.network_price_per_gb
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkPricePerGB returns the old "network_price_per_gb" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldNetworkPricePerGB(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetworkPricePerGB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetworkPricePerGB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkPricePerGB: %w", err)
	}
	return oldValue.NetworkPricePerGB, nil
}

// AddNetworkPricePerGB adds f to the "network_price_per_gb" field.
func (m *BotRunnerMutation) AddNetworkPricePerGB(f float64) {
	if m.addnetwork_price_per_gb != nil {
		*m.addnetwork_price_per_gb += f
	} else {
		m.addnetwork_price_per_gb = &f
	}
}

// AddedNetworkPricePerGB returns the value that was added to the "network_price_per_gb" field in this mutation.
func (m *BotRunnerMutation) AddedNetworkPricePerGB() (r float64, exists bool) {
	v := m.addnetwork_price_per_gb
	if v == nil {
		return
	}
	return *v, true
}

// ClearNetworkPricePerGB clears the value of the "network_price_per_gb" field.
func (m *BotRunnerMutation) ClearNetworkPricePerGB() {
	m.network_price_per_gb = nil
	m.addnetwork_price_per_gb = nil
	m.clearedFields[botrunner.FieldNetworkPricePerGB] = struct{}{}
}

// NetworkPricePerGBCleared returns if the "network_price_per_gb" field was cleared in this mutation.
func (m *BotRunnerMutation) NetworkPricePerGBCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldNetworkPricePerGB]
	return ok
}

// ResetNetworkPricePerGB resets all changes to the "network_price_per_gb" field.
func (m *BotRunnerMutation) ResetNetworkPricePerGB() {
	m.network_price_per_gb = nil
	m.addnetwork_price_per_gb = nil
	delete(m.clearedFields, botrunner.FieldNetworkPricePerGB)
}

// SetStoragePricePerGB sets the "storage_price_per_gb" field.
func (m *BotRunnerMutation) SetStoragePricePerGB(f float64) {
	m.storage_price_per_gb = &f
	m.addstorage_price_per_gb = nil
}

// StoragePricePerGB returns the value of the "storage_price_per_gb" field in the mutation.
func (m *BotRunnerMutation) StoragePricePerGB() (r float64, exists bool) {
	v := m.storage_price_per_gb
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePricePerGB returns the old "storage_price_per_gb" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldStoragePricePerGB(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePricePerGB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePricePerGB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePricePerGB: %w", err)
	}
	return oldValue.StoragePricePerGB, nil
}

// AddStoragePricePerGB adds f to the "storage_price_per_gb" field.
func (m *BotRunnerMutation) AddStoragePricePerGB(f float64) {
	if m.addstorage_price_per_gb != nil {
		*m.addstorage_price_per_gb += f
	} else {
		m.addstorage_price_per_gb = &f
	}
}

// AddedStoragePricePerGB returns the value that was added to the "storage_price_per_gb" field in this mutation.
func (m *BotRunnerMutation) AddedStoragePricePerGB() (r float64, exists bool) {
	v := m.addstorage_price_per_gb
	if v == nil {
		return
	}
	return *v, true
}

// ClearStoragePricePerGB clears the value of the "storage_price_per_gb" field.
func (m *BotRunnerMutation) ClearStoragePricePerGB() {
	m.storage_price_per_gb = nil
	m.addstorage_price_per_gb = nil
	m.clearedFields[botrunner.FieldStoragePricePerGB] = struct{}{}
}

// StoragePricePerGBCleared returns if the "storage_price_per_gb" field was cleared in this mutation.
func (m *BotRunnerMutation) StoragePricePerGBCleared() bool {
	_, ok := m.clearedFields[botrunner.FieldStoragePricePerGB]
	return ok
}

// ResetStoragePricePerGB resets all changes to the "storage_price_per_gb" field.
func (m *BotRunnerMutation) ResetStoragePricePerGB() {
	m.storage_price_per_gb = nil
	m.addstorage_price_per_gb = nil
	delete(m.clearedFields, botrunner.FieldStoragePricePerGB)
}

// SetCreatedAt sets the "created_at" field.
func (m *BotRunnerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BotRunnerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BotRunnerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BotRunnerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BotRunnerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BotRunner entity.
// If the BotRunner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BotRunnerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BotRunnerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBotIDs adds the "bots" edge to the Bot entity by ids.
func (m *BotRunnerMutation) AddBotIDs(ids ...uuid.UUID) {
	if m.bots == nil {
		m.bots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bots[ids[i]] = struct{}{}
	}
}

// ClearBots clears the "bots" edge to the Bot entity.
func (m *BotRunnerMutation) ClearBots() {
	m.clearedbots = true
}

// BotsCleared reports if the "bots" edge to the Bot entity was cleared.
func (m *BotRunnerMutation) BotsCleared() bool {
	return m.clearedbots
}

// RemoveBotIDs removes the "bots" edge to the Bot entity by IDs.
func (m *BotRunnerMutation) RemoveBotIDs(ids ...uuid.UUID) {
	if m.removedbots == nil {
		m.removedbots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bots, ids[i])
		m.removedbots[ids[i]] = struct{}{}
	}
}

// RemovedBots returns the removed IDs of the "bots" edge to the Bot entity.
func (m *BotRunnerMutation) RemovedBotsIDs() (ids []uuid.UUID) {
	for id := range m.removedbots {
		ids = append(ids, id)
	}
	return
}

// BotsIDs returns the "bots" edge IDs in the mutation.
func (m *BotRunnerMutation) BotsIDs() (ids []uuid.UUID) {
	for id := range m.bots {
		ids = append(ids, id)
	}
	return
}

// ResetBots resets all changes to the "bots" edge.
func (m *BotRunnerMutation) ResetBots() {
	m.bots = nil
	m.clearedbots = false
	m.removedbots = nil
}

// AddBacktestIDs adds the "backtests" edge to the Backtest entity by ids.
func (m *BotRunnerMutation) AddBacktestIDs(ids ...uuid.UUID) {
	if m.backtests == nil {
		m.backtests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.backtests[ids[i]] = struct{}{}
	}
}

// ClearBacktests clears the "backtests" edge to the Backtest entity.
func (m *BotRunnerMutation) ClearBacktests() {
	m.clearedbacktests = true
}

// BacktestsCleared reports if the "backtests" edge to the Backtest entity was cleared.
func (m *BotRunnerMutation) BacktestsCleared() bool {
	return m.clearedbacktests
}

// RemoveBacktestIDs removes the "backtests" edge to the Backtest entity by IDs.
func (m *BotRunnerMutation) RemoveBacktestIDs(ids ...uuid.UUID) {
	if m.removedbacktests == nil {
		m.removedbacktests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.backtests, ids[i])
		m.removedbacktests[ids[i]] = struct{}{}
	}
}

// RemovedBacktests returns the removed IDs of the "backtests" edge to the Backtest entity.
func (m *BotRunnerMutation) RemovedBacktestsIDs() (ids []uuid.UUID) {
	for id := range m.removedbacktests {
		ids = append(ids, id)
	}
	return
}

// BacktestsIDs returns the "backtests" edge IDs in the mutation.
func (m *BotRunnerMutation) BacktestsIDs() (ids []uuid.UUID) {
	for id := range m.backtests {
		ids = append(ids, id)
	}
	return
}

// ResetBacktests resets all changes to the "backtests" edge.
func (m *BotRunnerMutation) ResetBacktests() {
	m.backtests = nil
	m.clearedbacktests = false
	m.removedbacktests = nil
}

// AddUsageSampleIDs adds the "usage_samples" edge to the ResourceUsageSample entity by ids.
func (m *BotRunnerMutation) AddUsageSampleIDs(ids ...uuid.UUID) {
	if m.usage_samples == nil {
		m.usage_samples = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.usage_samples[ids[i]] = struct{}{}
	}
}

// ClearUsageSamples clears the "usage_samples" edge to the ResourceUsageSample entity.
func (m *BotRunnerMutation) ClearUsageSamples() {
	m.clearedusage_samples = true
}

// UsageSamplesCleared reports if the "usage_samples" edge to the ResourceUsageSample entity was cleared.
func (m *BotRunnerMutation) UsageSamplesCleared() bool {
	return m.clearedusage_samples
}

// RemoveUsageSampleIDs removes the "usage_samples" edge to the ResourceUsageSample entity by IDs.
func (m *BotRunnerMutation) RemoveUsageSampleIDs(ids ...uuid.UUID) {
	if m.removedusage_samples == nil {
		m.removedusage_samples = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.usage_samples, ids[i])
		m.removedusage_samples[ids[i]] = struct{}{}
	}
}

// RemovedUsageSamples returns the removed IDs of the "usage_samples" edge to the ResourceUsageSample entity.
func (m *BotRunnerMutation) RemovedUsageSamplesIDs() (ids []uuid.UUID) {
	for id := range m.removedusage_samples {
		ids = append(ids, id)
	}
	return
}

// UsageSamplesIDs returns the "usage_samples" edge IDs in the mutation.
func (m *BotRunnerMutation) UsageSamplesIDs() (ids []uuid.UUID) {
	for id := range m.usage_samples {
		ids = append(ids, id)
	}
	return
}

// ResetUsageSamples resets all changes to the "usage_samples" edge.
func (m *BotRunnerMutation) ResetUsageSamples() {
	m.usage_samples = nil
	m.clearedusage_samples = false
	m.removedusage_samples = nil
}

// AddUsageAggregationIDs adds the "usage_aggregations" edge to the ResourceUsageAggregation entity by ids.
func (m *BotRunnerMutation) AddUsageAggregationIDs(ids ...uuid.UUID) {
	if m.usage_aggregations == nil {
		m.usage_aggregations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.usage_aggregations[ids[i]] = struct{}{}
	}
}

// ClearUsageAggregations clears the "usage_aggregations" edge to the ResourceUsageAggregation entity.
func (m *BotRunnerMutation) ClearUsageAggregations() {
	m.clearedusage_aggregations = true
}

// UsageAggregationsCleared reports if the "usage_aggregations" edge to the ResourceUsageAggregation entity was cleared.
func (m *BotRunnerMutation) UsageAggregationsCleared() bool {
	return m.clearedusage_aggregations
}

// RemoveUsageAggregationIDs removes the "usage_aggregations" edge to the ResourceUsageAggregation entity by IDs.
func (m *BotRunnerMutation) RemoveUsageAggregationIDs(ids ...uuid.UUID) {
	if m.removedusage_aggregations == nil {
		m.removedusage_aggregations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.usage_aggregations, ids[i])
		m.removedusage_aggregations[ids[i]] = struct{}{}
	}
}

// RemovedUsageAggregations returns the removed IDs of the "usage_aggregations" edge to the ResourceUsageAggregation entity.
func (m *BotRunnerMutation) RemovedUsageAggregationsIDs() (ids []uuid.UUID) {
	for id := range m.removedusage_aggregations {
		ids = append(ids, id)
	}
	return
}

// UsageAggregationsIDs returns the "usage_aggregations" edge IDs in the mutation.
func (m *BotRunnerMutation) UsageAggregationsIDs() (ids []uuid.UUID) {
	for id := range m.usage_aggregations {
		ids = append(ids, id)
	}
	return
}

// ResetUsageAggregations resets all changes to the "usage_aggregations" edge.
func (m *BotRunnerMutation) ResetUsageAggregations() {
	m.usage_aggregations = nil
	m.clearedusage_aggregations = false
	m.removedusage_aggregations = nil
}

// Where appends a list predicates to the BotRunnerMutation builder.
func (m *BotRunnerMutation) Where(ps ...predicate.BotRunner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BotRunnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BotRunnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BotRunner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BotRunnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BotRunnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BotRunner).
func (m *BotRunnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BotRunnerMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.public != nil {
		fields = append(fields, botrunner.FieldPublic)
	}
	if m.deleted_at != nil {
		fields = append(fields, botrunner.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, botrunner.FieldName)
	}
	if m._type != nil {
		fields = append(fields, botrunner.FieldType)
	}
	if m._config != nil {
		fields = append(fields, botrunner.FieldConfig)
	}
	if m.data_is_ready != nil {
		fields = append(fields, botrunner.FieldDataIsReady)
	}
	if m.data_last_updated != nil {
		fields = append(fields, botrunner.FieldDataLastUpdated)
	}
	if m.data_download_status != nil {
		fields = append(fields, botrunner.FieldDataDownloadStatus)
	}
	if m.data_download_started_at != nil {
		fields = append(fields, botrunner.FieldDataDownloadStartedAt)
	}
	if m.data_download_progress != nil {
		fields = append(fields, botrunner.FieldDataDownloadProgress)
	}
	if m.data_error_message != nil {
		fields = append(fields, botrunner.FieldDataErrorMessage)
	}
	if m.data_download_config != nil {
		fields = append(fields, botrunner.FieldDataDownloadConfig)
	}
	if m.s3_config != nil {
		fields = append(fields, botrunner.FieldS3Config)
	}
	if m.s3_data_key != nil {
		fields = append(fields, botrunner.FieldS3DataKey)
	}
	if m.s3_data_uploaded_at != nil {
		fields = append(fields, botrunner.FieldS3DataUploadedAt)
	}
	if m.data_available != nil {
		fields = append(fields, botrunner.FieldDataAvailable)
	}
	if m.owner_id != nil {
		fields = append(fields, botrunner.FieldOwnerID)
	}
	if m.billing_enabled != nil {
		fields = append(fields, botrunner.FieldBillingEnabled)
	}
	if m.cpu_price_per_core_hour != nil {
		fields = append(fields, botrunner.FieldCPUPricePerCoreHour)
	}
	if m.memory_price_per_gb_hour != nil {
		fields = append(fields, botrunner.FieldMemoryPricePerGBHour)
	}
	if m.network_price_per_gb != nil {
		fields = append(fields, botrunner.FieldNetworkPricePerGB)
	}
	if m.storage_price_per_gb != nil {
		fields = append(fields, botrunner.FieldStoragePricePerGB)
	}
	if m.created_at != nil {
		fields = append(fields, botrunner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, botrunner.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BotRunnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case botrunner.FieldPublic:
		return m.Public()
	case botrunner.FieldDeletedAt:
		return m.DeletedAt()
	case botrunner.FieldName:
		return m.Name()
	case botrunner.FieldType:
		return m.GetType()
	case botrunner.FieldConfig:
		return m.Config()
	case botrunner.FieldDataIsReady:
		return m.DataIsReady()
	case botrunner.FieldDataLastUpdated:
		return m.DataLastUpdated()
	case botrunner.FieldDataDownloadStatus:
		return m.DataDownloadStatus()
	case botrunner.FieldDataDownloadStartedAt:
		return m.DataDownloadStartedAt()
	case botrunner.FieldDataDownloadProgress:
		return m.DataDownloadProgress()
	case botrunner.FieldDataErrorMessage:
		return m.DataErrorMessage()
	case botrunner.FieldDataDownloadConfig:
		return m.DataDownloadConfig()
	case botrunner.FieldS3Config:
		return m.S3Config()
	case botrunner.FieldS3DataKey:
		return m.S3DataKey()
	case botrunner.FieldS3DataUploadedAt:
		return m.S3DataUploadedAt()
	case botrunner.FieldDataAvailable:
		return m.DataAvailable()
	case botrunner.FieldOwnerID:
		return m.OwnerID()
	case botrunner.FieldBillingEnabled:
		return m.BillingEnabled()
	case botrunner.FieldCPUPricePerCoreHour:
		return m.CPUPricePerCoreHour()
	case botrunner.FieldMemoryPricePerGBHour:
		return m.MemoryPricePerGBHour()
	case botrunner.FieldNetworkPricePerGB:
		return m.NetworkPricePerGB()
	case botrunner.FieldStoragePricePerGB:
		return m.StoragePricePerGB()
	case botrunner.FieldCreatedAt:
		return m.CreatedAt()
	case botrunner.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BotRunnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case botrunner.FieldPublic:
		return m.OldPublic(ctx)
	case botrunner.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case botrunner.FieldName:
		return m.OldName(ctx)
	case botrunner.FieldType:
		return m.OldType(ctx)
	case botrunner.FieldConfig:
		return m.OldConfig(ctx)
	case botrunner.FieldDataIsReady:
		return m.OldDataIsReady(ctx)
	case botrunner.FieldDataLastUpdated:
		return m.OldDataLastUpdated(ctx)
	case botrunner.FieldDataDownloadStatus:
		return m.OldDataDownloadStatus(ctx)
	case botrunner.FieldDataDownloadStartedAt:
		return m.OldDataDownloadStartedAt(ctx)
	case botrunner.FieldDataDownloadProgress:
		return m.OldDataDownloadProgress(ctx)
	case botrunner.FieldDataErrorMessage:
		return m.OldDataErrorMessage(ctx)
	case botrunner.FieldDataDownloadConfig:
		return m.OldDataDownloadConfig(ctx)
	case botrunner.FieldS3Config:
		return m.OldS3Config(ctx)
	case botrunner.FieldS3DataKey:
		return m.OldS3DataKey(ctx)
	case botrunner.FieldS3DataUploadedAt:
		return m.OldS3DataUploadedAt(ctx)
	case botrunner.FieldDataAvailable:
		return m.OldDataAvailable(ctx)
	case botrunner.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case botrunner.FieldBillingEnabled:
		return m.OldBillingEnabled(ctx)
	case botrunner.FieldCPUPricePerCoreHour:
		return m.OldCPUPricePerCoreHour(ctx)
	case botrunner.FieldMemoryPricePerGBHour:
		return m.OldMemoryPricePerGBHour(ctx)
	case botrunner.FieldNetworkPricePerGB:
		return m.OldNetworkPricePerGB(ctx)
	case botrunner.FieldStoragePricePerGB:
		return m.OldStoragePricePerGB(ctx)
	case botrunner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case botrunner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BotRunner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotRunnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case botrunner.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case botrunner.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case botrunner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case botrunner.FieldType:
		v, ok := value.(enum.RunnerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case botrunner.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case botrunner.FieldDataIsReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataIsReady(v)
		return nil
	case botrunner.FieldDataLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataLastUpdated(v)
		return nil
	case botrunner.FieldDataDownloadStatus:
		v, ok := value.(enum.DataDownloadStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataDownloadStatus(v)
		return nil
	case botrunner.FieldDataDownloadStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataDownloadStartedAt(v)
		return nil
	case botrunner.FieldDataDownloadProgress:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataDownloadProgress(v)
		return nil
	case botrunner.FieldDataErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataErrorMessage(v)
		return nil
	case botrunner.FieldDataDownloadConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataDownloadConfig(v)
		return nil
	case botrunner.FieldS3Config:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3Config(v)
		return nil
	case botrunner.FieldS3DataKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3DataKey(v)
		return nil
	case botrunner.FieldS3DataUploadedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3DataUploadedAt(v)
		return nil
	case botrunner.FieldDataAvailable:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataAvailable(v)
		return nil
	case botrunner.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case botrunner.FieldBillingEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingEnabled(v)
		return nil
	case botrunner.FieldCPUPricePerCoreHour:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUPricePerCoreHour(v)
		return nil
	case botrunner.FieldMemoryPricePerGBHour:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemoryPricePerGBHour(v)
		return nil
	case botrunner.FieldNetworkPricePerGB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkPricePerGB(v)
		return nil
	case botrunner.FieldStoragePricePerGB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePricePerGB(v)
		return nil
	case botrunner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case botrunner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BotRunner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BotRunnerMutation) AddedFields() []string {
	var fields []string
	if m.addcpu_price_per_core_hour != nil {
		fields = append(fields, botrunner.FieldCPUPricePerCoreHour)
	}
	if m.addmemory_price_per_gb_hour != nil {
		fields = append(fields, botrunner.FieldMemoryPricePerGBHour)
	}
	if m.addnetwork_price_per_gb != nil {
		fields = append(fields, botrunner.FieldNetworkPricePerGB)
	}
	if m.addstorage_price_per_gb != nil {
		fields = append(fields, botrunner.FieldStoragePricePerGB)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BotRunnerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case botrunner.FieldCPUPricePerCoreHour:
		return m.AddedCPUPricePerCoreHour()
	case botrunner.FieldMemoryPricePerGBHour:
		return m.AddedMemoryPricePerGBHour()
	case botrunner.FieldNetworkPricePerGB:
		return m.AddedNetworkPricePerGB()
	case botrunner.FieldStoragePricePerGB:
		return m.AddedStoragePricePerGB()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BotRunnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case botrunner.FieldCPUPricePerCoreHour:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUPricePerCoreHour(v)
		return nil
	case botrunner.FieldMemoryPricePerGBHour:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemoryPricePerGBHour(v)
		return nil
	case botrunner.FieldNetworkPricePerGB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetworkPricePerGB(v)
		return nil
	case botrunner.FieldStoragePricePerGB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoragePricePerGB(v)
		return nil
	}
	return fmt.Errorf("unknown BotRunner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BotRunnerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(botrunner.FieldDeletedAt) {
		fields = append(fields, botrunner.FieldDeletedAt)
	}
	if m.FieldCleared(botrunner.FieldConfig) {
		fields = append(fields, botrunner.FieldConfig)
	}
	if m.FieldCleared(botrunner.FieldDataLastUpdated) {
		fields = append(fields, botrunner.FieldDataLastUpdated)
	}
	if m.FieldCleared(botrunner.FieldDataDownloadStartedAt) {
		fields = append(fields, botrunner.FieldDataDownloadStartedAt)
	}
	if m.FieldCleared(botrunner.FieldDataDownloadProgress) {
		fields = append(fields, botrunner.FieldDataDownloadProgress)
	}
	if m.FieldCleared(botrunner.FieldDataErrorMessage) {
		fields = append(fields, botrunner.FieldDataErrorMessage)
	}
	if m.FieldCleared(botrunner.FieldDataDownloadConfig) {
		fields = append(fields, botrunner.FieldDataDownloadConfig)
	}
	if m.FieldCleared(botrunner.FieldS3Config) {
		fields = append(fields, botrunner.FieldS3Config)
	}
	if m.FieldCleared(botrunner.FieldS3DataKey) {
		fields = append(fields, botrunner.FieldS3DataKey)
	}
	if m.FieldCleared(botrunner.FieldS3DataUploadedAt) {
		fields = append(fields, botrunner.FieldS3DataUploadedAt)
	}
	if m.FieldCleared(botrunner.FieldDataAvailable) {
		fields = append(fields, botrunner.FieldDataAvailable)
	}
	if m.FieldCleared(botrunner.FieldCPUPricePerCoreHour) {
		fields = append(fields, botrunner.FieldCPUPricePerCoreHour)
	}
	if m.FieldCleared(botrunner.FieldMemoryPricePerGBHour) {
		fields = append(fields, botrunner.FieldMemoryPricePerGBHour)
	}
	if m.FieldCleared(botrunner.FieldNetworkPricePerGB) {
		fields = append(fields, botrunner.FieldNetworkPricePerGB)
	}
	if m.FieldCleared(botrunner.FieldStoragePricePerGB) {
		fields = append(fields, botrunner.FieldStoragePricePerGB)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BotRunnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BotRunnerMutation) ClearField(name string) error {
	switch name {
	case botrunner.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case botrunner.FieldConfig:
		m.ClearConfig()
		return nil
	case botrunner.FieldDataLastUpdated:
		m.ClearDataLastUpdated()
		return nil
	case botrunner.FieldDataDownloadStartedAt:
		m.ClearDataDownloadStartedAt()
		return nil
	case botrunner.FieldDataDownloadProgress:
		m.ClearDataDownloadProgress()
		return nil
	case botrunner.FieldDataErrorMessage:
		m.ClearDataErrorMessage()
		return nil
	case botrunner.FieldDataDownloadConfig:
		m.ClearDataDownloadConfig()
		return nil
	case botrunner.FieldS3Config:
		m.ClearS3Config()
		return nil
	case botrunner.FieldS3DataKey:
		m.ClearS3DataKey()
		return nil
	case botrunner.FieldS3DataUploadedAt:
		m.ClearS3DataUploadedAt()
		return nil
	case botrunner.FieldDataAvailable:
		m.ClearDataAvailable()
		return nil
	case botrunner.FieldCPUPricePerCoreHour:
		m.ClearCPUPricePerCoreHour()
		return nil
	case botrunner.FieldMemoryPricePerGBHour:
		m.ClearMemoryPricePerGBHour()
		return nil
	case botrunner.FieldNetworkPricePerGB:
		m.ClearNetworkPricePerGB()
		return nil
	case botrunner.FieldStoragePricePerGB:
		m.ClearStoragePricePerGB()
		return nil
	}
	return fmt.Errorf("unknown BotRunner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BotRunnerMutation) ResetField(name string) error {
	switch name {
	case botrunner.FieldPublic:
		m.ResetPublic()
		return nil
	case botrunner.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case botrunner.FieldName:
		m.ResetName()
		return nil
	case botrunner.FieldType:
		m.ResetType()
		return nil
	case botrunner.FieldConfig:
		m.ResetConfig()
		return nil
	case botrunner.FieldDataIsReady:
		m.ResetDataIsReady()
		return nil
	case botrunner.FieldDataLastUpdated:
		m.ResetDataLastUpdated()
		return nil
	case botrunner.FieldDataDownloadStatus:
		m.ResetDataDownloadStatus()
		return nil
	case botrunner.FieldDataDownloadStartedAt:
		m.ResetDataDownloadStartedAt()
		return nil
	case botrunner.FieldDataDownloadProgress:
		m.ResetDataDownloadProgress()
		return nil
	case botrunner.FieldDataErrorMessage:
		m.ResetDataErrorMessage()
		return nil
	case botrunner.FieldDataDownloadConfig:
		m.ResetDataDownloadConfig()
		return nil
	case botrunner.FieldS3Config:
		m.ResetS3Config()
		return nil
	case botrunner.FieldS3DataKey:
		m.ResetS3DataKey()
		return nil
	case botrunner.FieldS3DataUploadedAt:
		m.ResetS3DataUploadedAt()
		return nil
	case botrunner.FieldDataAvailable:
		m.ResetDataAvailable()
		return nil
	case botrunner.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case botrunner.FieldBillingEnabled:
		m.ResetBillingEnabled()
		return nil
	case botrunner.FieldCPUPricePerCoreHour:
		m.ResetCPUPricePerCoreHour()
		return nil
	case botrunner.FieldMemoryPricePerGBHour:
		m.ResetMemoryPricePerGBHour()
		return nil
	case botrunner.FieldNetworkPricePerGB:
		m.ResetNetworkPricePerGB()
		return nil
	case botrunner.FieldStoragePricePerGB:
		m.ResetStoragePricePerGB()
		return nil
	case botrunner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case botrunner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BotRunner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BotRunnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.bots != nil {
		edges = append(edges, botrunner.EdgeBots)
	}
	if m.backtests != nil {
		edges = append(edges, botrunner.EdgeBacktests)
	}
	if m.usage_samples != nil {
		edges = append(edges, botrunner.EdgeUsageSamples)
	}
	if m.usage_aggregations != nil {
		edges = append(edges, botrunner.EdgeUsageAggregations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BotRunnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case botrunner.EdgeBots:
		ids := make([]ent.Value, 0, len(m.bots))
		for id := range m.bots {
			ids = append(ids, id)
		}
		return ids
	case botrunner.EdgeBacktests:
		ids := make([]ent.Value, 0, len(m.backtests))
		for id := range m.backtests {
			ids = append(ids, id)
		}
		return ids
	case botrunner.EdgeUsageSamples:
		ids := make([]ent.Value, 0, len(m.usage_samples))
		for id := range m.usage_samples {
			ids = append(ids, id)
		}
		return ids
	case botrunner.EdgeUsageAggregations:
		ids := make([]ent.Value, 0, len(m.usage_aggregations))
		for id := range m.usage_aggregations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BotRunnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedbots != nil {
		edges = append(edges, botrunner.EdgeBots)
	}
	if m.removedbacktests != nil {
		edges = append(edges, botrunner.EdgeBacktests)
	}
	if m.removedusage_samples != nil {
		edges = append(edges, botrunner.EdgeUsageSamples)
	}
	if m.removedusage_aggregations != nil {
		edges = append(edges, botrunner.EdgeUsageAggregations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BotRunnerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case botrunner.EdgeBots:
		ids := make([]ent.Value, 0, len(m.removedbots))
		for id := range m.removedbots {
			ids = append(ids, id)
		}
		return ids
	case botrunner.EdgeBacktests:
		ids := make([]ent.Value, 0, len(m.removedbacktests))
		for id := range m.removedbacktests {
			ids = append(ids, id)
		}
		return ids
	case botrunner.EdgeUsageSamples:
		ids := make([]ent.Value, 0, len(m.removedusage_samples))
		for id := range m.removedusage_samples {
			ids = append(ids, id)
		}
		return ids
	case botrunner.EdgeUsageAggregations:
		ids := make([]ent.Value, 0, len(m.removedusage_aggregations))
		for id := range m.removedusage_aggregations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BotRunnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbots {
		edges = append(edges, botrunner.EdgeBots)
	}
	if m.clearedbacktests {
		edges = append(edges, botrunner.EdgeBacktests)
	}
	if m.clearedusage_samples {
		edges = append(edges, botrunner.EdgeUsageSamples)
	}
	if m.clearedusage_aggregations {
		edges = append(edges, botrunner.EdgeUsageAggregations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BotRunnerMutation) EdgeCleared(name string) bool {
	switch name {
	case botrunner.EdgeBots:
		return m.clearedbots
	case botrunner.EdgeBacktests:
		return m.clearedbacktests
	case botrunner.EdgeUsageSamples:
		return m.clearedusage_samples
	case botrunner.EdgeUsageAggregations:
		return m.clearedusage_aggregations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BotRunnerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BotRunner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BotRunnerMutation) ResetEdge(name string) error {
	switch name {
	case botrunner.EdgeBots:
		m.ResetBots()
		return nil
	case botrunner.EdgeBacktests:
		m.ResetBacktests()
		return nil
	case botrunner.EdgeUsageSamples:
		m.ResetUsageSamples()
		return nil
	case botrunner.EdgeUsageAggregations:
		m.ResetUsageAggregations()
		return nil
	}
	return fmt.Errorf("unknown BotRunner edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	name          *string
	_config       *map[string]interface{}
	owner_id      *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	bots          map[uuid.UUID]struct{}
	removedbots   map[uuid.UUID]struct{}
	clearedbots   bool
	done          bool
	oldValue      func(context.Context) (*Exchange, error)
	predicates    []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id uuid.UUID) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exchange entities.
func (m *ExchangeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExchangeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExchangeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ExchangeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[exchange.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ExchangeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[exchange.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExchangeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, exchange.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ExchangeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExchangeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExchangeMutation) ResetName() {
	m.name = nil
}

// SetConfig sets the "config" field.
func (m *ExchangeMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *ExchangeMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *ExchangeMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[exchange.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *ExchangeMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[exchange.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *ExchangeMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, exchange.FieldConfig)
}

// SetOwnerID sets the "owner_id" field.
func (m *ExchangeMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ExchangeMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ExchangeMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExchangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExchangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExchangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExchangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExchangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExchangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBotIDs adds the "bots" edge to the Bot entity by ids.
func (m *ExchangeMutation) AddBotIDs(ids ...uuid.UUID) {
	if m.bots == nil {
		m.bots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bots[ids[i]] = struct{}{}
	}
}

// ClearBots clears the "bots" edge to the Bot entity.
func (m *ExchangeMutation) ClearBots() {
	m.clearedbots = true
}

// BotsCleared reports if the "bots" edge to the Bot entity was cleared.
func (m *ExchangeMutation) BotsCleared() bool {
	return m.clearedbots
}

// RemoveBotIDs removes the "bots" edge to the Bot entity by IDs.
func (m *ExchangeMutation) RemoveBotIDs(ids ...uuid.UUID) {
	if m.removedbots == nil {
		m.removedbots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bots, ids[i])
		m.removedbots[ids[i]] = struct{}{}
	}
}

// RemovedBots returns the removed IDs of the "bots" edge to the Bot entity.
func (m *ExchangeMutation) RemovedBotsIDs() (ids []uuid.UUID) {
	for id := range m.removedbots {
		ids = append(ids, id)
	}
	return
}

// BotsIDs returns the "bots" edge IDs in the mutation.
func (m *ExchangeMutation) BotsIDs() (ids []uuid.UUID) {
	for id := range m.bots {
		ids = append(ids, id)
	}
	return
}

// ResetBots resets all changes to the "bots" edge.
func (m *ExchangeMutation) ResetBots() {
	m.bots = nil
	m.clearedbots = false
	m.removedbots = nil
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExchangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExchangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exchange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExchangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, exchange.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, exchange.FieldName)
	}
	if m._config != nil {
		fields = append(fields, exchange.FieldConfig)
	}
	if m.owner_id != nil {
		fields = append(fields, exchange.FieldOwnerID)
	}
	if m.created_at != nil {
		fields = append(fields, exchange.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exchange.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldDeletedAt:
		return m.DeletedAt()
	case exchange.FieldName:
		return m.Name()
	case exchange.FieldConfig:
		return m.Config()
	case exchange.FieldOwnerID:
		return m.OwnerID()
	case exchange.FieldCreatedAt:
		return m.CreatedAt()
	case exchange.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case exchange.FieldName:
		return m.OldName(ctx)
	case exchange.FieldConfig:
		return m.OldConfig(ctx)
	case exchange.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case exchange.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exchange.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case exchange.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case exchange.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case exchange.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case exchange.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exchange.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exchange.FieldDeletedAt) {
		fields = append(fields, exchange.FieldDeletedAt)
	}
	if m.FieldCleared(exchange.FieldConfig) {
		fields = append(fields, exchange.FieldConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	switch name {
	case exchange.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case exchange.FieldConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case exchange.FieldName:
		m.ResetName()
		return nil
	case exchange.FieldConfig:
		m.ResetConfig()
		return nil
	case exchange.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case exchange.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exchange.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bots != nil {
		edges = append(edges, exchange.EdgeBots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeBots:
		ids := make([]ent.Value, 0, len(m.bots))
		for id := range m.bots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbots != nil {
		edges = append(edges, exchange.EdgeBots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeBots:
		ids := make([]ent.Value, 0, len(m.removedbots))
		for id := range m.removedbots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbots {
		edges = append(edges, exchange.EdgeBots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	switch name {
	case exchange.EdgeBots:
		return m.clearedbots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	switch name {
	case exchange.EdgeBots:
		m.ResetBots()
		return nil
	}
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// ResourceUsageAggregationMutation represents an operation that mutates the ResourceUsageAggregation nodes in the graph.
type ResourceUsageAggregationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	deleted_at           *time.Time
	resource_type        *enum.ResourceType
	resource_id          *uuid.UUID
	owner_id             *string
	granularity          *enum.AggregationGranularity
	bucket_start         *time.Time
	bucket_end           *time.Time
	cpu_core_seconds     *float64
	addcpu_core_seconds  *float64
	cpu_avg_percent      *float64
	addcpu_avg_percent   *float64
	cpu_max_percent      *float64
	addcpu_max_percent   *float64
	memory_gb_seconds    *float64
	addmemory_gb_seconds *float64
	memory_avg_bytes     *int64
	addmemory_avg_bytes  *int64
	memory_max_bytes     *int64
	addmemory_max_bytes  *int64
	network_rx_bytes     *int64
	addnetwork_rx_bytes  *int64
	network_tx_bytes     *int64
	addnetwork_tx_bytes  *int64
	block_read_bytes     *int64
	addblock_read_bytes  *int64
	block_write_bytes    *int64
	addblock_write_bytes *int64
	sample_count         *int
	addsample_count      *int
	created_at           *time.Time
	clearedFields        map[string]struct{}
	runner               *uuid.UUID
	clearedrunner        bool
	done                 bool
	oldValue             func(context.Context) (*ResourceUsageAggregation, error)
	predicates           []predicate.ResourceUsageAggregation
}

var _ ent.Mutation = (*ResourceUsageAggregationMutation)(nil)

// resourceusageaggregationOption allows management of the mutation configuration using functional options.
type resourceusageaggregationOption func(*ResourceUsageAggregationMutation)

// newResourceUsageAggregationMutation creates new mutation for the ResourceUsageAggregation entity.
func newResourceUsageAggregationMutation(c config, op Op, opts ...resourceusageaggregationOption) *ResourceUsageAggregationMutation {
	m := &ResourceUsageAggregationMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceUsageAggregation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceUsageAggregationID sets the ID field of the mutation.
func withResourceUsageAggregationID(id uuid.UUID) resourceusageaggregationOption {
	return func(m *ResourceUsageAggregationMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceUsageAggregation
		)
		m.oldValue = func(ctx context.Context) (*ResourceUsageAggregation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceUsageAggregation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceUsageAggregation sets the old ResourceUsageAggregation of the mutation.
func withResourceUsageAggregation(node *ResourceUsageAggregation) resourceusageaggregationOption {
	return func(m *ResourceUsageAggregationMutation) {
		m.oldValue = func(context.Context) (*ResourceUsageAggregation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceUsageAggregationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceUsageAggregationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceUsageAggregation entities.
func (m *ResourceUsageAggregationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceUsageAggregationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceUsageAggregationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceUsageAggregation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResourceUsageAggregationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResourceUsageAggregationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResourceUsageAggregationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resourceusageaggregation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResourceUsageAggregationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resourceusageaggregation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResourceUsageAggregationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resourceusageaggregation.FieldDeletedAt)
}

// SetResourceType sets the "resource_type" field.
func (m *ResourceUsageAggregationMutation) SetResourceType(et enum.ResourceType) {
	m.resource_type = &et
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *ResourceUsageAggregationMutation) ResourceType() (r enum.ResourceType, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldResourceType(ctx context.Context) (v enum.ResourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *ResourceUsageAggregationMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *ResourceUsageAggregationMutation) SetResourceID(u uuid.UUID) {
	m.resource_id = &u
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ResourceUsageAggregationMutation) ResourceID() (r uuid.UUID, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldResourceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ResourceUsageAggregationMutation) ResetResourceID() {
	m.resource_id = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *ResourceUsageAggregationMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ResourceUsageAggregationMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ResourceUsageAggregationMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetRunnerID sets the "runner_id" field.
func (m *ResourceUsageAggregationMutation) SetRunnerID(u uuid.UUID) {
	m.runner = &u
}

// RunnerID returns the value of the "runner_id" field in the mutation.
func (m *ResourceUsageAggregationMutation) RunnerID() (r uuid.UUID, exists bool) {
	v := m.runner
	if v == nil {
		return
	}
	return *v, true
}

// OldRunnerID returns the old "runner_id" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldRunnerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunnerID: %w", err)
	}
	return oldValue.RunnerID, nil
}

// ResetRunnerID resets all changes to the "runner_id" field.
func (m *ResourceUsageAggregationMutation) ResetRunnerID() {
	m.runner = nil
}

// SetGranularity sets the "granularity" field.
func (m *ResourceUsageAggregationMutation) SetGranularity(eg enum.AggregationGranularity) {
	m.granularity = &eg
}

// Granularity returns the value of the "granularity" field in the mutation.
func (m *ResourceUsageAggregationMutation) Granularity() (r enum.AggregationGranularity, exists bool) {
	v := m.granularity
	if v == nil {
		return
	}
	return *v, true
}

// OldGranularity returns the old "granularity" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldGranularity(ctx context.Context) (v enum.AggregationGranularity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGranularity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGranularity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGranularity: %w", err)
	}
	return oldValue.Granularity, nil
}

// ResetGranularity resets all changes to the "granularity" field.
func (m *ResourceUsageAggregationMutation) ResetGranularity() {
	m.granularity = nil
}

// SetBucketStart sets the "bucket_start" field.
func (m *ResourceUsageAggregationMutation) SetBucketStart(t time.Time) {
	m.bucket_start = &t
}

// BucketStart returns the value of the "bucket_start" field in the mutation.
func (m *ResourceUsageAggregationMutation) BucketStart() (r time.Time, exists bool) {
	v := m.bucket_start
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketStart returns the old "bucket_start" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldBucketStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketStart: %w", err)
	}
	return oldValue.BucketStart, nil
}

// ResetBucketStart resets all changes to the "bucket_start" field.
func (m *ResourceUsageAggregationMutation) ResetBucketStart() {
	m.bucket_start = nil
}

// SetBucketEnd sets the "bucket_end" field.
func (m *ResourceUsageAggregationMutation) SetBucketEnd(t time.Time) {
	m.bucket_end = &t
}

// BucketEnd returns the value of the "bucket_end" field in the mutation.
func (m *ResourceUsageAggregationMutation) BucketEnd() (r time.Time, exists bool) {
	v := m.bucket_end
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketEnd returns the old "bucket_end" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldBucketEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketEnd: %w", err)
	}
	return oldValue.BucketEnd, nil
}

// ResetBucketEnd resets all changes to the "bucket_end" field.
func (m *ResourceUsageAggregationMutation) ResetBucketEnd() {
	m.bucket_end = nil
}

// SetCPUCoreSeconds sets the "cpu_core_seconds" field.
func (m *ResourceUsageAggregationMutation) SetCPUCoreSeconds(f float64) {
	m.cpu_core_seconds = &f
	m.addcpu_core_seconds = nil
}

// CPUCoreSeconds returns the value of the "cpu_core_seconds" field in the mutation.
func (m *ResourceUsageAggregationMutation) CPUCoreSeconds() (r float64, exists bool) {
	v := m.cpu_core_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCoreSeconds returns the old "cpu_core_seconds" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldCPUCoreSeconds(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCoreSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCoreSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCoreSeconds: %w", err)
	}
	return oldValue.CPUCoreSeconds, nil
}

// AddCPUCoreSeconds adds f to the "cpu_core_seconds" field.
func (m *ResourceUsageAggregationMutation) AddCPUCoreSeconds(f float64) {
	if m.addcpu_core_seconds != nil {
		*m.addcpu_core_seconds += f
	} else {
		m.addcpu_core_seconds = &f
	}
}

// AddedCPUCoreSeconds returns the value that was added to the "cpu_core_seconds" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedCPUCoreSeconds() (r float64, exists bool) {
	v := m.addcpu_core_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCoreSeconds resets all changes to the "cpu_core_seconds" field.
func (m *ResourceUsageAggregationMutation) ResetCPUCoreSeconds() {
	m.cpu_core_seconds = nil
	m.addcpu_core_seconds = nil
}

// SetCPUAvgPercent sets the "cpu_avg_percent" field.
func (m *ResourceUsageAggregationMutation) SetCPUAvgPercent(f float64) {
	m.cpu_avg_percent = &f
	m.addcpu_avg_percent = nil
}

// CPUAvgPercent returns the value of the "cpu_avg_percent" field in the mutation.
func (m *ResourceUsageAggregationMutation) CPUAvgPercent() (r float64, exists bool) {
	v := m.cpu_avg_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUAvgPercent returns the old "cpu_avg_percent" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldCPUAvgPercent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUAvgPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUAvgPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUAvgPercent: %w", err)
	}
	return oldValue.CPUAvgPercent, nil
}

// AddCPUAvgPercent adds f to the "cpu_avg_percent" field.
func (m *ResourceUsageAggregationMutation) AddCPUAvgPercent(f float64) {
	if m.addcpu_avg_percent != nil {
		*m.addcpu_avg_percent += f
	} else {
		m.addcpu_avg_percent = &f
	}
}

// AddedCPUAvgPercent returns the value that was added to the "cpu_avg_percent" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedCPUAvgPercent() (r float64, exists bool) {
	v := m.addcpu_avg_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUAvgPercent resets all changes to the "cpu_avg_percent" field.
func (m *ResourceUsageAggregationMutation) ResetCPUAvgPercent() {
	m.cpu_avg_percent = nil
	m.addcpu_avg_percent = nil
}

// SetCPUMaxPercent sets the "cpu_max_percent" field.
func (m *ResourceUsageAggregationMutation) SetCPUMaxPercent(f float64) {
	m.cpu_max_percent = &f
	m.addcpu_max_percent = nil
}

// CPUMaxPercent returns the value of the "cpu_max_percent" field in the mutation.
func (m *ResourceUsageAggregationMutation) CPUMaxPercent() (r float64, exists bool) {
	v := m.cpu_max_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUMaxPercent returns the old "cpu_max_percent" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldCPUMaxPercent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUMaxPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUMaxPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUMaxPercent: %w", err)
	}
	return oldValue.CPUMaxPercent, nil
}

// AddCPUMaxPercent adds f to the "cpu_max_percent" field.
func (m *ResourceUsageAggregationMutation) AddCPUMaxPercent(f float64) {
	if m.addcpu_max_percent != nil {
		*m.addcpu_max_percent += f
	} else {
		m.addcpu_max_percent = &f
	}
}

// AddedCPUMaxPercent returns the value that was added to the "cpu_max_percent" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedCPUMaxPercent() (r float64, exists bool) {
	v := m.addcpu_max_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUMaxPercent resets all changes to the "cpu_max_percent" field.
func (m *ResourceUsageAggregationMutation) ResetCPUMaxPercent() {
	m.cpu_max_percent = nil
	m.addcpu_max_percent = nil
}

// SetMemoryGBSeconds sets the "memory_gb_seconds" field.
func (m *ResourceUsageAggregationMutation) SetMemoryGBSeconds(f float64) {
	m.memory_gb_seconds = &f
	m.addmemory_gb_seconds = nil
}

// MemoryGBSeconds returns the value of the "memory_gb_seconds" field in the mutation.
func (m *ResourceUsageAggregationMutation) MemoryGBSeconds() (r float64, exists bool) {
	v := m.memory_gb_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldMemoryGBSeconds returns the old "memory_gb_seconds" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldMemoryGBSeconds(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemoryGBSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemoryGBSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemoryGBSeconds: %w", err)
	}
	return oldValue.MemoryGBSeconds, nil
}

// AddMemoryGBSeconds adds f to the "memory_gb_seconds" field.
func (m *ResourceUsageAggregationMutation) AddMemoryGBSeconds(f float64) {
	if m.addmemory_gb_seconds != nil {
		*m.addmemory_gb_seconds += f
	} else {
		m.addmemory_gb_seconds = &f
	}
}

// AddedMemoryGBSeconds returns the value that was added to the "memory_gb_seconds" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedMemoryGBSeconds() (r float64, exists bool) {
	v := m.addmemory_gb_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemoryGBSeconds resets all changes to the "memory_gb_seconds" field.
func (m *ResourceUsageAggregationMutation) ResetMemoryGBSeconds() {
	m.memory_gb_seconds = nil
	m.addmemory_gb_seconds = nil
}

// SetMemoryAvgBytes sets the "memory_avg_bytes" field.
func (m *ResourceUsageAggregationMutation) SetMemoryAvgBytes(i int64) {
	m.memory_avg_bytes = &i
	m.addmemory_avg_bytes = nil
}

// MemoryAvgBytes returns the value of the "memory_avg_bytes" field in the mutation.
func (m *ResourceUsageAggregationMutation) MemoryAvgBytes() (r int64, exists bool) {
	v := m.memory_avg_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldMemoryAvgBytes returns the old "memory_avg_bytes" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldMemoryAvgBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemoryAvgBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemoryAvgBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemoryAvgBytes: %w", err)
	}
	return oldValue.MemoryAvgBytes, nil
}

// AddMemoryAvgBytes adds i to the "memory_avg_bytes" field.
func (m *ResourceUsageAggregationMutation) AddMemoryAvgBytes(i int64) {
	if m.addmemory_avg_bytes != nil {
		*m.addmemory_avg_bytes += i
	} else {
		m.addmemory_avg_bytes = &i
	}
}

// AddedMemoryAvgBytes returns the value that was added to the "memory_avg_bytes" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedMemoryAvgBytes() (r int64, exists bool) {
	v := m.addmemory_avg_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemoryAvgBytes resets all changes to the "memory_avg_bytes" field.
func (m *ResourceUsageAggregationMutation) ResetMemoryAvgBytes() {
	m.memory_avg_bytes = nil
	m.addmemory_avg_bytes = nil
}

// SetMemoryMaxBytes sets the "memory_max_bytes" field.
func (m *ResourceUsageAggregationMutation) SetMemoryMaxBytes(i int64) {
	m.memory_max_bytes = &i
	m.addmemory_max_bytes = nil
}

// MemoryMaxBytes returns the value of the "memory_max_bytes" field in the mutation.
func (m *ResourceUsageAggregationMutation) MemoryMaxBytes() (r int64, exists bool) {
	v := m.memory_max_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldMemoryMaxBytes returns the old "memory_max_bytes" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldMemoryMaxBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemoryMaxBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemoryMaxBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemoryMaxBytes: %w", err)
	}
	return oldValue.MemoryMaxBytes, nil
}

// AddMemoryMaxBytes adds i to the "memory_max_bytes" field.
func (m *ResourceUsageAggregationMutation) AddMemoryMaxBytes(i int64) {
	if m.addmemory_max_bytes != nil {
		*m.addmemory_max_bytes += i
	} else {
		m.addmemory_max_bytes = &i
	}
}

// AddedMemoryMaxBytes returns the value that was added to the "memory_max_bytes" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedMemoryMaxBytes() (r int64, exists bool) {
	v := m.addmemory_max_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemoryMaxBytes resets all changes to the "memory_max_bytes" field.
func (m *ResourceUsageAggregationMutation) ResetMemoryMaxBytes() {
	m.memory_max_bytes = nil
	m.addmemory_max_bytes = nil
}

// SetNetworkRxBytes sets the "network_rx_bytes" field.
func (m *ResourceUsageAggregationMutation) SetNetworkRxBytes(i int64) {
	m.network_rx_bytes = &i
	m.addnetwork_rx_bytes = nil
}

// NetworkRxBytes returns the value of the "network_rx_bytes" field in the mutation.
func (m *ResourceUsageAggregationMutation) NetworkRxBytes() (r int64, exists bool) {
	v := m.network_rx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkRxBytes returns the old "network_rx_bytes" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldNetworkRxBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetworkRxBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetworkRxBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkRxBytes: %w", err)
	}
	return oldValue.NetworkRxBytes, nil
}

// AddNetworkRxBytes adds i to the "network_rx_bytes" field.
func (m *ResourceUsageAggregationMutation) AddNetworkRxBytes(i int64) {
	if m.addnetwork_rx_bytes != nil {
		*m.addnetwork_rx_bytes += i
	} else {
		m.addnetwork_rx_bytes = &i
	}
}

// AddedNetworkRxBytes returns the value that was added to the "network_rx_bytes" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedNetworkRxBytes() (r int64, exists bool) {
	v := m.addnetwork_rx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetNetworkRxBytes resets all changes to the "network_rx_bytes" field.
func (m *ResourceUsageAggregationMutation) ResetNetworkRxBytes() {
	m.network_rx_bytes = nil
	m.addnetwork_rx_bytes = nil
}

// SetNetworkTxBytes sets the "network_tx_bytes" field.
func (m *ResourceUsageAggregationMutation) SetNetworkTxBytes(i int64) {
	m.network_tx_bytes = &i
	m.addnetwork_tx_bytes = nil
}

// NetworkTxBytes returns the value of the "network_tx_bytes" field in the mutation.
func (m *ResourceUsageAggregationMutation) NetworkTxBytes() (r int64, exists bool) {
	v := m.network_tx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkTxBytes returns the old "network_tx_bytes" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldNetworkTxBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetworkTxBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetworkTxBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkTxBytes: %w", err)
	}
	return oldValue.NetworkTxBytes, nil
}

// AddNetworkTxBytes adds i to the "network_tx_bytes" field.
func (m *ResourceUsageAggregationMutation) AddNetworkTxBytes(i int64) {
	if m.addnetwork_tx_bytes != nil {
		*m.addnetwork_tx_bytes += i
	} else {
		m.addnetwork_tx_bytes = &i
	}
}

// AddedNetworkTxBytes returns the value that was added to the "network_tx_bytes" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedNetworkTxBytes() (r int64, exists bool) {
	v := m.addnetwork_tx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetNetworkTxBytes resets all changes to the "network_tx_bytes" field.
func (m *ResourceUsageAggregationMutation) ResetNetworkTxBytes() {
	m.network_tx_bytes = nil
	m.addnetwork_tx_bytes = nil
}

// SetBlockReadBytes sets the "block_read_bytes" field.
func (m *ResourceUsageAggregationMutation) SetBlockReadBytes(i int64) {
	m.block_read_bytes = &i
	m.addblock_read_bytes = nil
}

// BlockReadBytes returns the value of the "block_read_bytes" field in the mutation.
func (m *ResourceUsageAggregationMutation) BlockReadBytes() (r int64, exists bool) {
	v := m.block_read_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockReadBytes returns the old "block_read_bytes" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldBlockReadBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockReadBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockReadBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockReadBytes: %w", err)
	}
	return oldValue.BlockReadBytes, nil
}

// AddBlockReadBytes adds i to the "block_read_bytes" field.
func (m *ResourceUsageAggregationMutation) AddBlockReadBytes(i int64) {
	if m.addblock_read_bytes != nil {
		*m.addblock_read_bytes += i
	} else {
		m.addblock_read_bytes = &i
	}
}

// AddedBlockReadBytes returns the value that was added to the "block_read_bytes" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedBlockReadBytes() (r int64, exists bool) {
	v := m.addblock_read_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockReadBytes resets all changes to the "block_read_bytes" field.
func (m *ResourceUsageAggregationMutation) ResetBlockReadBytes() {
	m.block_read_bytes = nil
	m.addblock_read_bytes = nil
}

// SetBlockWriteBytes sets the "block_write_bytes" field.
func (m *ResourceUsageAggregationMutation) SetBlockWriteBytes(i int64) {
	m.block_write_bytes = &i
	m.addblock_write_bytes = nil
}

// BlockWriteBytes returns the value of the "block_write_bytes" field in the mutation.
func (m *ResourceUsageAggregationMutation) BlockWriteBytes() (r int64, exists bool) {
	v := m.block_write_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockWriteBytes returns the old "block_write_bytes" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldBlockWriteBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockWriteBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockWriteBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockWriteBytes: %w", err)
	}
	return oldValue.BlockWriteBytes, nil
}

// AddBlockWriteBytes adds i to the "block_write_bytes" field.
func (m *ResourceUsageAggregationMutation) AddBlockWriteBytes(i int64) {
	if m.addblock_write_bytes != nil {
		*m.addblock_write_bytes += i
	} else {
		m.addblock_write_bytes = &i
	}
}

// AddedBlockWriteBytes returns the value that was added to the "block_write_bytes" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedBlockWriteBytes() (r int64, exists bool) {
	v := m.addblock_write_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockWriteBytes resets all changes to the "block_write_bytes" field.
func (m *ResourceUsageAggregationMutation) ResetBlockWriteBytes() {
	m.block_write_bytes = nil
	m.addblock_write_bytes = nil
}

// SetSampleCount sets the "sample_count" field.
func (m *ResourceUsageAggregationMutation) SetSampleCount(i int) {
	m.sample_count = &i
	m.addsample_count = nil
}

// SampleCount returns the value of the "sample_count" field in the mutation.
func (m *ResourceUsageAggregationMutation) SampleCount() (r int, exists bool) {
	v := m.sample_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleCount returns the old "sample_count" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldSampleCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleCount: %w", err)
	}
	return oldValue.SampleCount, nil
}

// AddSampleCount adds i to the "sample_count" field.
func (m *ResourceUsageAggregationMutation) AddSampleCount(i int) {
	if m.addsample_count != nil {
		*m.addsample_count += i
	} else {
		m.addsample_count = &i
	}
}

// AddedSampleCount returns the value that was added to the "sample_count" field in this mutation.
func (m *ResourceUsageAggregationMutation) AddedSampleCount() (r int, exists bool) {
	v := m.addsample_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSampleCount resets all changes to the "sample_count" field.
func (m *ResourceUsageAggregationMutation) ResetSampleCount() {
	m.sample_count = nil
	m.addsample_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceUsageAggregationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceUsageAggregationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResourceUsageAggregation entity.
// If the ResourceUsageAggregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageAggregationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceUsageAggregationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearRunner clears the "runner" edge to the BotRunner entity.
func (m *ResourceUsageAggregationMutation) ClearRunner() {
	m.clearedrunner = true
	m.clearedFields[resourceusageaggregation.FieldRunnerID] = struct{}{}
}

// RunnerCleared reports if the "runner" edge to the BotRunner entity was cleared.
func (m *ResourceUsageAggregationMutation) RunnerCleared() bool {
	return m.clearedrunner
}

// RunnerIDs returns the "runner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunnerID instead. It exists only for internal usage by the builders.
func (m *ResourceUsageAggregationMutation) RunnerIDs() (ids []uuid.UUID) {
	if id := m.runner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRunner resets all changes to the "runner" edge.
func (m *ResourceUsageAggregationMutation) ResetRunner() {
	m.runner = nil
	m.clearedrunner = false
}

// Where appends a list predicates to the ResourceUsageAggregationMutation builder.
func (m *ResourceUsageAggregationMutation) Where(ps ...predicate.ResourceUsageAggregation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceUsageAggregationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceUsageAggregationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceUsageAggregation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceUsageAggregationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceUsageAggregationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceUsageAggregation).
func (m *ResourceUsageAggregationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceUsageAggregationMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.deleted_at != nil {
		fields = append(fields, resourceusageaggregation.FieldDeletedAt)
	}
	if m.resource_type != nil {
		fields = append(fields, resourceusageaggregation.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, resourceusageaggregation.FieldResourceID)
	}
	if m.owner_id != nil {
		fields = append(fields, resourceusageaggregation.FieldOwnerID)
	}
	if m.runner != nil {
		fields = append(fields, resourceusageaggregation.FieldRunnerID)
	}
	if m.granularity != nil {
		fields = append(fields, resourceusageaggregation.FieldGranularity)
	}
	if m.bucket_start != nil {
		fields = append(fields, resourceusageaggregation.FieldBucketStart)
	}
	if m.bucket_end != nil {
		fields = append(fields, resourceusageaggregation.FieldBucketEnd)
	}
	if m.cpu_core_seconds != nil {
		fields = append(fields, resourceusageaggregation.FieldCPUCoreSeconds)
	}
	if m.cpu_avg_percent != nil {
		fields = append(fields, resourceusageaggregation.FieldCPUAvgPercent)
	}
	if m.cpu_max_percent != nil {
		fields = append(fields, resourceusageaggregation.FieldCPUMaxPercent)
	}
	if m.memory_gb_seconds != nil {
		fields = append(fields, resourceusageaggregation.FieldMemoryGBSeconds)
	}
	if m.memory_avg_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldMemoryAvgBytes)
	}
	if m.memory_max_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldMemoryMaxBytes)
	}
	if m.network_rx_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldNetworkRxBytes)
	}
	if m.network_tx_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldNetworkTxBytes)
	}
	if m.block_read_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldBlockReadBytes)
	}
	if m.block_write_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldBlockWriteBytes)
	}
	if m.sample_count != nil {
		fields = append(fields, resourceusageaggregation.FieldSampleCount)
	}
	if m.created_at != nil {
		fields = append(fields, resourceusageaggregation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceUsageAggregationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourceusageaggregation.FieldDeletedAt:
		return m.DeletedAt()
	case resourceusageaggregation.FieldResourceType:
		return m.ResourceType()
	case resourceusageaggregation.FieldResourceID:
		return m.ResourceID()
	case resourceusageaggregation.FieldOwnerID:
		return m.OwnerID()
	case resourceusageaggregation.FieldRunnerID:
		return m.RunnerID()
	case resourceusageaggregation.FieldGranularity:
		return m.Granularity()
	case resourceusageaggregation.FieldBucketStart:
		return m.BucketStart()
	case resourceusageaggregation.FieldBucketEnd:
		return m.BucketEnd()
	case resourceusageaggregation.FieldCPUCoreSeconds:
		return m.CPUCoreSeconds()
	case resourceusageaggregation.FieldCPUAvgPercent:
		return m.CPUAvgPercent()
	case resourceusageaggregation.FieldCPUMaxPercent:
		return m.CPUMaxPercent()
	case resourceusageaggregation.FieldMemoryGBSeconds:
		return m.MemoryGBSeconds()
	case resourceusageaggregation.FieldMemoryAvgBytes:
		return m.MemoryAvgBytes()
	case resourceusageaggregation.FieldMemoryMaxBytes:
		return m.MemoryMaxBytes()
	case resourceusageaggregation.FieldNetworkRxBytes:
		return m.NetworkRxBytes()
	case resourceusageaggregation.FieldNetworkTxBytes:
		return m.NetworkTxBytes()
	case resourceusageaggregation.FieldBlockReadBytes:
		return m.BlockReadBytes()
	case resourceusageaggregation.FieldBlockWriteBytes:
		return m.BlockWriteBytes()
	case resourceusageaggregation.FieldSampleCount:
		return m.SampleCount()
	case resourceusageaggregation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceUsageAggregationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourceusageaggregation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resourceusageaggregation.FieldResourceType:
		return m.OldResourceType(ctx)
	case resourceusageaggregation.FieldResourceID:
		return m.OldResourceID(ctx)
	case resourceusageaggregation.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case resourceusageaggregation.FieldRunnerID:
		return m.OldRunnerID(ctx)
	case resourceusageaggregation.FieldGranularity:
		return m.OldGranularity(ctx)
	case resourceusageaggregation.FieldBucketStart:
		return m.OldBucketStart(ctx)
	case resourceusageaggregation.FieldBucketEnd:
		return m.OldBucketEnd(ctx)
	case resourceusageaggregation.FieldCPUCoreSeconds:
		return m.OldCPUCoreSeconds(ctx)
	case resourceusageaggregation.FieldCPUAvgPercent:
		return m.OldCPUAvgPercent(ctx)
	case resourceusageaggregation.FieldCPUMaxPercent:
		return m.OldCPUMaxPercent(ctx)
	case resourceusageaggregation.FieldMemoryGBSeconds:
		return m.OldMemoryGBSeconds(ctx)
	case resourceusageaggregation.FieldMemoryAvgBytes:
		return m.OldMemoryAvgBytes(ctx)
	case resourceusageaggregation.FieldMemoryMaxBytes:
		return m.OldMemoryMaxBytes(ctx)
	case resourceusageaggregation.FieldNetworkRxBytes:
		return m.OldNetworkRxBytes(ctx)
	case resourceusageaggregation.FieldNetworkTxBytes:
		return m.OldNetworkTxBytes(ctx)
	case resourceusageaggregation.FieldBlockReadBytes:
		return m.OldBlockReadBytes(ctx)
	case resourceusageaggregation.FieldBlockWriteBytes:
		return m.OldBlockWriteBytes(ctx)
	case resourceusageaggregation.FieldSampleCount:
		return m.OldSampleCount(ctx)
	case resourceusageaggregation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceUsageAggregation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceUsageAggregationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourceusageaggregation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resourceusageaggregation.FieldResourceType:
		v, ok := value.(enum.ResourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case resourceusageaggregation.FieldResourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case resourceusageaggregation.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case resourceusageaggregation.FieldRunnerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunnerID(v)
		return nil
	case resourceusageaggregation.FieldGranularity:
		v, ok := value.(enum.AggregationGranularity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGranularity(v)
		return nil
	case resourceusageaggregation.FieldBucketStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketStart(v)
		return nil
	case resourceusageaggregation.FieldBucketEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketEnd(v)
		return nil
	case resourceusageaggregation.FieldCPUCoreSeconds:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCoreSeconds(v)
		return nil
	case resourceusageaggregation.FieldCPUAvgPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUAvgPercent(v)
		return nil
	case resourceusageaggregation.FieldCPUMaxPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUMaxPercent(v)
		return nil
	case resourceusageaggregation.FieldMemoryGBSeconds:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemoryGBSeconds(v)
		return nil
	case resourceusageaggregation.FieldMemoryAvgBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemoryAvgBytes(v)
		return nil
	case resourceusageaggregation.FieldMemoryMaxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemoryMaxBytes(v)
		return nil
	case resourceusageaggregation.FieldNetworkRxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkRxBytes(v)
		return nil
	case resourceusageaggregation.FieldNetworkTxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkTxBytes(v)
		return nil
	case resourceusageaggregation.FieldBlockReadBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockReadBytes(v)
		return nil
	case resourceusageaggregation.FieldBlockWriteBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockWriteBytes(v)
		return nil
	case resourceusageaggregation.FieldSampleCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleCount(v)
		return nil
	case resourceusageaggregation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageAggregation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceUsageAggregationMutation) AddedFields() []string {
	var fields []string
	if m.addcpu_core_seconds != nil {
		fields = append(fields, resourceusageaggregation.FieldCPUCoreSeconds)
	}
	if m.addcpu_avg_percent != nil {
		fields = append(fields, resourceusageaggregation.FieldCPUAvgPercent)
	}
	if m.addcpu_max_percent != nil {
		fields = append(fields, resourceusageaggregation.FieldCPUMaxPercent)
	}
	if m.addmemory_gb_seconds != nil {
		fields = append(fields, resourceusageaggregation.FieldMemoryGBSeconds)
	}
	if m.addmemory_avg_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldMemoryAvgBytes)
	}
	if m.addmemory_max_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldMemoryMaxBytes)
	}
	if m.addnetwork_rx_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldNetworkRxBytes)
	}
	if m.addnetwork_tx_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldNetworkTxBytes)
	}
	if m.addblock_read_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldBlockReadBytes)
	}
	if m.addblock_write_bytes != nil {
		fields = append(fields, resourceusageaggregation.FieldBlockWriteBytes)
	}
	if m.addsample_count != nil {
		fields = append(fields, resourceusageaggregation.FieldSampleCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceUsageAggregationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resourceusageaggregation.FieldCPUCoreSeconds:
		return m.AddedCPUCoreSeconds()
	case resourceusageaggregation.FieldCPUAvgPercent:
		return m.AddedCPUAvgPercent()
	case resourceusageaggregation.FieldCPUMaxPercent:
		return m.AddedCPUMaxPercent()
	case resourceusageaggregation.FieldMemoryGBSeconds:
		return m.AddedMemoryGBSeconds()
	case resourceusageaggregation.FieldMemoryAvgBytes:
		return m.AddedMemoryAvgBytes()
	case resourceusageaggregation.FieldMemoryMaxBytes:
		return m.AddedMemoryMaxBytes()
	case resourceusageaggregation.FieldNetworkRxBytes:
		return m.AddedNetworkRxBytes()
	case resourceusageaggregation.FieldNetworkTxBytes:
		return m.AddedNetworkTxBytes()
	case resourceusageaggregation.FieldBlockReadBytes:
		return m.AddedBlockReadBytes()
	case resourceusageaggregation.FieldBlockWriteBytes:
		return m.AddedBlockWriteBytes()
	case resourceusageaggregation.FieldSampleCount:
		return m.AddedSampleCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceUsageAggregationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resourceusageaggregation.FieldCPUCoreSeconds:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCoreSeconds(v)
		return nil
	case resourceusageaggregation.FieldCPUAvgPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUAvgPercent(v)
		return nil
	case resourceusageaggregation.FieldCPUMaxPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUMaxPercent(v)
		return nil
	case resourceusageaggregation.FieldMemoryGBSeconds:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemoryGBSeconds(v)
		return nil
	case resourceusageaggregation.FieldMemoryAvgBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemoryAvgBytes(v)
		return nil
	case resourceusageaggregation.FieldMemoryMaxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemoryMaxBytes(v)
		return nil
	case resourceusageaggregation.FieldNetworkRxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetworkRxBytes(v)
		return nil
	case resourceusageaggregation.FieldNetworkTxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetworkTxBytes(v)
		return nil
	case resourceusageaggregation.FieldBlockReadBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockReadBytes(v)
		return nil
	case resourceusageaggregation.FieldBlockWriteBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockWriteBytes(v)
		return nil
	case resourceusageaggregation.FieldSampleCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSampleCount(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageAggregation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceUsageAggregationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourceusageaggregation.FieldDeletedAt) {
		fields = append(fields, resourceusageaggregation.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceUsageAggregationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceUsageAggregationMutation) ClearField(name string) error {
	switch name {
	case resourceusageaggregation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageAggregation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceUsageAggregationMutation) ResetField(name string) error {
	switch name {
	case resourceusageaggregation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resourceusageaggregation.FieldResourceType:
		m.ResetResourceType()
		return nil
	case resourceusageaggregation.FieldResourceID:
		m.ResetResourceID()
		return nil
	case resourceusageaggregation.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case resourceusageaggregation.FieldRunnerID:
		m.ResetRunnerID()
		return nil
	case resourceusageaggregation.FieldGranularity:
		m.ResetGranularity()
		return nil
	case resourceusageaggregation.FieldBucketStart:
		m.ResetBucketStart()
		return nil
	case resourceusageaggregation.FieldBucketEnd:
		m.ResetBucketEnd()
		return nil
	case resourceusageaggregation.FieldCPUCoreSeconds:
		m.ResetCPUCoreSeconds()
		return nil
	case resourceusageaggregation.FieldCPUAvgPercent:
		m.ResetCPUAvgPercent()
		return nil
	case resourceusageaggregation.FieldCPUMaxPercent:
		m.ResetCPUMaxPercent()
		return nil
	case resourceusageaggregation.FieldMemoryGBSeconds:
		m.ResetMemoryGBSeconds()
		return nil
	case resourceusageaggregation.FieldMemoryAvgBytes:
		m.ResetMemoryAvgBytes()
		return nil
	case resourceusageaggregation.FieldMemoryMaxBytes:
		m.ResetMemoryMaxBytes()
		return nil
	case resourceusageaggregation.FieldNetworkRxBytes:
		m.ResetNetworkRxBytes()
		return nil
	case resourceusageaggregation.FieldNetworkTxBytes:
		m.ResetNetworkTxBytes()
		return nil
	case resourceusageaggregation.FieldBlockReadBytes:
		m.ResetBlockReadBytes()
		return nil
	case resourceusageaggregation.FieldBlockWriteBytes:
		m.ResetBlockWriteBytes()
		return nil
	case resourceusageaggregation.FieldSampleCount:
		m.ResetSampleCount()
		return nil
	case resourceusageaggregation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageAggregation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceUsageAggregationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.runner != nil {
		edges = append(edges, resourceusageaggregation.EdgeRunner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceUsageAggregationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourceusageaggregation.EdgeRunner:
		if id := m.runner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceUsageAggregationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceUsageAggregationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceUsageAggregationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrunner {
		edges = append(edges, resourceusageaggregation.EdgeRunner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceUsageAggregationMutation) EdgeCleared(name string) bool {
	switch name {
	case resourceusageaggregation.EdgeRunner:
		return m.clearedrunner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceUsageAggregationMutation) ClearEdge(name string) error {
	switch name {
	case resourceusageaggregation.EdgeRunner:
		m.ClearRunner()
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageAggregation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceUsageAggregationMutation) ResetEdge(name string) error {
	switch name {
	case resourceusageaggregation.EdgeRunner:
		m.ResetRunner()
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageAggregation edge %s", name)
}

// ResourceUsageSampleMutation represents an operation that mutates the ResourceUsageSample nodes in the graph.
type ResourceUsageSampleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	deleted_at           *time.Time
	resource_type        *enum.ResourceType
	resource_id          *uuid.UUID
	owner_id             *string
	cpu_percent          *float64
	addcpu_percent       *float64
	memory_bytes         *int64
	addmemory_bytes      *int64
	network_rx_bytes     *int64
	addnetwork_rx_bytes  *int64
	network_tx_bytes     *int64
	addnetwork_tx_bytes  *int64
	block_read_bytes     *int64
	addblock_read_bytes  *int64
	block_write_bytes    *int64
	addblock_write_bytes *int64
	sampled_at           *time.Time
	created_at           *time.Time
	clearedFields        map[string]struct{}
	runner               *uuid.UUID
	clearedrunner        bool
	done                 bool
	oldValue             func(context.Context) (*ResourceUsageSample, error)
	predicates           []predicate.ResourceUsageSample
}

var _ ent.Mutation = (*ResourceUsageSampleMutation)(nil)

// resourceusagesampleOption allows management of the mutation configuration using functional options.
type resourceusagesampleOption func(*ResourceUsageSampleMutation)

// newResourceUsageSampleMutation creates new mutation for the ResourceUsageSample entity.
func newResourceUsageSampleMutation(c config, op Op, opts ...resourceusagesampleOption) *ResourceUsageSampleMutation {
	m := &ResourceUsageSampleMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceUsageSample,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceUsageSampleID sets the ID field of the mutation.
func withResourceUsageSampleID(id uuid.UUID) resourceusagesampleOption {
	return func(m *ResourceUsageSampleMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceUsageSample
		)
		m.oldValue = func(ctx context.Context) (*ResourceUsageSample, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceUsageSample.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceUsageSample sets the old ResourceUsageSample of the mutation.
func withResourceUsageSample(node *ResourceUsageSample) resourceusagesampleOption {
	return func(m *ResourceUsageSampleMutation) {
		m.oldValue = func(context.Context) (*ResourceUsageSample, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceUsageSampleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceUsageSampleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceUsageSample entities.
func (m *ResourceUsageSampleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceUsageSampleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceUsageSampleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceUsageSample.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResourceUsageSampleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResourceUsageSampleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResourceUsageSampleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resourceusagesample.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResourceUsageSampleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resourceusagesample.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResourceUsageSampleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resourceusagesample.FieldDeletedAt)
}

// SetResourceType sets the "resource_type" field.
func (m *ResourceUsageSampleMutation) SetResourceType(et enum.ResourceType) {
	m.resource_type = &et
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *ResourceUsageSampleMutation) ResourceType() (r enum.ResourceType, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldResourceType(ctx context.Context) (v enum.ResourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *ResourceUsageSampleMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *ResourceUsageSampleMutation) SetResourceID(u uuid.UUID) {
	m.resource_id = &u
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ResourceUsageSampleMutation) ResourceID() (r uuid.UUID, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldResourceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ResourceUsageSampleMutation) ResetResourceID() {
	m.resource_id = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *ResourceUsageSampleMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ResourceUsageSampleMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ResourceUsageSampleMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetRunnerID sets the "runner_id" field.
func (m *ResourceUsageSampleMutation) SetRunnerID(u uuid.UUID) {
	m.runner = &u
}

// RunnerID returns the value of the "runner_id" field in the mutation.
func (m *ResourceUsageSampleMutation) RunnerID() (r uuid.UUID, exists bool) {
	v := m.runner
	if v == nil {
		return
	}
	return *v, true
}

// OldRunnerID returns the old "runner_id" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldRunnerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunnerID: %w", err)
	}
	return oldValue.RunnerID, nil
}

// ResetRunnerID resets all changes to the "runner_id" field.
func (m *ResourceUsageSampleMutation) ResetRunnerID() {
	m.runner = nil
}

// SetCPUPercent sets the "cpu_percent" field.
func (m *ResourceUsageSampleMutation) SetCPUPercent(f float64) {
	m.cpu_percent = &f
	m.addcpu_percent = nil
}

// CPUPercent returns the value of the "cpu_percent" field in the mutation.
func (m *ResourceUsageSampleMutation) CPUPercent() (r float64, exists bool) {
	v := m.cpu_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUPercent returns the old "cpu_percent" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldCPUPercent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUPercent: %w", err)
	}
	return oldValue.CPUPercent, nil
}

// AddCPUPercent adds f to the "cpu_percent" field.
func (m *ResourceUsageSampleMutation) AddCPUPercent(f float64) {
	if m.addcpu_percent != nil {
		*m.addcpu_percent += f
	} else {
		m.addcpu_percent = &f
	}
}

// AddedCPUPercent returns the value that was added to the "cpu_percent" field in this mutation.
func (m *ResourceUsageSampleMutation) AddedCPUPercent() (r float64, exists bool) {
	v := m.addcpu_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUPercent resets all changes to the "cpu_percent" field.
func (m *ResourceUsageSampleMutation) ResetCPUPercent() {
	m.cpu_percent = nil
	m.addcpu_percent = nil
}

// SetMemoryBytes sets the "memory_bytes" field.
func (m *ResourceUsageSampleMutation) SetMemoryBytes(i int64) {
	m.memory_bytes = &i
	m.addmemory_bytes = nil
}

// MemoryBytes returns the value of the "memory_bytes" field in the mutation.
func (m *ResourceUsageSampleMutation) MemoryBytes() (r int64, exists bool) {
	v := m.memory_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldMemoryBytes returns the old "memory_bytes" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldMemoryBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemoryBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemoryBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemoryBytes: %w", err)
	}
	return oldValue.MemoryBytes, nil
}

// AddMemoryBytes adds i to the "memory_bytes" field.
func (m *ResourceUsageSampleMutation) AddMemoryBytes(i int64) {
	if m.addmemory_bytes != nil {
		*m.addmemory_bytes += i
	} else {
		m.addmemory_bytes = &i
	}
}

// AddedMemoryBytes returns the value that was added to the "memory_bytes" field in this mutation.
func (m *ResourceUsageSampleMutation) AddedMemoryBytes() (r int64, exists bool) {
	v := m.addmemory_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemoryBytes resets all changes to the "memory_bytes" field.
func (m *ResourceUsageSampleMutation) ResetMemoryBytes() {
	m.memory_bytes = nil
	m.addmemory_bytes = nil
}

// SetNetworkRxBytes sets the "network_rx_bytes" field.
func (m *ResourceUsageSampleMutation) SetNetworkRxBytes(i int64) {
	m.network_rx_bytes = &i
	m.addnetwork_rx_bytes = nil
}

// NetworkRxBytes returns the value of the "network_rx_bytes" field in the mutation.
func (m *ResourceUsageSampleMutation) NetworkRxBytes() (r int64, exists bool) {
	v := m.network_rx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkRxBytes returns the old "network_rx_bytes" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldNetworkRxBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetworkRxBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetworkRxBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkRxBytes: %w", err)
	}
	return oldValue.NetworkRxBytes, nil
}

// AddNetworkRxBytes adds i to the "network_rx_bytes" field.
func (m *ResourceUsageSampleMutation) AddNetworkRxBytes(i int64) {
	if m.addnetwork_rx_bytes != nil {
		*m.addnetwork_rx_bytes += i
	} else {
		m.addnetwork_rx_bytes = &i
	}
}

// AddedNetworkRxBytes returns the value that was added to the "network_rx_bytes" field in this mutation.
func (m *ResourceUsageSampleMutation) AddedNetworkRxBytes() (r int64, exists bool) {
	v := m.addnetwork_rx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetNetworkRxBytes resets all changes to the "network_rx_bytes" field.
func (m *ResourceUsageSampleMutation) ResetNetworkRxBytes() {
	m.network_rx_bytes = nil
	m.addnetwork_rx_bytes = nil
}

// SetNetworkTxBytes sets the "network_tx_bytes" field.
func (m *ResourceUsageSampleMutation) SetNetworkTxBytes(i int64) {
	m.network_tx_bytes = &i
	m.addnetwork_tx_bytes = nil
}

// NetworkTxBytes returns the value of the "network_tx_bytes" field in the mutation.
func (m *ResourceUsageSampleMutation) NetworkTxBytes() (r int64, exists bool) {
	v := m.network_tx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkTxBytes returns the old "network_tx_bytes" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldNetworkTxBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetworkTxBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetworkTxBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkTxBytes: %w", err)
	}
	return oldValue.NetworkTxBytes, nil
}

// AddNetworkTxBytes adds i to the "network_tx_bytes" field.
func (m *ResourceUsageSampleMutation) AddNetworkTxBytes(i int64) {
	if m.addnetwork_tx_bytes != nil {
		*m.addnetwork_tx_bytes += i
	} else {
		m.addnetwork_tx_bytes = &i
	}
}

// AddedNetworkTxBytes returns the value that was added to the "network_tx_bytes" field in this mutation.
func (m *ResourceUsageSampleMutation) AddedNetworkTxBytes() (r int64, exists bool) {
	v := m.addnetwork_tx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetNetworkTxBytes resets all changes to the "network_tx_bytes" field.
func (m *ResourceUsageSampleMutation) ResetNetworkTxBytes() {
	m.network_tx_bytes = nil
	m.addnetwork_tx_bytes = nil
}

// SetBlockReadBytes sets the "block_read_bytes" field.
func (m *ResourceUsageSampleMutation) SetBlockReadBytes(i int64) {
	m.block_read_bytes = &i
	m.addblock_read_bytes = nil
}

// BlockReadBytes returns the value of the "block_read_bytes" field in the mutation.
func (m *ResourceUsageSampleMutation) BlockReadBytes() (r int64, exists bool) {
	v := m.block_read_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockReadBytes returns the old "block_read_bytes" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldBlockReadBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockReadBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockReadBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockReadBytes: %w", err)
	}
	return oldValue.BlockReadBytes, nil
}

// AddBlockReadBytes adds i to the "block_read_bytes" field.
func (m *ResourceUsageSampleMutation) AddBlockReadBytes(i int64) {
	if m.addblock_read_bytes != nil {
		*m.addblock_read_bytes += i
	} else {
		m.addblock_read_bytes = &i
	}
}

// AddedBlockReadBytes returns the value that was added to the "block_read_bytes" field in this mutation.
func (m *ResourceUsageSampleMutation) AddedBlockReadBytes() (r int64, exists bool) {
	v := m.addblock_read_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockReadBytes resets all changes to the "block_read_bytes" field.
func (m *ResourceUsageSampleMutation) ResetBlockReadBytes() {
	m.block_read_bytes = nil
	m.addblock_read_bytes = nil
}

// SetBlockWriteBytes sets the "block_write_bytes" field.
func (m *ResourceUsageSampleMutation) SetBlockWriteBytes(i int64) {
	m.block_write_bytes = &i
	m.addblock_write_bytes = nil
}

// BlockWriteBytes returns the value of the "block_write_bytes" field in the mutation.
func (m *ResourceUsageSampleMutation) BlockWriteBytes() (r int64, exists bool) {
	v := m.block_write_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockWriteBytes returns the old "block_write_bytes" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldBlockWriteBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockWriteBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockWriteBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockWriteBytes: %w", err)
	}
	return oldValue.BlockWriteBytes, nil
}

// AddBlockWriteBytes adds i to the "block_write_bytes" field.
func (m *ResourceUsageSampleMutation) AddBlockWriteBytes(i int64) {
	if m.addblock_write_bytes != nil {
		*m.addblock_write_bytes += i
	} else {
		m.addblock_write_bytes = &i
	}
}

// AddedBlockWriteBytes returns the value that was added to the "block_write_bytes" field in this mutation.
func (m *ResourceUsageSampleMutation) AddedBlockWriteBytes() (r int64, exists bool) {
	v := m.addblock_write_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockWriteBytes resets all changes to the "block_write_bytes" field.
func (m *ResourceUsageSampleMutation) ResetBlockWriteBytes() {
	m.block_write_bytes = nil
	m.addblock_write_bytes = nil
}

// SetSampledAt sets the "sampled_at" field.
func (m *ResourceUsageSampleMutation) SetSampledAt(t time.Time) {
	m.sampled_at = &t
}

// SampledAt returns the value of the "sampled_at" field in the mutation.
func (m *ResourceUsageSampleMutation) SampledAt() (r time.Time, exists bool) {
	v := m.sampled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSampledAt returns the old "sampled_at" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldSampledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampledAt: %w", err)
	}
	return oldValue.SampledAt, nil
}

// ResetSampledAt resets all changes to the "sampled_at" field.
func (m *ResourceUsageSampleMutation) ResetSampledAt() {
	m.sampled_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceUsageSampleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceUsageSampleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResourceUsageSample entity.
// If the ResourceUsageSample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceUsageSampleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceUsageSampleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearRunner clears the "runner" edge to the BotRunner entity.
func (m *ResourceUsageSampleMutation) ClearRunner() {
	m.clearedrunner = true
	m.clearedFields[resourceusagesample.FieldRunnerID] = struct{}{}
}

// RunnerCleared reports if the "runner" edge to the BotRunner entity was cleared.
func (m *ResourceUsageSampleMutation) RunnerCleared() bool {
	return m.clearedrunner
}

// RunnerIDs returns the "runner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunnerID instead. It exists only for internal usage by the builders.
func (m *ResourceUsageSampleMutation) RunnerIDs() (ids []uuid.UUID) {
	if id := m.runner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRunner resets all changes to the "runner" edge.
func (m *ResourceUsageSampleMutation) ResetRunner() {
	m.runner = nil
	m.clearedrunner = false
}

// Where appends a list predicates to the ResourceUsageSampleMutation builder.
func (m *ResourceUsageSampleMutation) Where(ps ...predicate.ResourceUsageSample) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceUsageSampleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceUsageSampleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceUsageSample, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceUsageSampleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceUsageSampleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceUsageSample).
func (m *ResourceUsageSampleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceUsageSampleMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.deleted_at != nil {
		fields = append(fields, resourceusagesample.FieldDeletedAt)
	}
	if m.resource_type != nil {
		fields = append(fields, resourceusagesample.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, resourceusagesample.FieldResourceID)
	}
	if m.owner_id != nil {
		fields = append(fields, resourceusagesample.FieldOwnerID)
	}
	if m.runner != nil {
		fields = append(fields, resourceusagesample.FieldRunnerID)
	}
	if m.cpu_percent != nil {
		fields = append(fields, resourceusagesample.FieldCPUPercent)
	}
	if m.memory_bytes != nil {
		fields = append(fields, resourceusagesample.FieldMemoryBytes)
	}
	if m.network_rx_bytes != nil {
		fields = append(fields, resourceusagesample.FieldNetworkRxBytes)
	}
	if m.network_tx_bytes != nil {
		fields = append(fields, resourceusagesample.FieldNetworkTxBytes)
	}
	if m.block_read_bytes != nil {
		fields = append(fields, resourceusagesample.FieldBlockReadBytes)
	}
	if m.block_write_bytes != nil {
		fields = append(fields, resourceusagesample.FieldBlockWriteBytes)
	}
	if m.sampled_at != nil {
		fields = append(fields, resourceusagesample.FieldSampledAt)
	}
	if m.created_at != nil {
		fields = append(fields, resourceusagesample.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceUsageSampleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourceusagesample.FieldDeletedAt:
		return m.DeletedAt()
	case resourceusagesample.FieldResourceType:
		return m.ResourceType()
	case resourceusagesample.FieldResourceID:
		return m.ResourceID()
	case resourceusagesample.FieldOwnerID:
		return m.OwnerID()
	case resourceusagesample.FieldRunnerID:
		return m.RunnerID()
	case resourceusagesample.FieldCPUPercent:
		return m.CPUPercent()
	case resourceusagesample.FieldMemoryBytes:
		return m.MemoryBytes()
	case resourceusagesample.FieldNetworkRxBytes:
		return m.NetworkRxBytes()
	case resourceusagesample.FieldNetworkTxBytes:
		return m.NetworkTxBytes()
	case resourceusagesample.FieldBlockReadBytes:
		return m.BlockReadBytes()
	case resourceusagesample.FieldBlockWriteBytes:
		return m.BlockWriteBytes()
	case resourceusagesample.FieldSampledAt:
		return m.SampledAt()
	case resourceusagesample.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceUsageSampleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourceusagesample.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resourceusagesample.FieldResourceType:
		return m.OldResourceType(ctx)
	case resourceusagesample.FieldResourceID:
		return m.OldResourceID(ctx)
	case resourceusagesample.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case resourceusagesample.FieldRunnerID:
		return m.OldRunnerID(ctx)
	case resourceusagesample.FieldCPUPercent:
		return m.OldCPUPercent(ctx)
	case resourceusagesample.FieldMemoryBytes:
		return m.OldMemoryBytes(ctx)
	case resourceusagesample.FieldNetworkRxBytes:
		return m.OldNetworkRxBytes(ctx)
	case resourceusagesample.FieldNetworkTxBytes:
		return m.OldNetworkTxBytes(ctx)
	case resourceusagesample.FieldBlockReadBytes:
		return m.OldBlockReadBytes(ctx)
	case resourceusagesample.FieldBlockWriteBytes:
		return m.OldBlockWriteBytes(ctx)
	case resourceusagesample.FieldSampledAt:
		return m.OldSampledAt(ctx)
	case resourceusagesample.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceUsageSample field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceUsageSampleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourceusagesample.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resourceusagesample.FieldResourceType:
		v, ok := value.(enum.ResourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case resourceusagesample.FieldResourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case resourceusagesample.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case resourceusagesample.FieldRunnerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunnerID(v)
		return nil
	case resourceusagesample.FieldCPUPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUPercent(v)
		return nil
	case resourceusagesample.FieldMemoryBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemoryBytes(v)
		return nil
	case resourceusagesample.FieldNetworkRxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkRxBytes(v)
		return nil
	case resourceusagesample.FieldNetworkTxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkTxBytes(v)
		return nil
	case resourceusagesample.FieldBlockReadBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockReadBytes(v)
		return nil
	case resourceusagesample.FieldBlockWriteBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockWriteBytes(v)
		return nil
	case resourceusagesample.FieldSampledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampledAt(v)
		return nil
	case resourceusagesample.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageSample field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceUsageSampleMutation) AddedFields() []string {
	var fields []string
	if m.addcpu_percent != nil {
		fields = append(fields, resourceusagesample.FieldCPUPercent)
	}
	if m.addmemory_bytes != nil {
		fields = append(fields, resourceusagesample.FieldMemoryBytes)
	}
	if m.addnetwork_rx_bytes != nil {
		fields = append(fields, resourceusagesample.FieldNetworkRxBytes)
	}
	if m.addnetwork_tx_bytes != nil {
		fields = append(fields, resourceusagesample.FieldNetworkTxBytes)
	}
	if m.addblock_read_bytes != nil {
		fields = append(fields, resourceusagesample.FieldBlockReadBytes)
	}
	if m.addblock_write_bytes != nil {
		fields = append(fields, resourceusagesample.FieldBlockWriteBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceUsageSampleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resourceusagesample.FieldCPUPercent:
		return m.AddedCPUPercent()
	case resourceusagesample.FieldMemoryBytes:
		return m.AddedMemoryBytes()
	case resourceusagesample.FieldNetworkRxBytes:
		return m.AddedNetworkRxBytes()
	case resourceusagesample.FieldNetworkTxBytes:
		return m.AddedNetworkTxBytes()
	case resourceusagesample.FieldBlockReadBytes:
		return m.AddedBlockReadBytes()
	case resourceusagesample.FieldBlockWriteBytes:
		return m.AddedBlockWriteBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceUsageSampleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resourceusagesample.FieldCPUPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUPercent(v)
		return nil
	case resourceusagesample.FieldMemoryBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemoryBytes(v)
		return nil
	case resourceusagesample.FieldNetworkRxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetworkRxBytes(v)
		return nil
	case resourceusagesample.FieldNetworkTxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetworkTxBytes(v)
		return nil
	case resourceusagesample.FieldBlockReadBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockReadBytes(v)
		return nil
	case resourceusagesample.FieldBlockWriteBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockWriteBytes(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageSample numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceUsageSampleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourceusagesample.FieldDeletedAt) {
		fields = append(fields, resourceusagesample.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceUsageSampleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceUsageSampleMutation) ClearField(name string) error {
	switch name {
	case resourceusagesample.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageSample nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceUsageSampleMutation) ResetField(name string) error {
	switch name {
	case resourceusagesample.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resourceusagesample.FieldResourceType:
		m.ResetResourceType()
		return nil
	case resourceusagesample.FieldResourceID:
		m.ResetResourceID()
		return nil
	case resourceusagesample.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case resourceusagesample.FieldRunnerID:
		m.ResetRunnerID()
		return nil
	case resourceusagesample.FieldCPUPercent:
		m.ResetCPUPercent()
		return nil
	case resourceusagesample.FieldMemoryBytes:
		m.ResetMemoryBytes()
		return nil
	case resourceusagesample.FieldNetworkRxBytes:
		m.ResetNetworkRxBytes()
		return nil
	case resourceusagesample.FieldNetworkTxBytes:
		m.ResetNetworkTxBytes()
		return nil
	case resourceusagesample.FieldBlockReadBytes:
		m.ResetBlockReadBytes()
		return nil
	case resourceusagesample.FieldBlockWriteBytes:
		m.ResetBlockWriteBytes()
		return nil
	case resourceusagesample.FieldSampledAt:
		m.ResetSampledAt()
		return nil
	case resourceusagesample.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageSample field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceUsageSampleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.runner != nil {
		edges = append(edges, resourceusagesample.EdgeRunner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceUsageSampleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourceusagesample.EdgeRunner:
		if id := m.runner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceUsageSampleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceUsageSampleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceUsageSampleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrunner {
		edges = append(edges, resourceusagesample.EdgeRunner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceUsageSampleMutation) EdgeCleared(name string) bool {
	switch name {
	case resourceusagesample.EdgeRunner:
		return m.clearedrunner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceUsageSampleMutation) ClearEdge(name string) error {
	switch name {
	case resourceusagesample.EdgeRunner:
		m.ClearRunner()
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageSample unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceUsageSampleMutation) ResetEdge(name string) error {
	switch name {
	case resourceusagesample.EdgeRunner:
		m.ResetRunner()
		return nil
	}
	return fmt.Errorf("unknown ResourceUsageSample edge %s", name)
}

// StrategyMutation represents an operation that mutates the Strategy nodes in the graph.
type StrategyMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	public            *bool
	deleted_at        *time.Time
	name              *string
	description       *string
	code              *string
	_config           *map[string]interface{}
	builder_mode      *enum.StrategyBuilderMode
	is_latest         *bool
	version_number    *int
	addversion_number *int
	owner_id          *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	bots              map[uuid.UUID]struct{}
	removedbots       map[uuid.UUID]struct{}
	clearedbots       bool
	backtest          *uuid.UUID
	clearedbacktest   bool
	children          map[uuid.UUID]struct{}
	removedchildren   map[uuid.UUID]struct{}
	clearedchildren   bool
	parent            *uuid.UUID
	clearedparent     bool
	done              bool
	oldValue          func(context.Context) (*Strategy, error)
	predicates        []predicate.Strategy
}

var _ ent.Mutation = (*StrategyMutation)(nil)

// strategyOption allows management of the mutation configuration using functional options.
type strategyOption func(*StrategyMutation)

// newStrategyMutation creates new mutation for the Strategy entity.
func newStrategyMutation(c config, op Op, opts ...strategyOption) *StrategyMutation {
	m := &StrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyID sets the ID field of the mutation.
func withStrategyID(id uuid.UUID) strategyOption {
	return func(m *StrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *Strategy
		)
		m.oldValue = func(ctx context.Context) (*Strategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Strategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategy sets the old Strategy of the mutation.
func withStrategy(node *Strategy) strategyOption {
	return func(m *StrategyMutation) {
		m.oldValue = func(context.Context) (*Strategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Strategy entities.
func (m *StrategyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Strategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublic sets the "public" field.
func (m *StrategyMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *StrategyMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *StrategyMutation) ResetPublic() {
	m.public = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StrategyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StrategyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StrategyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[strategy.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StrategyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[strategy.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StrategyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, strategy.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *StrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *StrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[strategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[strategy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, strategy.FieldDescription)
}

// SetCode sets the "code" field.
func (m *StrategyMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *StrategyMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *StrategyMutation) ResetCode() {
	m.code = nil
}

// SetConfig sets the "config" field.
func (m *StrategyMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *StrategyMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *StrategyMutation) ResetConfig() {
	m._config = nil
}

// SetBuilderMode sets the "builder_mode" field.
func (m *StrategyMutation) SetBuilderMode(ebm enum.StrategyBuilderMode) {
	m.builder_mode = &ebm
}

// BuilderMode returns the value of the "builder_mode" field in the mutation.
func (m *StrategyMutation) BuilderMode() (r enum.StrategyBuilderMode, exists bool) {
	v := m.builder_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldBuilderMode returns the old "builder_mode" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldBuilderMode(ctx context.Context) (v enum.StrategyBuilderMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuilderMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuilderMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuilderMode: %w", err)
	}
	return oldValue.BuilderMode, nil
}

// ResetBuilderMode resets all changes to the "builder_mode" field.
func (m *StrategyMutation) ResetBuilderMode() {
	m.builder_mode = nil
}

// SetParentID sets the "parent_id" field.
func (m *StrategyMutation) SetParentID(u uuid.UUID) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *StrategyMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldParentID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *StrategyMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[strategy.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *StrategyMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[strategy.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *StrategyMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, strategy.FieldParentID)
}

// SetIsLatest sets the "is_latest" field.
func (m *StrategyMutation) SetIsLatest(b bool) {
	m.is_latest = &b
}

// IsLatest returns the value of the "is_latest" field in the mutation.
func (m *StrategyMutation) IsLatest() (r bool, exists bool) {
	v := m.is_latest
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLatest returns the old "is_latest" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldIsLatest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLatest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLatest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLatest: %w", err)
	}
	return oldValue.IsLatest, nil
}

// ResetIsLatest resets all changes to the "is_latest" field.
func (m *StrategyMutation) ResetIsLatest() {
	m.is_latest = nil
}

// SetVersionNumber sets the "version_number" field.
func (m *StrategyMutation) SetVersionNumber(i int) {
	m.version_number = &i
	m.addversion_number = nil
}

// VersionNumber returns the value of the "version_number" field in the mutation.
func (m *StrategyMutation) VersionNumber() (r int, exists bool) {
	v := m.version_number
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionNumber returns the old "version_number" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldVersionNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionNumber: %w", err)
	}
	return oldValue.VersionNumber, nil
}

// AddVersionNumber adds i to the "version_number" field.
func (m *StrategyMutation) AddVersionNumber(i int) {
	if m.addversion_number != nil {
		*m.addversion_number += i
	} else {
		m.addversion_number = &i
	}
}

// AddedVersionNumber returns the value that was added to the "version_number" field in this mutation.
func (m *StrategyMutation) AddedVersionNumber() (r int, exists bool) {
	v := m.addversion_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionNumber resets all changes to the "version_number" field.
func (m *StrategyMutation) ResetVersionNumber() {
	m.version_number = nil
	m.addversion_number = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *StrategyMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *StrategyMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *StrategyMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StrategyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StrategyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StrategyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StrategyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StrategyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StrategyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBotIDs adds the "bots" edge to the Bot entity by ids.
func (m *StrategyMutation) AddBotIDs(ids ...uuid.UUID) {
	if m.bots == nil {
		m.bots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bots[ids[i]] = struct{}{}
	}
}

// ClearBots clears the "bots" edge to the Bot entity.
func (m *StrategyMutation) ClearBots() {
	m.clearedbots = true
}

// BotsCleared reports if the "bots" edge to the Bot entity was cleared.
func (m *StrategyMutation) BotsCleared() bool {
	return m.clearedbots
}

// RemoveBotIDs removes the "bots" edge to the Bot entity by IDs.
func (m *StrategyMutation) RemoveBotIDs(ids ...uuid.UUID) {
	if m.removedbots == nil {
		m.removedbots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bots, ids[i])
		m.removedbots[ids[i]] = struct{}{}
	}
}

// RemovedBots returns the removed IDs of the "bots" edge to the Bot entity.
func (m *StrategyMutation) RemovedBotsIDs() (ids []uuid.UUID) {
	for id := range m.removedbots {
		ids = append(ids, id)
	}
	return
}

// BotsIDs returns the "bots" edge IDs in the mutation.
func (m *StrategyMutation) BotsIDs() (ids []uuid.UUID) {
	for id := range m.bots {
		ids = append(ids, id)
	}
	return
}

// ResetBots resets all changes to the "bots" edge.
func (m *StrategyMutation) ResetBots() {
	m.bots = nil
	m.clearedbots = false
	m.removedbots = nil
}

// SetBacktestID sets the "backtest" edge to the Backtest entity by id.
func (m *StrategyMutation) SetBacktestID(id uuid.UUID) {
	m.backtest = &id
}

// ClearBacktest clears the "backtest" edge to the Backtest entity.
func (m *StrategyMutation) ClearBacktest() {
	m.clearedbacktest = true
}

// BacktestCleared reports if the "backtest" edge to the Backtest entity was cleared.
func (m *StrategyMutation) BacktestCleared() bool {
	return m.clearedbacktest
}

// BacktestID returns the "backtest" edge ID in the mutation.
func (m *StrategyMutation) BacktestID() (id uuid.UUID, exists bool) {
	if m.backtest != nil {
		return *m.backtest, true
	}
	return
}

// BacktestIDs returns the "backtest" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BacktestID instead. It exists only for internal usage by the builders.
func (m *StrategyMutation) BacktestIDs() (ids []uuid.UUID) {
	if id := m.backtest; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBacktest resets all changes to the "backtest" edge.
func (m *StrategyMutation) ResetBacktest() {
	m.backtest = nil
	m.clearedbacktest = false
}

// AddChildIDs adds the "children" edge to the Strategy entity by ids.
func (m *StrategyMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Strategy entity.
func (m *StrategyMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Strategy entity was cleared.
func (m *StrategyMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Strategy entity by IDs.
func (m *StrategyMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Strategy entity.
func (m *StrategyMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *StrategyMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *StrategyMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearParent clears the "parent" edge to the Strategy entity.
func (m *StrategyMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[strategy.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Strategy entity was cleared.
func (m *StrategyMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *StrategyMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *StrategyMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the StrategyMutation builder.
func (m *StrategyMutation) Where(ps ...predicate.Strategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Strategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Strategy).
func (m *StrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.public != nil {
		fields = append(fields, strategy.FieldPublic)
	}
	if m.deleted_at != nil {
		fields = append(fields, strategy.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, strategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, strategy.FieldDescription)
	}
	if m.code != nil {
		fields = append(fields, strategy.FieldCode)
	}
	if m._config != nil {
		fields = append(fields, strategy.FieldConfig)
	}
	if m.builder_mode != nil {
		fields = append(fields, strategy.FieldBuilderMode)
	}
	if m.parent != nil {
		fields = append(fields, strategy.FieldParentID)
	}
	if m.is_latest != nil {
		fields = append(fields, strategy.FieldIsLatest)
	}
	if m.version_number != nil {
		fields = append(fields, strategy.FieldVersionNumber)
	}
	if m.owner_id != nil {
		fields = append(fields, strategy.FieldOwnerID)
	}
	if m.created_at != nil {
		fields = append(fields, strategy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, strategy.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldPublic:
		return m.Public()
	case strategy.FieldDeletedAt:
		return m.DeletedAt()
	case strategy.FieldName:
		return m.Name()
	case strategy.FieldDescription:
		return m.Description()
	case strategy.FieldCode:
		return m.Code()
	case strategy.FieldConfig:
		return m.Config()
	case strategy.FieldBuilderMode:
		return m.BuilderMode()
	case strategy.FieldParentID:
		return m.ParentID()
	case strategy.FieldIsLatest:
		return m.IsLatest()
	case strategy.FieldVersionNumber:
		return m.VersionNumber()
	case strategy.FieldOwnerID:
		return m.OwnerID()
	case strategy.FieldCreatedAt:
		return m.CreatedAt()
	case strategy.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategy.FieldPublic:
		return m.OldPublic(ctx)
	case strategy.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case strategy.FieldName:
		return m.OldName(ctx)
	case strategy.FieldDescription:
		return m.OldDescription(ctx)
	case strategy.FieldCode:
		return m.OldCode(ctx)
	case strategy.FieldConfig:
		return m.OldConfig(ctx)
	case strategy.FieldBuilderMode:
		return m.OldBuilderMode(ctx)
	case strategy.FieldParentID:
		return m.OldParentID(ctx)
	case strategy.FieldIsLatest:
		return m.OldIsLatest(ctx)
	case strategy.FieldVersionNumber:
		return m.OldVersionNumber(ctx)
	case strategy.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case strategy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case strategy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Strategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case strategy.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case strategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case strategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case strategy.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case strategy.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case strategy.FieldBuilderMode:
		v, ok := value.(enum.StrategyBuilderMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuilderMode(v)
		return nil
	case strategy.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case strategy.FieldIsLatest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLatest(v)
		return nil
	case strategy.FieldVersionNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionNumber(v)
		return nil
	case strategy.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case strategy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case strategy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyMutation) AddedFields() []string {
	var fields []string
	if m.addversion_number != nil {
		fields = append(fields, strategy.FieldVersionNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldVersionNumber:
		return m.AddedVersionNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldVersionNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategy.FieldDeletedAt) {
		fields = append(fields, strategy.FieldDeletedAt)
	}
	if m.FieldCleared(strategy.FieldDescription) {
		fields = append(fields, strategy.FieldDescription)
	}
	if m.FieldCleared(strategy.FieldParentID) {
		fields = append(fields, strategy.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyMutation) ClearField(name string) error {
	switch name {
	case strategy.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case strategy.FieldDescription:
		m.ClearDescription()
		return nil
	case strategy.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Strategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyMutation) ResetField(name string) error {
	switch name {
	case strategy.FieldPublic:
		m.ResetPublic()
		return nil
	case strategy.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case strategy.FieldName:
		m.ResetName()
		return nil
	case strategy.FieldDescription:
		m.ResetDescription()
		return nil
	case strategy.FieldCode:
		m.ResetCode()
		return nil
	case strategy.FieldConfig:
		m.ResetConfig()
		return nil
	case strategy.FieldBuilderMode:
		m.ResetBuilderMode()
		return nil
	case strategy.FieldParentID:
		m.ResetParentID()
		return nil
	case strategy.FieldIsLatest:
		m.ResetIsLatest()
		return nil
	case strategy.FieldVersionNumber:
		m.ResetVersionNumber()
		return nil
	case strategy.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case strategy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case strategy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.bots != nil {
		edges = append(edges, strategy.EdgeBots)
	}
	if m.backtest != nil {
		edges = append(edges, strategy.EdgeBacktest)
	}
	if m.children != nil {
		edges = append(edges, strategy.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, strategy.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeBots:
		ids := make([]ent.Value, 0, len(m.bots))
		for id := range m.bots {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeBacktest:
		if id := m.backtest; id != nil {
			return []ent.Value{*id}
		}
	case strategy.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedbots != nil {
		edges = append(edges, strategy.EdgeBots)
	}
	if m.removedchildren != nil {
		edges = append(edges, strategy.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeBots:
		ids := make([]ent.Value, 0, len(m.removedbots))
		for id := range m.removedbots {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbots {
		edges = append(edges, strategy.EdgeBots)
	}
	if m.clearedbacktest {
		edges = append(edges, strategy.EdgeBacktest)
	}
	if m.clearedchildren {
		edges = append(edges, strategy.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, strategy.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyMutation) EdgeCleared(name string) bool {
	switch name {
	case strategy.EdgeBots:
		return m.clearedbots
	case strategy.EdgeBacktest:
		return m.clearedbacktest
	case strategy.EdgeChildren:
		return m.clearedchildren
	case strategy.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyMutation) ClearEdge(name string) error {
	switch name {
	case strategy.EdgeBacktest:
		m.ClearBacktest()
		return nil
	case strategy.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Strategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyMutation) ResetEdge(name string) error {
	switch name {
	case strategy.EdgeBots:
		m.ResetBots()
		return nil
	case strategy.EdgeBacktest:
		m.ResetBacktest()
		return nil
	case strategy.EdgeChildren:
		m.ResetChildren()
		return nil
	case strategy.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown Strategy edge %s", name)
}

// TradeMutation represents an operation that mutates the Trade nodes in the graph.
type TradeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	deleted_at            *time.Time
	freqtrade_trade_id    *int
	addfreqtrade_trade_id *int
	pair                  *string
	is_open               *bool
	open_date             *time.Time
	close_date            *time.Time
	open_rate             *float64
	addopen_rate          *float64
	close_rate            *float64
	addclose_rate         *float64
	amount                *float64
	addamount             *float64
	stake_amount          *float64
	addstake_amount       *float64
	profit_abs            *float64
	addprofit_abs         *float64
	profit_ratio          *float64
	addprofit_ratio       *float64
	sell_reason           *string
	strategy_name         *string
	timeframe             *string
	raw_data              *map[string]interface{}
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	bot                   *uuid.UUID
	clearedbot            bool
	done                  bool
	oldValue              func(context.Context) (*Trade, error)
	predicates            []predicate.Trade
}

var _ ent.Mutation = (*TradeMutation)(nil)

// tradeOption allows management of the mutation configuration using functional options.
type tradeOption func(*TradeMutation)

// newTradeMutation creates new mutation for the Trade entity.
func newTradeMutation(c config, op Op, opts ...tradeOption) *TradeMutation {
	m := &TradeMutation{
		config:        c,
		op:            op,
		typ:           TypeTrade,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTradeID sets the ID field of the mutation.
func withTradeID(id uuid.UUID) tradeOption {
	return func(m *TradeMutation) {
		var (
			err   error
			once  sync.Once
			value *Trade
		)
		m.oldValue = func(ctx context.Context) (*Trade, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trade.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrade sets the old Trade of the mutation.
func withTrade(node *Trade) tradeOption {
	return func(m *TradeMutation) {
		m.oldValue = func(context.Context) (*Trade, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TradeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TradeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Trade entities.
func (m *TradeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TradeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TradeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trade.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TradeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TradeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TradeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[trade.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TradeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[trade.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TradeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, trade.FieldDeletedAt)
}

// SetFreqtradeTradeID sets the "freqtrade_trade_id" field.
func (m *TradeMutation) SetFreqtradeTradeID(i int) {
	m.freqtrade_trade_id = &i
	m.addfreqtrade_trade_id = nil
}

// FreqtradeTradeID returns the value of the "freqtrade_trade_id" field in the mutation.
func (m *TradeMutation) FreqtradeTradeID() (r int, exists bool) {
	v := m.freqtrade_trade_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFreqtradeTradeID returns the old "freqtrade_trade_id" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldFreqtradeTradeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreqtradeTradeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreqtradeTradeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreqtradeTradeID: %w", err)
	}
	return oldValue.FreqtradeTradeID, nil
}

// AddFreqtradeTradeID adds i to the "freqtrade_trade_id" field.
func (m *TradeMutation) AddFreqtradeTradeID(i int) {
	if m.addfreqtrade_trade_id != nil {
		*m.addfreqtrade_trade_id += i
	} else {
		m.addfreqtrade_trade_id = &i
	}
}

// AddedFreqtradeTradeID returns the value that was added to the "freqtrade_trade_id" field in this mutation.
func (m *TradeMutation) AddedFreqtradeTradeID() (r int, exists bool) {
	v := m.addfreqtrade_trade_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFreqtradeTradeID resets all changes to the "freqtrade_trade_id" field.
func (m *TradeMutation) ResetFreqtradeTradeID() {
	m.freqtrade_trade_id = nil
	m.addfreqtrade_trade_id = nil
}

// SetPair sets the "pair" field.
func (m *TradeMutation) SetPair(s string) {
	m.pair = &s
}

// Pair returns the value of the "pair" field in the mutation.
func (m *TradeMutation) Pair() (r string, exists bool) {
	v := m.pair
	if v == nil {
		return
	}
	return *v, true
}

// OldPair returns the old "pair" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldPair(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPair is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPair requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPair: %w", err)
	}
	return oldValue.Pair, nil
}

// ResetPair resets all changes to the "pair" field.
func (m *TradeMutation) ResetPair() {
	m.pair = nil
}

// SetIsOpen sets the "is_open" field.
func (m *TradeMutation) SetIsOpen(b bool) {
	m.is_open = &b
}

// IsOpen returns the value of the "is_open" field in the mutation.
func (m *TradeMutation) IsOpen() (r bool, exists bool) {
	v := m.is_open
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOpen returns the old "is_open" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldIsOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOpen: %w", err)
	}
	return oldValue.IsOpen, nil
}

// ResetIsOpen resets all changes to the "is_open" field.
func (m *TradeMutation) ResetIsOpen() {
	m.is_open = nil
}

// SetOpenDate sets the "open_date" field.
func (m *TradeMutation) SetOpenDate(t time.Time) {
	m.open_date = &t
}

// OpenDate returns the value of the "open_date" field in the mutation.
func (m *TradeMutation) OpenDate() (r time.Time, exists bool) {
	v := m.open_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenDate returns the old "open_date" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldOpenDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenDate: %w", err)
	}
	return oldValue.OpenDate, nil
}

// ResetOpenDate resets all changes to the "open_date" field.
func (m *TradeMutation) ResetOpenDate() {
	m.open_date = nil
}

// SetCloseDate sets the "close_date" field.
func (m *TradeMutation) SetCloseDate(t time.Time) {
	m.close_date = &t
}

// CloseDate returns the value of the "close_date" field in the mutation.
func (m *TradeMutation) CloseDate() (r time.Time, exists bool) {
	v := m.close_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseDate returns the old "close_date" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldCloseDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseDate: %w", err)
	}
	return oldValue.CloseDate, nil
}

// ClearCloseDate clears the value of the "close_date" field.
func (m *TradeMutation) ClearCloseDate() {
	m.close_date = nil
	m.clearedFields[trade.FieldCloseDate] = struct{}{}
}

// CloseDateCleared returns if the "close_date" field was cleared in this mutation.
func (m *TradeMutation) CloseDateCleared() bool {
	_, ok := m.clearedFields[trade.FieldCloseDate]
	return ok
}

// ResetCloseDate resets all changes to the "close_date" field.
func (m *TradeMutation) ResetCloseDate() {
	m.close_date = nil
	delete(m.clearedFields, trade.FieldCloseDate)
}

// SetOpenRate sets the "open_rate" field.
func (m *TradeMutation) SetOpenRate(f float64) {
	m.open_rate = &f
	m.addopen_rate = nil
}

// OpenRate returns the value of the "open_rate" field in the mutation.
func (m *TradeMutation) OpenRate() (r float64, exists bool) {
	v := m.open_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenRate returns the old "open_rate" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldOpenRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenRate: %w", err)
	}
	return oldValue.OpenRate, nil
}

// AddOpenRate adds f to the "open_rate" field.
func (m *TradeMutation) AddOpenRate(f float64) {
	if m.addopen_rate != nil {
		*m.addopen_rate += f
	} else {
		m.addopen_rate = &f
	}
}

// AddedOpenRate returns the value that was added to the "open_rate" field in this mutation.
func (m *TradeMutation) AddedOpenRate() (r float64, exists bool) {
	v := m.addopen_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpenRate resets all changes to the "open_rate" field.
func (m *TradeMutation) ResetOpenRate() {
	m.open_rate = nil
	m.addopen_rate = nil
}

// SetCloseRate sets the "close_rate" field.
func (m *TradeMutation) SetCloseRate(f float64) {
	m.close_rate = &f
	m.addclose_rate = nil
}

// CloseRate returns the value of the "close_rate" field in the mutation.
func (m *TradeMutation) CloseRate() (r float64, exists bool) {
	v := m.close_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseRate returns the old "close_rate" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldCloseRate(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseRate: %w", err)
	}
	return oldValue.CloseRate, nil
}

// AddCloseRate adds f to the "close_rate" field.
func (m *TradeMutation) AddCloseRate(f float64) {
	if m.addclose_rate != nil {
		*m.addclose_rate += f
	} else {
		m.addclose_rate = &f
	}
}

// AddedCloseRate returns the value that was added to the "close_rate" field in this mutation.
func (m *TradeMutation) AddedCloseRate() (r float64, exists bool) {
	v := m.addclose_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearCloseRate clears the value of the "close_rate" field.
func (m *TradeMutation) ClearCloseRate() {
	m.close_rate = nil
	m.addclose_rate = nil
	m.clearedFields[trade.FieldCloseRate] = struct{}{}
}

// CloseRateCleared returns if the "close_rate" field was cleared in this mutation.
func (m *TradeMutation) CloseRateCleared() bool {
	_, ok := m.clearedFields[trade.FieldCloseRate]
	return ok
}

// ResetCloseRate resets all changes to the "close_rate" field.
func (m *TradeMutation) ResetCloseRate() {
	m.close_rate = nil
	m.addclose_rate = nil
	delete(m.clearedFields, trade.FieldCloseRate)
}

// SetAmount sets the "amount" field.
func (m *TradeMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TradeMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TradeMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TradeMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TradeMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStakeAmount sets the "stake_amount" field.
func (m *TradeMutation) SetStakeAmount(f float64) {
	m.stake_amount = &f
	m.addstake_amount = nil
}

// StakeAmount returns the value of the "stake_amount" field in the mutation.
func (m *TradeMutation) StakeAmount() (r float64, exists bool) {
	v := m.stake_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStakeAmount returns the old "stake_amount" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldStakeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakeAmount: %w", err)
	}
	return oldValue.StakeAmount, nil
}

// AddStakeAmount adds f to the "stake_amount" field.
func (m *TradeMutation) AddStakeAmount(f float64) {
	if m.addstake_amount != nil {
		*m.addstake_amount += f
	} else {
		m.addstake_amount = &f
	}
}

// AddedStakeAmount returns the value that was added to the "stake_amount" field in this mutation.
func (m *TradeMutation) AddedStakeAmount() (r float64, exists bool) {
	v := m.addstake_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetStakeAmount resets all changes to the "stake_amount" field.
func (m *TradeMutation) ResetStakeAmount() {
	m.stake_amount = nil
	m.addstake_amount = nil
}

// SetProfitAbs sets the "profit_abs" field.
func (m *TradeMutation) SetProfitAbs(f float64) {
	m.profit_abs = &f
	m.addprofit_abs = nil
}

// ProfitAbs returns the value of the "profit_abs" field in the mutation.
func (m *TradeMutation) ProfitAbs() (r float64, exists bool) {
	v := m.profit_abs
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitAbs returns the old "profit_abs" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldProfitAbs(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitAbs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitAbs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitAbs: %w", err)
	}
	return oldValue.ProfitAbs, nil
}

// AddProfitAbs adds f to the "profit_abs" field.
func (m *TradeMutation) AddProfitAbs(f float64) {
	if m.addprofit_abs != nil {
		*m.addprofit_abs += f
	} else {
		m.addprofit_abs = &f
	}
}

// AddedProfitAbs returns the value that was added to the "profit_abs" field in this mutation.
func (m *TradeMutation) AddedProfitAbs() (r float64, exists bool) {
	v := m.addprofit_abs
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitAbs resets all changes to the "profit_abs" field.
func (m *TradeMutation) ResetProfitAbs() {
	m.profit_abs = nil
	m.addprofit_abs = nil
}

// SetProfitRatio sets the "profit_ratio" field.
func (m *TradeMutation) SetProfitRatio(f float64) {
	m.profit_ratio = &f
	m.addprofit_ratio = nil
}

// ProfitRatio returns the value of the "profit_ratio" field in the mutation.
func (m *TradeMutation) ProfitRatio() (r float64, exists bool) {
	v := m.profit_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitRatio returns the old "profit_ratio" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldProfitRatio(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitRatio: %w", err)
	}
	return oldValue.ProfitRatio, nil
}

// AddProfitRatio adds f to the "profit_ratio" field.
func (m *TradeMutation) AddProfitRatio(f float64) {
	if m.addprofit_ratio != nil {
		*m.addprofit_ratio += f
	} else {
		m.addprofit_ratio = &f
	}
}

// AddedProfitRatio returns the value that was added to the "profit_ratio" field in this mutation.
func (m *TradeMutation) AddedProfitRatio() (r float64, exists bool) {
	v := m.addprofit_ratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfitRatio resets all changes to the "profit_ratio" field.
func (m *TradeMutation) ResetProfitRatio() {
	m.profit_ratio = nil
	m.addprofit_ratio = nil
}

// SetSellReason sets the "sell_reason" field.
func (m *TradeMutation) SetSellReason(s string) {
	m.sell_reason = &s
}

// SellReason returns the value of the "sell_reason" field in the mutation.
func (m *TradeMutation) SellReason() (r string, exists bool) {
	v := m.sell_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSellReason returns the old "sell_reason" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldSellReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellReason: %w", err)
	}
	return oldValue.SellReason, nil
}

// ClearSellReason clears the value of the "sell_reason" field.
func (m *TradeMutation) ClearSellReason() {
	m.sell_reason = nil
	m.clearedFields[trade.FieldSellReason] = struct{}{}
}

// SellReasonCleared returns if the "sell_reason" field was cleared in this mutation.
func (m *TradeMutation) SellReasonCleared() bool {
	_, ok := m.clearedFields[trade.FieldSellReason]
	return ok
}

// ResetSellReason resets all changes to the "sell_reason" field.
func (m *TradeMutation) ResetSellReason() {
	m.sell_reason = nil
	delete(m.clearedFields, trade.FieldSellReason)
}

// SetStrategyName sets the "strategy_name" field.
func (m *TradeMutation) SetStrategyName(s string) {
	m.strategy_name = &s
}

// StrategyName returns the value of the "strategy_name" field in the mutation.
func (m *TradeMutation) StrategyName() (r string, exists bool) {
	v := m.strategy_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyName returns the old "strategy_name" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldStrategyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyName: %w", err)
	}
	return oldValue.StrategyName, nil
}

// ClearStrategyName clears the value of the "strategy_name" field.
func (m *TradeMutation) ClearStrategyName() {
	m.strategy_name = nil
	m.clearedFields[trade.FieldStrategyName] = struct{}{}
}

// StrategyNameCleared returns if the "strategy_name" field was cleared in this mutation.
func (m *TradeMutation) StrategyNameCleared() bool {
	_, ok := m.clearedFields[trade.FieldStrategyName]
	return ok
}

// ResetStrategyName resets all changes to the "strategy_name" field.
func (m *TradeMutation) ResetStrategyName() {
	m.strategy_name = nil
	delete(m.clearedFields, trade.FieldStrategyName)
}

// SetTimeframe sets the "timeframe" field.
func (m *TradeMutation) SetTimeframe(s string) {
	m.timeframe = &s
}

// Timeframe returns the value of the "timeframe" field in the mutation.
func (m *TradeMutation) Timeframe() (r string, exists bool) {
	v := m.timeframe
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeframe returns the old "timeframe" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldTimeframe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeframe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeframe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeframe: %w", err)
	}
	return oldValue.Timeframe, nil
}

// ClearTimeframe clears the value of the "timeframe" field.
func (m *TradeMutation) ClearTimeframe() {
	m.timeframe = nil
	m.clearedFields[trade.FieldTimeframe] = struct{}{}
}

// TimeframeCleared returns if the "timeframe" field was cleared in this mutation.
func (m *TradeMutation) TimeframeCleared() bool {
	_, ok := m.clearedFields[trade.FieldTimeframe]
	return ok
}

// ResetTimeframe resets all changes to the "timeframe" field.
func (m *TradeMutation) ResetTimeframe() {
	m.timeframe = nil
	delete(m.clearedFields, trade.FieldTimeframe)
}

// SetRawData sets the "raw_data" field.
func (m *TradeMutation) SetRawData(value map[string]interface{}) {
	m.raw_data = &value
}

// RawData returns the value of the "raw_data" field in the mutation.
func (m *TradeMutation) RawData() (r map[string]interface{}, exists bool) {
	v := m.raw_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRawData returns the old "raw_data" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldRawData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawData: %w", err)
	}
	return oldValue.RawData, nil
}

// ClearRawData clears the value of the "raw_data" field.
func (m *TradeMutation) ClearRawData() {
	m.raw_data = nil
	m.clearedFields[trade.FieldRawData] = struct{}{}
}

// RawDataCleared returns if the "raw_data" field was cleared in this mutation.
func (m *TradeMutation) RawDataCleared() bool {
	_, ok := m.clearedFields[trade.FieldRawData]
	return ok
}

// ResetRawData resets all changes to the "raw_data" field.
func (m *TradeMutation) ResetRawData() {
	m.raw_data = nil
	delete(m.clearedFields, trade.FieldRawData)
}

// SetBotID sets the "bot_id" field.
func (m *TradeMutation) SetBotID(u uuid.UUID) {
	m.bot = &u
}

// BotID returns the value of the "bot_id" field in the mutation.
func (m *TradeMutation) BotID() (r uuid.UUID, exists bool) {
	v := m.bot
	if v == nil {
		return
	}
	return *v, true
}

// OldBotID returns the old "bot_id" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldBotID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBotID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBotID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBotID: %w", err)
	}
	return oldValue.BotID, nil
}

// ResetBotID resets all changes to the "bot_id" field.
func (m *TradeMutation) ResetBotID() {
	m.bot = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TradeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TradeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TradeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TradeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TradeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Trade entity.
// If the Trade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TradeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearBot clears the "bot" edge to the Bot entity.
func (m *TradeMutation) ClearBot() {
	m.clearedbot = true
	m.clearedFields[trade.FieldBotID] = struct{}{}
}

// BotCleared reports if the "bot" edge to the Bot entity was cleared.
func (m *TradeMutation) BotCleared() bool {
	return m.clearedbot
}

// BotIDs returns the "bot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BotID instead. It exists only for internal usage by the builders.
func (m *TradeMutation) BotIDs() (ids []uuid.UUID) {
	if id := m.bot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBot resets all changes to the "bot" edge.
func (m *TradeMutation) ResetBot() {
	m.bot = nil
	m.clearedbot = false
}

// Where appends a list predicates to the TradeMutation builder.
func (m *TradeMutation) Where(ps ...predicate.Trade) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TradeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TradeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trade, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TradeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TradeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trade).
func (m *TradeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TradeMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.deleted_at != nil {
		fields = append(fields, trade.FieldDeletedAt)
	}
	if m.freqtrade_trade_id != nil {
		fields = append(fields, trade.FieldFreqtradeTradeID)
	}
	if m.pair != nil {
		fields = append(fields, trade.FieldPair)
	}
	if m.is_open != nil {
		fields = append(fields, trade.FieldIsOpen)
	}
	if m.open_date != nil {
		fields = append(fields, trade.FieldOpenDate)
	}
	if m.close_date != nil {
		fields = append(fields, trade.FieldCloseDate)
	}
	if m.open_rate != nil {
		fields = append(fields, trade.FieldOpenRate)
	}
	if m.close_rate != nil {
		fields = append(fields, trade.FieldCloseRate)
	}
	if m.amount != nil {
		fields = append(fields, trade.FieldAmount)
	}
	if m.stake_amount != nil {
		fields = append(fields, trade.FieldStakeAmount)
	}
	if m.profit_abs != nil {
		fields = append(fields, trade.FieldProfitAbs)
	}
	if m.profit_ratio != nil {
		fields = append(fields, trade.FieldProfitRatio)
	}
	if m.sell_reason != nil {
		fields = append(fields, trade.FieldSellReason)
	}
	if m.strategy_name != nil {
		fields = append(fields, trade.FieldStrategyName)
	}
	if m.timeframe != nil {
		fields = append(fields, trade.FieldTimeframe)
	}
	if m.raw_data != nil {
		fields = append(fields, trade.FieldRawData)
	}
	if m.bot != nil {
		fields = append(fields, trade.FieldBotID)
	}
	if m.created_at != nil {
		fields = append(fields, trade.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trade.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TradeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trade.FieldDeletedAt:
		return m.DeletedAt()
	case trade.FieldFreqtradeTradeID:
		return m.FreqtradeTradeID()
	case trade.FieldPair:
		return m.Pair()
	case trade.FieldIsOpen:
		return m.IsOpen()
	case trade.FieldOpenDate:
		return m.OpenDate()
	case trade.FieldCloseDate:
		return m.CloseDate()
	case trade.FieldOpenRate:
		return m.OpenRate()
	case trade.FieldCloseRate:
		return m.CloseRate()
	case trade.FieldAmount:
		return m.Amount()
	case trade.FieldStakeAmount:
		return m.StakeAmount()
	case trade.FieldProfitAbs:
		return m.ProfitAbs()
	case trade.FieldProfitRatio:
		return m.ProfitRatio()
	case trade.FieldSellReason:
		return m.SellReason()
	case trade.FieldStrategyName:
		return m.StrategyName()
	case trade.FieldTimeframe:
		return m.Timeframe()
	case trade.FieldRawData:
		return m.RawData()
	case trade.FieldBotID:
		return m.BotID()
	case trade.FieldCreatedAt:
		return m.CreatedAt()
	case trade.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TradeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trade.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trade.FieldFreqtradeTradeID:
		return m.OldFreqtradeTradeID(ctx)
	case trade.FieldPair:
		return m.OldPair(ctx)
	case trade.FieldIsOpen:
		return m.OldIsOpen(ctx)
	case trade.FieldOpenDate:
		return m.OldOpenDate(ctx)
	case trade.FieldCloseDate:
		return m.OldCloseDate(ctx)
	case trade.FieldOpenRate:
		return m.OldOpenRate(ctx)
	case trade.FieldCloseRate:
		return m.OldCloseRate(ctx)
	case trade.FieldAmount:
		return m.OldAmount(ctx)
	case trade.FieldStakeAmount:
		return m.OldStakeAmount(ctx)
	case trade.FieldProfitAbs:
		return m.OldProfitAbs(ctx)
	case trade.FieldProfitRatio:
		return m.OldProfitRatio(ctx)
	case trade.FieldSellReason:
		return m.OldSellReason(ctx)
	case trade.FieldStrategyName:
		return m.OldStrategyName(ctx)
	case trade.FieldTimeframe:
		return m.OldTimeframe(ctx)
	case trade.FieldRawData:
		return m.OldRawData(ctx)
	case trade.FieldBotID:
		return m.OldBotID(ctx)
	case trade.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trade.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Trade field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trade.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trade.FieldFreqtradeTradeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreqtradeTradeID(v)
		return nil
	case trade.FieldPair:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPair(v)
		return nil
	case trade.FieldIsOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOpen(v)
		return nil
	case trade.FieldOpenDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenDate(v)
		return nil
	case trade.FieldCloseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseDate(v)
		return nil
	case trade.FieldOpenRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenRate(v)
		return nil
	case trade.FieldCloseRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseRate(v)
		return nil
	case trade.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case trade.FieldStakeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakeAmount(v)
		return nil
	case trade.FieldProfitAbs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitAbs(v)
		return nil
	case trade.FieldProfitRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitRatio(v)
		return nil
	case trade.FieldSellReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellReason(v)
		return nil
	case trade.FieldStrategyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyName(v)
		return nil
	case trade.FieldTimeframe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeframe(v)
		return nil
	case trade.FieldRawData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawData(v)
		return nil
	case trade.FieldBotID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBotID(v)
		return nil
	case trade.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trade.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Trade field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TradeMutation) AddedFields() []string {
	var fields []string
	if m.addfreqtrade_trade_id != nil {
		fields = append(fields, trade.FieldFreqtradeTradeID)
	}
	if m.addopen_rate != nil {
		fields = append(fields, trade.FieldOpenRate)
	}
	if m.addclose_rate != nil {
		fields = append(fields, trade.FieldCloseRate)
	}
	if m.addamount != nil {
		fields = append(fields, trade.FieldAmount)
	}
	if m.addstake_amount != nil {
		fields = append(fields, trade.FieldStakeAmount)
	}
	if m.addprofit_abs != nil {
		fields = append(fields, trade.FieldProfitAbs)
	}
	if m.addprofit_ratio != nil {
		fields = append(fields, trade.FieldProfitRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TradeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trade.FieldFreqtradeTradeID:
		return m.AddedFreqtradeTradeID()
	case trade.FieldOpenRate:
		return m.AddedOpenRate()
	case trade.FieldCloseRate:
		return m.AddedCloseRate()
	case trade.FieldAmount:
		return m.AddedAmount()
	case trade.FieldStakeAmount:
		return m.AddedStakeAmount()
	case trade.FieldProfitAbs:
		return m.AddedProfitAbs()
	case trade.FieldProfitRatio:
		return m.AddedProfitRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trade.FieldFreqtradeTradeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreqtradeTradeID(v)
		return nil
	case trade.FieldOpenRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpenRate(v)
		return nil
	case trade.FieldCloseRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCloseRate(v)
		return nil
	case trade.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case trade.FieldStakeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStakeAmount(v)
		return nil
	case trade.FieldProfitAbs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitAbs(v)
		return nil
	case trade.FieldProfitRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfitRatio(v)
		return nil
	}
	return fmt.Errorf("unknown Trade numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TradeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trade.FieldDeletedAt) {
		fields = append(fields, trade.FieldDeletedAt)
	}
	if m.FieldCleared(trade.FieldCloseDate) {
		fields = append(fields, trade.FieldCloseDate)
	}
	if m.FieldCleared(trade.FieldCloseRate) {
		fields = append(fields, trade.FieldCloseRate)
	}
	if m.FieldCleared(trade.FieldSellReason) {
		fields = append(fields, trade.FieldSellReason)
	}
	if m.FieldCleared(trade.FieldStrategyName) {
		fields = append(fields, trade.FieldStrategyName)
	}
	if m.FieldCleared(trade.FieldTimeframe) {
		fields = append(fields, trade.FieldTimeframe)
	}
	if m.FieldCleared(trade.FieldRawData) {
		fields = append(fields, trade.FieldRawData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TradeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TradeMutation) ClearField(name string) error {
	switch name {
	case trade.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case trade.FieldCloseDate:
		m.ClearCloseDate()
		return nil
	case trade.FieldCloseRate:
		m.ClearCloseRate()
		return nil
	case trade.FieldSellReason:
		m.ClearSellReason()
		return nil
	case trade.FieldStrategyName:
		m.ClearStrategyName()
		return nil
	case trade.FieldTimeframe:
		m.ClearTimeframe()
		return nil
	case trade.FieldRawData:
		m.ClearRawData()
		return nil
	}
	return fmt.Errorf("unknown Trade nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TradeMutation) ResetField(name string) error {
	switch name {
	case trade.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trade.FieldFreqtradeTradeID:
		m.ResetFreqtradeTradeID()
		return nil
	case trade.FieldPair:
		m.ResetPair()
		return nil
	case trade.FieldIsOpen:
		m.ResetIsOpen()
		return nil
	case trade.FieldOpenDate:
		m.ResetOpenDate()
		return nil
	case trade.FieldCloseDate:
		m.ResetCloseDate()
		return nil
	case trade.FieldOpenRate:
		m.ResetOpenRate()
		return nil
	case trade.FieldCloseRate:
		m.ResetCloseRate()
		return nil
	case trade.FieldAmount:
		m.ResetAmount()
		return nil
	case trade.FieldStakeAmount:
		m.ResetStakeAmount()
		return nil
	case trade.FieldProfitAbs:
		m.ResetProfitAbs()
		return nil
	case trade.FieldProfitRatio:
		m.ResetProfitRatio()
		return nil
	case trade.FieldSellReason:
		m.ResetSellReason()
		return nil
	case trade.FieldStrategyName:
		m.ResetStrategyName()
		return nil
	case trade.FieldTimeframe:
		m.ResetTimeframe()
		return nil
	case trade.FieldRawData:
		m.ResetRawData()
		return nil
	case trade.FieldBotID:
		m.ResetBotID()
		return nil
	case trade.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trade.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Trade field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TradeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bot != nil {
		edges = append(edges, trade.EdgeBot)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TradeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trade.EdgeBot:
		if id := m.bot; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TradeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TradeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TradeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbot {
		edges = append(edges, trade.EdgeBot)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TradeMutation) EdgeCleared(name string) bool {
	switch name {
	case trade.EdgeBot:
		return m.clearedbot
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TradeMutation) ClearEdge(name string) error {
	switch name {
	case trade.EdgeBot:
		m.ClearBot()
		return nil
	}
	return fmt.Errorf("unknown Trade unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TradeMutation) ResetEdge(name string) error {
	switch name {
	case trade.EdgeBot:
		m.ResetBot()
		return nil
	}
	return fmt.Errorf("unknown Trade edge %s", name)
}
