package codegen

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"
)

// GenerateFullStrategy generates a complete Python Freqtrade strategy from UIBuilderConfig
func (g *Generator) GenerateFullStrategy(config *UIBuilderConfig, className string, timeframe string) (string, error) {
	g.ResetImports()

	// Set indicators for reference during generation
	g.SetIndicators(config.Indicators)

	var sb strings.Builder

	// Generate header comment
	sb.WriteString("# Generated by VolatiCloud Strategy Builder\n")
	sb.WriteString("# Do not edit manually - use the UI Builder to modify\n\n")

	// Generate imports
	sb.WriteString("from freqtrade.strategy import IStrategy, IntParameter, DecimalParameter\n")
	sb.WriteString("from pandas import DataFrame\n")
	sb.WriteString("import talib.abstract as ta\n")

	// Generate entry/exit conditions to determine required imports
	entryCode, err := g.GenerateCondition(&config.EntryConditions)
	if err != nil {
		return "", fmt.Errorf("failed to generate entry conditions: %w", err)
	}

	exitCode, err := g.GenerateCondition(&config.ExitConditions)
	if err != nil {
		return "", fmt.Errorf("failed to generate exit conditions: %w", err)
	}

	// Add required imports based on what was used
	if g.imports["numpy"] {
		sb.WriteString("import numpy as np\n")
	}
	if g.imports["qtpylib"] {
		sb.WriteString("import qtpylib\n")
	}
	if g.imports["pandas"] {
		sb.WriteString("import pandas as pd\n")
	}

	sb.WriteString("\n\n")

	// Generate class definition
	sb.WriteString(fmt.Sprintf("class %s(IStrategy):\n", className))
	sb.WriteString(fmt.Sprintf("    \"\"\"\n    Strategy generated by VolatiCloud UI Builder\n    \"\"\"\n\n"))

	// Generate strategy properties
	sb.WriteString(fmt.Sprintf("    timeframe = '%s'\n\n", timeframe))

	// Generate minimal_roi
	if len(config.Parameters.MinimalROI) > 0 {
		sb.WriteString("    minimal_roi = {\n")
		// Sort keys for consistent output
		keys := make([]string, 0, len(config.Parameters.MinimalROI))
		for k := range config.Parameters.MinimalROI {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			sb.WriteString(fmt.Sprintf("        '%s': %.4f,\n", k, config.Parameters.MinimalROI[k]))
		}
		sb.WriteString("    }\n\n")
	} else {
		sb.WriteString("    minimal_roi = {\n        '0': 0.1\n    }\n\n")
	}

	// Generate stoploss
	sb.WriteString(fmt.Sprintf("    stoploss = %.4f\n\n", config.Parameters.Stoploss))

	// Generate trailing stop
	if config.Parameters.TrailingStop {
		sb.WriteString("    trailing_stop = True\n")
		if config.Parameters.TrailingStopPositive != nil {
			sb.WriteString(fmt.Sprintf("    trailing_stop_positive = %.4f\n", *config.Parameters.TrailingStopPositive))
		}
		if config.Parameters.TrailingStopPositiveOffset != nil {
			sb.WriteString(fmt.Sprintf("    trailing_stop_positive_offset = %.4f\n", *config.Parameters.TrailingStopPositiveOffset))
		}
		sb.WriteString("\n")
	}

	// Generate use_exit_signal
	sb.WriteString(fmt.Sprintf("    use_exit_signal = %s\n\n", boolToPython(config.Parameters.UseExitSignal)))

	// Generate populate_indicators
	indicatorsCode, err := g.generatePopulateIndicators(config.Indicators)
	if err != nil {
		return "", fmt.Errorf("failed to generate indicators: %w", err)
	}
	sb.WriteString(indicatorsCode)
	sb.WriteString("\n")

	// Generate populate_entry_trend
	sb.WriteString("    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:\n")
	sb.WriteString(fmt.Sprintf("        dataframe['enter_long'] = (\n            %s\n        ).astype(int)\n", entryCode))
	sb.WriteString("        return dataframe\n\n")

	// Generate populate_exit_trend
	sb.WriteString("    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:\n")
	sb.WriteString(fmt.Sprintf("        dataframe['exit_long'] = (\n            %s\n        ).astype(int)\n", exitCode))
	sb.WriteString("        return dataframe\n")

	// Generate callbacks if enabled
	if config.Callbacks.CustomStoploss != nil && config.Callbacks.CustomStoploss.Enabled {
		callbackCode, err := g.generateCustomStoploss(config.Callbacks.CustomStoploss)
		if err != nil {
			return "", fmt.Errorf("failed to generate custom_stoploss: %w", err)
		}
		sb.WriteString("\n")
		sb.WriteString(callbackCode)
	}

	if config.Callbacks.ConfirmEntry != nil && config.Callbacks.ConfirmEntry.Enabled {
		callbackCode, err := g.generateConfirmEntry(config.Callbacks.ConfirmEntry)
		if err != nil {
			return "", fmt.Errorf("failed to generate confirm_trade_entry: %w", err)
		}
		sb.WriteString("\n")
		sb.WriteString(callbackCode)
	}

	if config.Callbacks.DCA != nil && config.Callbacks.DCA.Enabled {
		callbackCode := g.generateDCA(config.Callbacks.DCA)
		sb.WriteString("\n")
		sb.WriteString(callbackCode)
	}

	return sb.String(), nil
}

// generatePopulateIndicators generates the populate_indicators method
func (g *Generator) generatePopulateIndicators(indicators []IndicatorDefinition) (string, error) {
	var sb strings.Builder
	sb.WriteString("    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:\n")

	if len(indicators) == 0 {
		sb.WriteString("        # No indicators configured\n")
		sb.WriteString("        return dataframe\n")
		return sb.String(), nil
	}

	indGen := NewIndicatorGenerator()
	for _, ind := range indicators {
		code, err := indGen.GenerateIndicator(ind)
		if err != nil {
			return "", fmt.Errorf("failed to generate indicator %s: %w", ind.ID, err)
		}
		// Indent each line
		lines := strings.Split(code, "\n")
		for _, line := range lines {
			if line != "" {
				sb.WriteString("        ")
				sb.WriteString(line)
				sb.WriteString("\n")
			}
		}
		sb.WriteString("\n")
	}

	sb.WriteString("        return dataframe\n")
	return sb.String(), nil
}

// generateCustomStoploss generates the custom_stoploss method
func (g *Generator) generateCustomStoploss(config *CustomStoplossConfig) (string, error) {
	var sb strings.Builder
	sb.WriteString("    def custom_stoploss(self, pair: str, trade, current_time, current_rate,\n")
	sb.WriteString("                        current_profit: float, **kwargs) -> float:\n")

	// Generate rules
	for _, rule := range config.Rules {
		condCode, err := g.GenerateCondition(&rule.Condition)
		if err != nil {
			return "", fmt.Errorf("failed to generate stoploss condition: %w", err)
		}
		sb.WriteString(fmt.Sprintf("        if %s:\n", condCode))
		sb.WriteString(fmt.Sprintf("            return %.4f\n", rule.Stoploss))
	}

	// Default stoploss
	sb.WriteString(fmt.Sprintf("        return %.4f\n", config.DefaultStoploss))

	return sb.String(), nil
}

// generateConfirmEntry generates the confirm_trade_entry method
func (g *Generator) generateConfirmEntry(config *ConfirmEntryConfig) (string, error) {
	var sb strings.Builder
	sb.WriteString("    def confirm_trade_entry(self, pair: str, order_type: str, amount: float,\n")
	sb.WriteString("                            rate: float, time_in_force: str, current_time,\n")
	sb.WriteString("                            entry_tag, side: str, **kwargs) -> bool:\n")

	condCode, err := g.GenerateCondition(&config.Rules)
	if err != nil {
		return "", fmt.Errorf("failed to generate confirm entry condition: %w", err)
	}

	sb.WriteString(fmt.Sprintf("        return %s\n", condCode))

	return sb.String(), nil
}

// generateDCA generates the adjust_trade_position method for DCA
func (g *Generator) generateDCA(config *DCAConfig) string {
	var sb strings.Builder
	sb.WriteString("    def adjust_trade_position(self, trade, current_time, current_rate,\n")
	sb.WriteString("                              current_profit: float, **kwargs):\n")
	sb.WriteString("        \"\"\"\n")
	sb.WriteString("        Dollar Cost Averaging - add to position when price drops\n")
	sb.WriteString("        \"\"\"\n")

	// Check max entries
	sb.WriteString(fmt.Sprintf("        if trade.nr_of_successful_entries >= %d:\n", config.MaxEntries))
	sb.WriteString("            return None  # Max entries reached\n\n")

	// Check cooldown if configured
	if config.CooldownMinutes > 0 {
		sb.WriteString(fmt.Sprintf("        # Cooldown: wait %d minutes between entries\n", config.CooldownMinutes))
		sb.WriteString("        if trade.nr_of_successful_entries > 1:\n")
		sb.WriteString("            last_entry = trade.orders[-1]\n")
		sb.WriteString(fmt.Sprintf("            if (current_time - last_entry.order_date_utc).total_seconds() < %d * 60:\n", config.CooldownMinutes))
		sb.WriteString("                return None\n\n")
	}

	// Generate DCA rules
	for i, rule := range config.Rules {
		priceDrop := -rule.PriceDropPercent / 100.0 // Convert to negative decimal
		sb.WriteString(fmt.Sprintf("        # DCA Entry %d: at %.1f%% loss, add %.2fx stake\n", i+2, rule.PriceDropPercent, rule.StakeMultiplier))
		sb.WriteString(fmt.Sprintf("        if trade.nr_of_successful_entries == %d and current_profit < %.4f:\n", i+1, priceDrop))
		sb.WriteString(fmt.Sprintf("            return trade.stake_amount * %.2f\n\n", rule.StakeMultiplier))
	}

	sb.WriteString("        return None\n")

	return sb.String()
}

// boolToPython converts a Go bool to Python bool string
func boolToPython(b bool) string {
	if b {
		return "True"
	}
	return "False"
}

// PreviewStrategyCode is the main entry point for code preview
// It parses the config map and generates the full strategy code
func PreviewStrategyCode(configMap map[string]interface{}, className string) (string, error) {
	// Parse the config
	config, err := ParseUIBuilderConfig(configMap)
	if err != nil {
		return "", fmt.Errorf("failed to parse UI builder config: %w", err)
	}

	if config == nil {
		return "", fmt.Errorf("no ui_builder config found in strategy config")
	}

	// Get timeframe from config
	timeframe := "5m" // default
	if tf, ok := configMap["timeframe"].(string); ok && tf != "" {
		timeframe = tf
	}

	// Generate the code
	gen := NewGenerator()
	return gen.GenerateFullStrategy(config, className, timeframe)
}

// ParseUIBuilderConfigFromJSON parses a JSON byte slice into UIBuilderConfig
func ParseUIBuilderConfigFromJSON(data []byte) (*UIBuilderConfig, error) {
	var configMap map[string]interface{}
	if err := json.Unmarshal(data, &configMap); err != nil {
		return nil, err
	}
	return ParseUIBuilderConfig(configMap)
}
