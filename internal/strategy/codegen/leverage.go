package codegen

import (
	"fmt"
	"sort"
	"strings"
)

// generateLeverage generates the leverage callback method for futures trading
func (g *Generator) generateLeverage(config *LeverageConfig) (string, error) {
	var sb strings.Builder

	sb.WriteString("    def leverage(self, pair: str, current_time, current_rate: float,\n")
	sb.WriteString("                 proposed_leverage: float, max_leverage: float, entry_tag,\n")
	sb.WriteString("                 side: str, **kwargs) -> float:\n")
	sb.WriteString("        \"\"\"\n")
	sb.WriteString("        Dynamic leverage callback generated by VolatiCloud UI Builder.\n")
	sb.WriteString("        Rules are evaluated in priority order (highest first).\n")
	sb.WriteString("        \"\"\"\n")

	// Check if we need to access dataframe for indicator-based conditions
	needsDataframe := g.leverageNeedsDataframe(config)
	needsPrevCandle := g.leverageNeedsPrevCandle(config)

	if needsDataframe {
		sb.WriteString("        # Get analyzed dataframe for indicator access\n")
		sb.WriteString("        dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)\n")
		// Require at least 2 candles if we need prev_candle for crossover/crossunder
		minCandles := 1
		if needsPrevCandle {
			minCandles = 2
		}
		sb.WriteString(fmt.Sprintf("        if len(dataframe) < %d:\n", minCandles))
		sb.WriteString(fmt.Sprintf("            return min(%.1f, max_leverage)\n\n", config.DefaultLeverage))
		sb.WriteString("        last_candle = dataframe.iloc[-1]\n")
		if needsPrevCandle {
			sb.WriteString("        prev_candle = dataframe.iloc[-2]\n")
		}
		sb.WriteString("\n")
	}

	// Add is_short helper variable
	sb.WriteString("        is_short = (side == 'short')\n\n")

	// Sort rules by priority (highest first)
	sortedRules := sortRulesByPriority(config.Rules)

	// Generate code for each rule
	for i, rule := range sortedRules {
		if rule.Disabled {
			continue
		}

		// Generate comment for the rule
		ruleLabel := rule.Label
		if ruleLabel == "" {
			ruleLabel = fmt.Sprintf("Rule %d", i+1)
		}
		sb.WriteString(fmt.Sprintf("        # %s (priority %d)\n", ruleLabel, rule.Priority))

		// Generate condition check
		if rule.Condition != nil {
			condCode, err := g.generateLeverageCondition(rule.Condition, needsDataframe)
			if err != nil {
				return "", fmt.Errorf("failed to generate leverage condition: %w", err)
			}

			sb.WriteString(fmt.Sprintf("        if %s:\n", condCode))

			// Generate leverage value
			leverageCode, err := g.generateLeverageValue(&rule.Leverage, config.MaxLeverage)
			if err != nil {
				return "", fmt.Errorf("failed to generate leverage value: %w", err)
			}

			sb.WriteString(fmt.Sprintf("            return %s\n\n", leverageCode))
		} else {
			// No condition - this is a catch-all rule
			leverageCode, err := g.generateLeverageValue(&rule.Leverage, config.MaxLeverage)
			if err != nil {
				return "", fmt.Errorf("failed to generate leverage value: %w", err)
			}

			sb.WriteString(fmt.Sprintf("        # Catch-all rule (no condition)\n"))
			sb.WriteString(fmt.Sprintf("        return %s\n\n", leverageCode))
			// No need to check remaining rules since this is a catch-all
			break
		}
	}

	// Generate default leverage
	sb.WriteString("        # Default leverage\n")
	maxLevStr := "max_leverage"
	if config.MaxLeverage != nil {
		maxLevStr = fmt.Sprintf("min(max_leverage, %.1f)", *config.MaxLeverage)
	}
	sb.WriteString(fmt.Sprintf("        return min(%.1f, %s)\n", config.DefaultLeverage, maxLevStr))

	return sb.String(), nil
}

// leverageNeedsDataframe checks if any rule needs dataframe access (indicators)
func (g *Generator) leverageNeedsDataframe(config *LeverageConfig) bool {
	for _, rule := range config.Rules {
		if rule.Disabled {
			continue
		}
		if rule.Condition != nil && g.conditionNeedsDataframe(rule.Condition) {
			return true
		}
		// Check if leverage value is expression-based with indicator operand
		valType, _ := rule.Leverage.GetLeverageValueType()
		if valType == LeverageValueTypeExpression {
			expr, _ := rule.Leverage.AsExpression()
			if expr != nil {
				opType, _ := expr.Operand.GetOperandType()
				if opType == OperandTypeINDICATOR || opType == OperandTypePRICE {
					return true
				}
			}
		}
	}
	return false
}

// leverageNeedsPrevCandle checks if any condition uses crossover/crossunder
func (g *Generator) leverageNeedsPrevCandle(config *LeverageConfig) bool {
	for _, rule := range config.Rules {
		if rule.Disabled {
			continue
		}
		if rule.Condition != nil && g.conditionNeedsPrevCandle(rule.Condition) {
			return true
		}
	}
	return false
}

// conditionNeedsPrevCandle recursively checks if a condition needs prev_candle access (crossover/crossunder)
func (g *Generator) conditionNeedsPrevCandle(node *ConditionNode) bool {
	nodeType, err := node.GetNodeType()
	if err != nil {
		return false
	}

	switch nodeType {
	case NodeTypeAND:
		andNode, _ := node.AsAndNode()
		for _, child := range andNode.Children {
			if g.conditionNeedsPrevCandle(&child) {
				return true
			}
		}
	case NodeTypeOR:
		orNode, _ := node.AsOrNode()
		for _, child := range orNode.Children {
			if g.conditionNeedsPrevCandle(&child) {
				return true
			}
		}
	case NodeTypeNOT:
		notNode, _ := node.AsNotNode()
		return g.conditionNeedsPrevCandle(&notNode.Child)
	case NodeTypeIfThenElse:
		ifNode, _ := node.AsIfThenElseNode()
		if g.conditionNeedsPrevCandle(&ifNode.Condition) || g.conditionNeedsPrevCandle(&ifNode.Then) {
			return true
		}
		if ifNode.Else != nil && g.conditionNeedsPrevCandle(ifNode.Else) {
			return true
		}
	case NodeTypeCROSSOVER, NodeTypeCROSSUNDER:
		return true
	}

	return false
}

// conditionNeedsDataframe recursively checks if a condition needs dataframe access
func (g *Generator) conditionNeedsDataframe(node *ConditionNode) bool {
	nodeType, err := node.GetNodeType()
	if err != nil {
		return false
	}

	switch nodeType {
	case NodeTypeAND:
		andNode, _ := node.AsAndNode()
		for _, child := range andNode.Children {
			if g.conditionNeedsDataframe(&child) {
				return true
			}
		}
	case NodeTypeOR:
		orNode, _ := node.AsOrNode()
		for _, child := range orNode.Children {
			if g.conditionNeedsDataframe(&child) {
				return true
			}
		}
	case NodeTypeNOT:
		notNode, _ := node.AsNotNode()
		return g.conditionNeedsDataframe(&notNode.Child)
	case NodeTypeIfThenElse:
		ifNode, _ := node.AsIfThenElseNode()
		if g.conditionNeedsDataframe(&ifNode.Condition) || g.conditionNeedsDataframe(&ifNode.Then) {
			return true
		}
		if ifNode.Else != nil && g.conditionNeedsDataframe(ifNode.Else) {
			return true
		}
	case NodeTypeCOMPARE:
		cmpNode, _ := node.AsCompareNode()
		return g.operandNeedsDataframe(&cmpNode.Left) || g.operandNeedsDataframe(&cmpNode.Right)
	case NodeTypeCROSSOVER, NodeTypeCROSSUNDER:
		// Crossover/crossunder always need dataframe
		return true
	case NodeTypeInRange:
		rangeNode, _ := node.AsInRangeNode()
		return g.operandNeedsDataframe(&rangeNode.Value) ||
			g.operandNeedsDataframe(&rangeNode.Min) ||
			g.operandNeedsDataframe(&rangeNode.Max)
	}

	return false
}

// operandNeedsDataframe checks if an operand needs dataframe access
func (g *Generator) operandNeedsDataframe(op *Operand) bool {
	opType, _ := op.GetOperandType()
	switch opType {
	case OperandTypeINDICATOR, OperandTypePRICE, OperandTypeTIME:
		return true
	case OperandTypeCOMPUTED:
		compOp, _ := op.AsComputedOperand()
		for _, subOp := range compOp.Operands {
			if g.operandNeedsDataframe(&subOp) {
				return true
			}
		}
	}
	return false
}

// generateLeverageCondition generates Python code for a condition in leverage callback
// Unlike dataframe conditions, these evaluate to scalar booleans
func (g *Generator) generateLeverageCondition(node *ConditionNode, needsDataframe bool) (string, error) {
	nodeType, err := node.GetNodeType()
	if err != nil {
		return "", err
	}

	switch nodeType {
	case NodeTypeAND:
		return g.generateLeverageAnd(node, needsDataframe)
	case NodeTypeOR:
		return g.generateLeverageOr(node, needsDataframe)
	case NodeTypeNOT:
		return g.generateLeverageNot(node, needsDataframe)
	case NodeTypeIfThenElse:
		return g.generateLeverageIfThenElse(node, needsDataframe)
	case NodeTypeCOMPARE:
		return g.generateLeverageCompare(node, needsDataframe)
	case NodeTypeCROSSOVER:
		return g.generateLeverageCrossover(node, needsDataframe)
	case NodeTypeCROSSUNDER:
		return g.generateLeverageCrossunder(node, needsDataframe)
	case NodeTypeInRange:
		return g.generateLeverageInRange(node, needsDataframe)
	default:
		return "", fmt.Errorf("unsupported node type in leverage condition: %s", nodeType)
	}
}

// generateLeverageAnd generates AND condition for leverage callback
func (g *Generator) generateLeverageAnd(node *ConditionNode, needsDataframe bool) (string, error) {
	andNode, err := node.AsAndNode()
	if err != nil {
		return "", err
	}

	if len(andNode.Children) == 0 {
		return "True", nil
	}

	parts := make([]string, 0, len(andNode.Children))
	for _, child := range andNode.Children {
		code, err := g.generateLeverageCondition(&child, needsDataframe)
		if err != nil {
			return "", err
		}
		parts = append(parts, fmt.Sprintf("(%s)", code))
	}

	return strings.Join(parts, " and "), nil
}

// generateLeverageOr generates OR condition for leverage callback
func (g *Generator) generateLeverageOr(node *ConditionNode, needsDataframe bool) (string, error) {
	orNode, err := node.AsOrNode()
	if err != nil {
		return "", err
	}

	if len(orNode.Children) == 0 {
		return "False", nil
	}

	parts := make([]string, 0, len(orNode.Children))
	for _, child := range orNode.Children {
		code, err := g.generateLeverageCondition(&child, needsDataframe)
		if err != nil {
			return "", err
		}
		parts = append(parts, fmt.Sprintf("(%s)", code))
	}

	return strings.Join(parts, " or "), nil
}

// generateLeverageNot generates NOT condition for leverage callback
func (g *Generator) generateLeverageNot(node *ConditionNode, needsDataframe bool) (string, error) {
	notNode, err := node.AsNotNode()
	if err != nil {
		return "", err
	}

	childCode, err := g.generateLeverageCondition(&notNode.Child, needsDataframe)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("not (%s)", childCode), nil
}

// generateLeverageCompare generates COMPARE condition for leverage callback
func (g *Generator) generateLeverageCompare(node *ConditionNode, needsDataframe bool) (string, error) {
	cmpNode, err := node.AsCompareNode()
	if err != nil {
		return "", err
	}

	leftCode, err := g.generateLeverageOperand(&cmpNode.Left, needsDataframe)
	if err != nil {
		return "", err
	}

	rightCode, err := g.generateLeverageOperand(&cmpNode.Right, needsDataframe)
	if err != nil {
		return "", err
	}

	var op string
	switch cmpNode.Operator {
	case OperatorEq:
		op = "=="
	case OperatorNeq:
		op = "!="
	case OperatorGt:
		op = ">"
	case OperatorGte:
		op = ">="
	case OperatorLt:
		op = "<"
	case OperatorLte:
		op = "<="
	default:
		return "", fmt.Errorf("unsupported operator in leverage condition: %s", cmpNode.Operator)
	}

	return fmt.Sprintf("%s %s %s", leftCode, op, rightCode), nil
}

// generateLeverageInRange generates IN_RANGE condition for leverage callback
func (g *Generator) generateLeverageInRange(node *ConditionNode, needsDataframe bool) (string, error) {
	rangeNode, err := node.AsInRangeNode()
	if err != nil {
		return "", err
	}

	valueCode, err := g.generateLeverageOperand(&rangeNode.Value, needsDataframe)
	if err != nil {
		return "", err
	}

	minCode, err := g.generateLeverageOperand(&rangeNode.Min, needsDataframe)
	if err != nil {
		return "", err
	}

	maxCode, err := g.generateLeverageOperand(&rangeNode.Max, needsDataframe)
	if err != nil {
		return "", err
	}

	if rangeNode.Inclusive {
		return fmt.Sprintf("(%s >= %s) and (%s <= %s)", valueCode, minCode, valueCode, maxCode), nil
	}
	return fmt.Sprintf("(%s > %s) and (%s < %s)", valueCode, minCode, valueCode, maxCode), nil
}

// generateLeverageIfThenElse generates IF-THEN-ELSE condition for leverage callback
func (g *Generator) generateLeverageIfThenElse(node *ConditionNode, needsDataframe bool) (string, error) {
	ifNode, err := node.AsIfThenElseNode()
	if err != nil {
		return "", err
	}

	condCode, err := g.generateLeverageCondition(&ifNode.Condition, needsDataframe)
	if err != nil {
		return "", err
	}

	thenCode, err := g.generateLeverageCondition(&ifNode.Then, needsDataframe)
	if err != nil {
		return "", err
	}

	var elseCode string
	if ifNode.Else != nil {
		elseCode, err = g.generateLeverageCondition(ifNode.Else, needsDataframe)
		if err != nil {
			return "", err
		}
	} else {
		elseCode = "False"
	}

	// Python ternary: (then if condition else else)
	return fmt.Sprintf("((%s) if (%s) else (%s))", thenCode, condCode, elseCode), nil
}

// generateLeverageCrossover generates CROSSOVER condition for leverage callback
// Crossover is True when series1 crosses above series2 (series1[-2] < series2[-2] and series1[-1] >= series2[-1])
func (g *Generator) generateLeverageCrossover(node *ConditionNode, needsDataframe bool) (string, error) {
	crossNode, err := node.AsCrossoverNode()
	if err != nil {
		return "", err
	}

	// For leverage callback with dataframe access, we use last_candle for current values
	// and need to access previous candle for crossover detection
	series1Current, err := g.generateLeverageOperand(&crossNode.Series1, needsDataframe)
	if err != nil {
		return "", err
	}

	series2Current, err := g.generateLeverageOperand(&crossNode.Series2, needsDataframe)
	if err != nil {
		return "", err
	}

	// For crossover we need previous values - modify the operand to use offset -1
	// This requires special handling since leverage operands use last_candle
	series1Prev := strings.Replace(series1Current, "last_candle", "prev_candle", 1)
	series2Prev := strings.Replace(series2Current, "last_candle", "prev_candle", 1)

	// Crossover: previous was below, current is above or equal
	return fmt.Sprintf("(%s < %s) and (%s >= %s)", series1Prev, series2Prev, series1Current, series2Current), nil
}

// generateLeverageCrossunder generates CROSSUNDER condition for leverage callback
// Crossunder is True when series1 crosses below series2 (series1[-2] > series2[-2] and series1[-1] <= series2[-1])
func (g *Generator) generateLeverageCrossunder(node *ConditionNode, needsDataframe bool) (string, error) {
	crossNode, err := node.AsCrossunderNode()
	if err != nil {
		return "", err
	}

	series1Current, err := g.generateLeverageOperand(&crossNode.Series1, needsDataframe)
	if err != nil {
		return "", err
	}

	series2Current, err := g.generateLeverageOperand(&crossNode.Series2, needsDataframe)
	if err != nil {
		return "", err
	}

	series1Prev := strings.Replace(series1Current, "last_candle", "prev_candle", 1)
	series2Prev := strings.Replace(series2Current, "last_candle", "prev_candle", 1)

	// Crossunder: previous was above, current is below or equal
	return fmt.Sprintf("(%s > %s) and (%s <= %s)", series1Prev, series2Prev, series1Current, series2Current), nil
}

// generateLeverageOperand generates Python code for an operand in leverage callback
// Returns scalar values (not pandas Series)
func (g *Generator) generateLeverageOperand(op *Operand, needsDataframe bool) (string, error) {
	opType, err := op.GetOperandType()
	if err != nil {
		return "", err
	}

	switch opType {
	case OperandTypeCONSTANT:
		return g.generateConstantOperand(op)
	case OperandTypeINDICATOR:
		return g.generateLeverageIndicatorOperand(op)
	case OperandTypePRICE:
		return g.generateLeveragePriceOperand(op)
	case OperandTypeTradeContext:
		return g.generateLeverageTradeContextOperand(op)
	case OperandTypeTIME:
		return g.generateLeverageTimeOperand(op)
	default:
		return "", fmt.Errorf("unsupported operand type in leverage callback: %s", opType)
	}
}

// generateLeverageIndicatorOperand generates Python code for indicator access in leverage callback
// Returns scalar value from last candle
func (g *Generator) generateLeverageIndicatorOperand(op *Operand) (string, error) {
	indOp, err := op.AsIndicatorOperand()
	if err != nil {
		return "", err
	}

	// Build the column name
	colName := indOp.IndicatorID
	if indOp.Field != "" {
		colName = fmt.Sprintf("%s_%s", indOp.IndicatorID, indOp.Field)
	}

	// Access from last_candle (scalar)
	return fmt.Sprintf("last_candle['%s']", colName), nil
}

// generateLeveragePriceOperand generates Python code for price access in leverage callback
// Returns scalar value from last candle
func (g *Generator) generateLeveragePriceOperand(op *Operand) (string, error) {
	priceOp, err := op.AsPriceOperand()
	if err != nil {
		return "", err
	}

	switch priceOp.Field {
	case "open", "high", "low", "close", "volume":
		return fmt.Sprintf("last_candle['%s']", priceOp.Field), nil
	case "ohlc4":
		return "(last_candle['open'] + last_candle['high'] + last_candle['low'] + last_candle['close']) / 4", nil
	case "hlc3":
		return "(last_candle['high'] + last_candle['low'] + last_candle['close']) / 3", nil
	case "hl2":
		return "(last_candle['high'] + last_candle['low']) / 2", nil
	default:
		return fmt.Sprintf("last_candle['%s']", priceOp.Field), nil
	}
}

// generateLeverageTradeContextOperand generates Python code for trade context in leverage callback
func (g *Generator) generateLeverageTradeContextOperand(op *Operand) (string, error) {
	tradeOp, err := op.AsTradeContextOperand()
	if err != nil {
		return "", err
	}

	// Map field names to Python variables available in leverage callback
	switch tradeOp.Field {
	case "pair":
		return "pair", nil
	case "is_short":
		return "is_short", nil
	case "current_rate":
		return "current_rate", nil
	default:
		return "", fmt.Errorf("unsupported trade context field in leverage callback: %s", tradeOp.Field)
	}
}

// generateLeverageTimeOperand generates Python code for time access in leverage callback
func (g *Generator) generateLeverageTimeOperand(op *Operand) (string, error) {
	timeOp, err := op.AsTimeOperand()
	if err != nil {
		return "", err
	}

	switch timeOp.Field {
	case "hour":
		return "current_time.hour", nil
	case "minute":
		return "current_time.minute", nil
	case "day_of_week":
		return "current_time.weekday()", nil
	case "day_of_month":
		return "current_time.day", nil
	case "month":
		return "current_time.month", nil
	case "is_weekend":
		return "(current_time.weekday() >= 5)", nil
	default:
		return "", fmt.Errorf("unknown time field in leverage callback: %s", timeOp.Field)
	}
}

// generateLeverageValue generates Python code for the leverage value
func (g *Generator) generateLeverageValue(value *LeverageValue, maxLeverage *float64) (string, error) {
	valType, err := value.GetLeverageValueType()
	if err != nil {
		return "", err
	}

	maxLevStr := "max_leverage"
	if maxLeverage != nil {
		maxLevStr = fmt.Sprintf("min(max_leverage, %.1f)", *maxLeverage)
	}

	switch valType {
	case LeverageValueTypeConstant:
		constVal, err := value.AsConstant()
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("min(%.1f, %s)", constVal.Value, maxLevStr), nil

	case LeverageValueTypeExpression:
		exprVal, err := value.AsExpression()
		if err != nil {
			return "", err
		}

		operandCode, err := g.generateLeverageOperand(&exprVal.Operand, true)
		if err != nil {
			return "", err
		}

		// Apply min/max bounds if specified
		result := operandCode
		if exprVal.Min != nil {
			result = fmt.Sprintf("max(%.1f, %s)", *exprVal.Min, result)
		}
		if exprVal.Max != nil {
			result = fmt.Sprintf("min(%.1f, %s)", *exprVal.Max, result)
		}

		return fmt.Sprintf("min(%s, %s)", result, maxLevStr), nil

	default:
		return "", fmt.Errorf("unknown leverage value type: %s", valType)
	}
}

// sortRulesByPriority sorts leverage rules by priority (highest first)
func sortRulesByPriority(rules []LeverageRule) []LeverageRule {
	sorted := make([]LeverageRule, len(rules))
	copy(sorted, rules)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].Priority > sorted[j].Priority
	})
	return sorted
}
