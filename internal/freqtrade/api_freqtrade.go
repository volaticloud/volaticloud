/*
Freqtrade API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package freqtrade

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// FreqtradeAPIService FreqtradeAPI service
type FreqtradeAPIService service

type ApiAddLocksApiV1LocksPostRequest struct {
	ctx          context.Context
	ApiService   *FreqtradeAPIService
	locksPayload *[]LocksPayload
}

func (r ApiAddLocksApiV1LocksPostRequest) LocksPayload(locksPayload []LocksPayload) ApiAddLocksApiV1LocksPostRequest {
	r.locksPayload = &locksPayload
	return r
}

func (r ApiAddLocksApiV1LocksPostRequest) Execute() (*Locks, *http.Response, error) {
	return r.ApiService.AddLocksApiV1LocksPostExecute(r)
}

/*
AddLocksApiV1LocksPost Add Locks

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddLocksApiV1LocksPostRequest
*/
func (a *FreqtradeAPIService) AddLocksApiV1LocksPost(ctx context.Context) ApiAddLocksApiV1LocksPostRequest {
	return ApiAddLocksApiV1LocksPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Locks
func (a *FreqtradeAPIService) AddLocksApiV1LocksPostExecute(r ApiAddLocksApiV1LocksPostRequest) (*Locks, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Locks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.AddLocksApiV1LocksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/locks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.locksPayload == nil {
		return localVarReturnValue, nil, reportError("locksPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.locksPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiBacktestAbortApiV1BacktestAbortGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiApiBacktestAbortApiV1BacktestAbortGetRequest) Execute() (*BacktestResponse, *http.Response, error) {
	return r.ApiService.ApiBacktestAbortApiV1BacktestAbortGetExecute(r)
}

/*
ApiBacktestAbortApiV1BacktestAbortGet Api Backtest Abort

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiBacktestAbortApiV1BacktestAbortGetRequest
*/
func (a *FreqtradeAPIService) ApiBacktestAbortApiV1BacktestAbortGet(ctx context.Context) ApiApiBacktestAbortApiV1BacktestAbortGetRequest {
	return ApiApiBacktestAbortApiV1BacktestAbortGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BacktestResponse
func (a *FreqtradeAPIService) ApiBacktestAbortApiV1BacktestAbortGetExecute(r ApiApiBacktestAbortApiV1BacktestAbortGetRequest) (*BacktestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BacktestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ApiBacktestAbortApiV1BacktestAbortGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/backtest/abort"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiBacktestHistoryApiV1BacktestHistoryGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiApiBacktestHistoryApiV1BacktestHistoryGetRequest) Execute() ([]BacktestHistoryEntry, *http.Response, error) {
	return r.ApiService.ApiBacktestHistoryApiV1BacktestHistoryGetExecute(r)
}

/*
ApiBacktestHistoryApiV1BacktestHistoryGet Api Backtest History

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiBacktestHistoryApiV1BacktestHistoryGetRequest
*/
func (a *FreqtradeAPIService) ApiBacktestHistoryApiV1BacktestHistoryGet(ctx context.Context) ApiApiBacktestHistoryApiV1BacktestHistoryGetRequest {
	return ApiApiBacktestHistoryApiV1BacktestHistoryGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []BacktestHistoryEntry
func (a *FreqtradeAPIService) ApiBacktestHistoryApiV1BacktestHistoryGetExecute(r ApiApiBacktestHistoryApiV1BacktestHistoryGetRequest) ([]BacktestHistoryEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BacktestHistoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ApiBacktestHistoryApiV1BacktestHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/backtest/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiBacktestHistoryResultApiV1BacktestHistoryResultGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	filename   *string
	strategy   *string
}

func (r ApiApiBacktestHistoryResultApiV1BacktestHistoryResultGetRequest) Filename(filename string) ApiApiBacktestHistoryResultApiV1BacktestHistoryResultGetRequest {
	r.filename = &filename
	return r
}

func (r ApiApiBacktestHistoryResultApiV1BacktestHistoryResultGetRequest) Strategy(strategy string) ApiApiBacktestHistoryResultApiV1BacktestHistoryResultGetRequest {
	r.strategy = &strategy
	return r
}

func (r ApiApiBacktestHistoryResultApiV1BacktestHistoryResultGetRequest) Execute() (*BacktestResponse, *http.Response, error) {
	return r.ApiService.ApiBacktestHistoryResultApiV1BacktestHistoryResultGetExecute(r)
}

/*
ApiBacktestHistoryResultApiV1BacktestHistoryResultGet Api Backtest History Result

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiBacktestHistoryResultApiV1BacktestHistoryResultGetRequest
*/
func (a *FreqtradeAPIService) ApiBacktestHistoryResultApiV1BacktestHistoryResultGet(ctx context.Context) ApiApiBacktestHistoryResultApiV1BacktestHistoryResultGetRequest {
	return ApiApiBacktestHistoryResultApiV1BacktestHistoryResultGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BacktestResponse
func (a *FreqtradeAPIService) ApiBacktestHistoryResultApiV1BacktestHistoryResultGetExecute(r ApiApiBacktestHistoryResultApiV1BacktestHistoryResultGetRequest) (*BacktestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BacktestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ApiBacktestHistoryResultApiV1BacktestHistoryResultGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/backtest/history/result"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filename == nil {
		return localVarReturnValue, nil, reportError("filename is required and must be specified")
	}
	if r.strategy == nil {
		return localVarReturnValue, nil, reportError("strategy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "strategy", r.strategy, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiDeleteBacktestApiV1BacktestDeleteRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiApiDeleteBacktestApiV1BacktestDeleteRequest) Execute() (*BacktestResponse, *http.Response, error) {
	return r.ApiService.ApiDeleteBacktestApiV1BacktestDeleteExecute(r)
}

/*
ApiDeleteBacktestApiV1BacktestDelete Api Delete Backtest

Reset backtesting

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiDeleteBacktestApiV1BacktestDeleteRequest
*/
func (a *FreqtradeAPIService) ApiDeleteBacktestApiV1BacktestDelete(ctx context.Context) ApiApiDeleteBacktestApiV1BacktestDeleteRequest {
	return ApiApiDeleteBacktestApiV1BacktestDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BacktestResponse
func (a *FreqtradeAPIService) ApiDeleteBacktestApiV1BacktestDeleteExecute(r ApiApiDeleteBacktestApiV1BacktestDeleteRequest) (*BacktestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BacktestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ApiDeleteBacktestApiV1BacktestDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/backtest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDeleteRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	file       string
}

func (r ApiApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDeleteRequest) Execute() ([]BacktestHistoryEntry, *http.Response, error) {
	return r.ApiService.ApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDeleteExecute(r)
}

/*
ApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDelete Api Delete Backtest History Entry

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param file
	@return ApiApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDeleteRequest
*/
func (a *FreqtradeAPIService) ApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDelete(ctx context.Context, file string) ApiApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDeleteRequest {
	return ApiApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		file:       file,
	}
}

// Execute executes the request
//
//	@return []BacktestHistoryEntry
func (a *FreqtradeAPIService) ApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDeleteExecute(r ApiApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDeleteRequest) ([]BacktestHistoryEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BacktestHistoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ApiDeleteBacktestHistoryEntryApiV1BacktestHistoryFileDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/backtest/history/{file}"
	localVarPath = strings.Replace(localVarPath, "{"+"file"+"}", url.PathEscape(parameterValueToString(r.file, "file")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiGetBacktestApiV1BacktestGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiApiGetBacktestApiV1BacktestGetRequest) Execute() (*BacktestResponse, *http.Response, error) {
	return r.ApiService.ApiGetBacktestApiV1BacktestGetExecute(r)
}

/*
ApiGetBacktestApiV1BacktestGet Api Get Backtest

Get backtesting result.
Returns Result after backtesting has been ran.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiGetBacktestApiV1BacktestGetRequest
*/
func (a *FreqtradeAPIService) ApiGetBacktestApiV1BacktestGet(ctx context.Context) ApiApiGetBacktestApiV1BacktestGetRequest {
	return ApiApiGetBacktestApiV1BacktestGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BacktestResponse
func (a *FreqtradeAPIService) ApiGetBacktestApiV1BacktestGetExecute(r ApiApiGetBacktestApiV1BacktestGetRequest) (*BacktestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BacktestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ApiGetBacktestApiV1BacktestGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/backtest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	file       string
}

func (r ApiApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGetRequest) Execute() (*BacktestMarketChange, *http.Response, error) {
	return r.ApiService.ApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGetExecute(r)
}

/*
ApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGet Api Get Backtest Market Change

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param file
	@return ApiApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGetRequest
*/
func (a *FreqtradeAPIService) ApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGet(ctx context.Context, file string) ApiApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGetRequest {
	return ApiApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGetRequest{
		ApiService: a,
		ctx:        ctx,
		file:       file,
	}
}

// Execute executes the request
//
//	@return BacktestMarketChange
func (a *FreqtradeAPIService) ApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGetExecute(r ApiApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGetRequest) (*BacktestMarketChange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BacktestMarketChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ApiGetBacktestMarketChangeApiV1BacktestHistoryFileMarketChangeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/backtest/history/{file}/market_change"
	localVarPath = strings.Replace(localVarPath, "{"+"file"+"}", url.PathEscape(parameterValueToString(r.file, "file")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiStartBacktestApiV1BacktestPostRequest struct {
	ctx             context.Context
	ApiService      *FreqtradeAPIService
	backtestRequest *BacktestRequest
}

func (r ApiApiStartBacktestApiV1BacktestPostRequest) BacktestRequest(backtestRequest BacktestRequest) ApiApiStartBacktestApiV1BacktestPostRequest {
	r.backtestRequest = &backtestRequest
	return r
}

func (r ApiApiStartBacktestApiV1BacktestPostRequest) Execute() (*BacktestResponse, *http.Response, error) {
	return r.ApiService.ApiStartBacktestApiV1BacktestPostExecute(r)
}

/*
ApiStartBacktestApiV1BacktestPost Api Start Backtest

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiStartBacktestApiV1BacktestPostRequest
*/
func (a *FreqtradeAPIService) ApiStartBacktestApiV1BacktestPost(ctx context.Context) ApiApiStartBacktestApiV1BacktestPostRequest {
	return ApiApiStartBacktestApiV1BacktestPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BacktestResponse
func (a *FreqtradeAPIService) ApiStartBacktestApiV1BacktestPostExecute(r ApiApiStartBacktestApiV1BacktestPostRequest) (*BacktestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BacktestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ApiStartBacktestApiV1BacktestPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/backtest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.backtestRequest == nil {
		return localVarReturnValue, nil, reportError("backtestRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.backtestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatchRequest struct {
	ctx                    context.Context
	ApiService             *FreqtradeAPIService
	file                   string
	backtestMetadataUpdate *BacktestMetadataUpdate
}

func (r ApiApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatchRequest) BacktestMetadataUpdate(backtestMetadataUpdate BacktestMetadataUpdate) ApiApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatchRequest {
	r.backtestMetadataUpdate = &backtestMetadataUpdate
	return r
}

func (r ApiApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatchRequest) Execute() ([]BacktestHistoryEntry, *http.Response, error) {
	return r.ApiService.ApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatchExecute(r)
}

/*
ApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatch Api Update Backtest History Entry

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param file
	@return ApiApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatchRequest
*/
func (a *FreqtradeAPIService) ApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatch(ctx context.Context, file string) ApiApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatchRequest {
	return ApiApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatchRequest{
		ApiService: a,
		ctx:        ctx,
		file:       file,
	}
}

// Execute executes the request
//
//	@return []BacktestHistoryEntry
func (a *FreqtradeAPIService) ApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatchExecute(r ApiApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatchRequest) ([]BacktestHistoryEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BacktestHistoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ApiUpdateBacktestHistoryEntryApiV1BacktestHistoryFilePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/backtest/history/{file}"
	localVarPath = strings.Replace(localVarPath, "{"+"file"+"}", url.PathEscape(parameterValueToString(r.file, "file")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.backtestMetadataUpdate == nil {
		return localVarReturnValue, nil, reportError("backtestMetadataUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.backtestMetadataUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBackgroundJobApiV1BackgroundJobidGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	jobid      string
}

func (r ApiBackgroundJobApiV1BackgroundJobidGetRequest) Execute() (*BackgroundTaskStatus, *http.Response, error) {
	return r.ApiService.BackgroundJobApiV1BackgroundJobidGetExecute(r)
}

/*
BackgroundJobApiV1BackgroundJobidGet Background Job

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobid
	@return ApiBackgroundJobApiV1BackgroundJobidGetRequest
*/
func (a *FreqtradeAPIService) BackgroundJobApiV1BackgroundJobidGet(ctx context.Context, jobid string) ApiBackgroundJobApiV1BackgroundJobidGetRequest {
	return ApiBackgroundJobApiV1BackgroundJobidGetRequest{
		ApiService: a,
		ctx:        ctx,
		jobid:      jobid,
	}
}

// Execute executes the request
//
//	@return BackgroundTaskStatus
func (a *FreqtradeAPIService) BackgroundJobApiV1BackgroundJobidGetExecute(r ApiBackgroundJobApiV1BackgroundJobidGetRequest) (*BackgroundTaskStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BackgroundTaskStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.BackgroundJobApiV1BackgroundJobidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/background/{jobid}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobid"+"}", url.PathEscape(parameterValueToString(r.jobid, "jobid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBackgroundJobListApiV1BackgroundGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiBackgroundJobListApiV1BackgroundGetRequest) Execute() ([]BackgroundTaskStatus, *http.Response, error) {
	return r.ApiService.BackgroundJobListApiV1BackgroundGetExecute(r)
}

/*
BackgroundJobListApiV1BackgroundGet Background Job List

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBackgroundJobListApiV1BackgroundGetRequest
*/
func (a *FreqtradeAPIService) BackgroundJobListApiV1BackgroundGet(ctx context.Context) ApiBackgroundJobListApiV1BackgroundGetRequest {
	return ApiBackgroundJobListApiV1BackgroundGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []BackgroundTaskStatus
func (a *FreqtradeAPIService) BackgroundJobListApiV1BackgroundGetExecute(r ApiBackgroundJobListApiV1BackgroundGetRequest) ([]BackgroundTaskStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BackgroundTaskStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.BackgroundJobListApiV1BackgroundGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/background"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBalanceApiV1BalanceGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiBalanceApiV1BalanceGetRequest) Execute() (*Balances, *http.Response, error) {
	return r.ApiService.BalanceApiV1BalanceGetExecute(r)
}

/*
BalanceApiV1BalanceGet Balance

Account Balances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBalanceApiV1BalanceGetRequest
*/
func (a *FreqtradeAPIService) BalanceApiV1BalanceGet(ctx context.Context) ApiBalanceApiV1BalanceGetRequest {
	return ApiBalanceApiV1BalanceGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Balances
func (a *FreqtradeAPIService) BalanceApiV1BalanceGetExecute(r ApiBalanceApiV1BalanceGetRequest) (*Balances, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Balances
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.BalanceApiV1BalanceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlacklistApiV1BlacklistGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiBlacklistApiV1BlacklistGetRequest) Execute() (*BlacklistResponse, *http.Response, error) {
	return r.ApiService.BlacklistApiV1BlacklistGetExecute(r)
}

/*
BlacklistApiV1BlacklistGet Blacklist

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBlacklistApiV1BlacklistGetRequest
*/
func (a *FreqtradeAPIService) BlacklistApiV1BlacklistGet(ctx context.Context) ApiBlacklistApiV1BlacklistGetRequest {
	return ApiBlacklistApiV1BlacklistGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BlacklistResponse
func (a *FreqtradeAPIService) BlacklistApiV1BlacklistGetExecute(r ApiBlacklistApiV1BlacklistGetRequest) (*BlacklistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlacklistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.BlacklistApiV1BlacklistGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blacklist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlacklistDeleteApiV1BlacklistDeleteRequest struct {
	ctx           context.Context
	ApiService    *FreqtradeAPIService
	pairsToDelete *[]*string
}

func (r ApiBlacklistDeleteApiV1BlacklistDeleteRequest) PairsToDelete(pairsToDelete []*string) ApiBlacklistDeleteApiV1BlacklistDeleteRequest {
	r.pairsToDelete = &pairsToDelete
	return r
}

func (r ApiBlacklistDeleteApiV1BlacklistDeleteRequest) Execute() (*BlacklistResponse, *http.Response, error) {
	return r.ApiService.BlacklistDeleteApiV1BlacklistDeleteExecute(r)
}

/*
BlacklistDeleteApiV1BlacklistDelete Blacklist Delete

Provide a list of pairs to delete from the blacklist

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBlacklistDeleteApiV1BlacklistDeleteRequest
*/
func (a *FreqtradeAPIService) BlacklistDeleteApiV1BlacklistDelete(ctx context.Context) ApiBlacklistDeleteApiV1BlacklistDeleteRequest {
	return ApiBlacklistDeleteApiV1BlacklistDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BlacklistResponse
func (a *FreqtradeAPIService) BlacklistDeleteApiV1BlacklistDeleteExecute(r ApiBlacklistDeleteApiV1BlacklistDeleteRequest) (*BlacklistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlacklistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.BlacklistDeleteApiV1BlacklistDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blacklist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pairsToDelete != nil {
		t := *r.pairsToDelete
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pairs_to_delete", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pairs_to_delete", t, "form", "multi")
		}
	} else {
		var defaultValue []*string = []*string{}
		parameterAddToHeaderOrQuery(localVarQueryParams, "pairs_to_delete", defaultValue, "form", "multi")
		r.pairsToDelete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlacklistPostApiV1BlacklistPostRequest struct {
	ctx              context.Context
	ApiService       *FreqtradeAPIService
	blacklistPayload *BlacklistPayload
}

func (r ApiBlacklistPostApiV1BlacklistPostRequest) BlacklistPayload(blacklistPayload BlacklistPayload) ApiBlacklistPostApiV1BlacklistPostRequest {
	r.blacklistPayload = &blacklistPayload
	return r
}

func (r ApiBlacklistPostApiV1BlacklistPostRequest) Execute() (*BlacklistResponse, *http.Response, error) {
	return r.ApiService.BlacklistPostApiV1BlacklistPostExecute(r)
}

/*
BlacklistPostApiV1BlacklistPost Blacklist Post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBlacklistPostApiV1BlacklistPostRequest
*/
func (a *FreqtradeAPIService) BlacklistPostApiV1BlacklistPost(ctx context.Context) ApiBlacklistPostApiV1BlacklistPostRequest {
	return ApiBlacklistPostApiV1BlacklistPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BlacklistResponse
func (a *FreqtradeAPIService) BlacklistPostApiV1BlacklistPostExecute(r ApiBlacklistPostApiV1BlacklistPostRequest) (*BlacklistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlacklistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.BlacklistPostApiV1BlacklistPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blacklist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blacklistPayload == nil {
		return localVarReturnValue, nil, reportError("blacklistPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blacklistPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountApiV1CountGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiCountApiV1CountGetRequest) Execute() (*Count, *http.Response, error) {
	return r.ApiService.CountApiV1CountGetExecute(r)
}

/*
CountApiV1CountGet Count

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCountApiV1CountGetRequest
*/
func (a *FreqtradeAPIService) CountApiV1CountGet(ctx context.Context) ApiCountApiV1CountGetRequest {
	return ApiCountApiV1CountGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Count
func (a *FreqtradeAPIService) CountApiV1CountGetExecute(r ApiCountApiV1CountGetRequest) (*Count, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Count
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.CountApiV1CountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDailyApiV1DailyGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	timescale  *int64
}

// Number of days to fetch data for
func (r ApiDailyApiV1DailyGetRequest) Timescale(timescale int64) ApiDailyApiV1DailyGetRequest {
	r.timescale = &timescale
	return r
}

func (r ApiDailyApiV1DailyGetRequest) Execute() (*DailyWeeklyMonthly, *http.Response, error) {
	return r.ApiService.DailyApiV1DailyGetExecute(r)
}

/*
DailyApiV1DailyGet Daily

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDailyApiV1DailyGetRequest
*/
func (a *FreqtradeAPIService) DailyApiV1DailyGet(ctx context.Context) ApiDailyApiV1DailyGetRequest {
	return ApiDailyApiV1DailyGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DailyWeeklyMonthly
func (a *FreqtradeAPIService) DailyApiV1DailyGetExecute(r ApiDailyApiV1DailyGetRequest) (*DailyWeeklyMonthly, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DailyWeeklyMonthly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.DailyApiV1DailyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/daily"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timescale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timescale", r.timescale, "form", "")
	} else {
		var defaultValue int64 = 7
		parameterAddToHeaderOrQuery(localVarQueryParams, "timescale", defaultValue, "form", "")
		r.timescale = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLockApiV1LocksLockidDeleteRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	lockid     int64
}

func (r ApiDeleteLockApiV1LocksLockidDeleteRequest) Execute() (*Locks, *http.Response, error) {
	return r.ApiService.DeleteLockApiV1LocksLockidDeleteExecute(r)
}

/*
DeleteLockApiV1LocksLockidDelete Delete Lock

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lockid
	@return ApiDeleteLockApiV1LocksLockidDeleteRequest
*/
func (a *FreqtradeAPIService) DeleteLockApiV1LocksLockidDelete(ctx context.Context, lockid int64) ApiDeleteLockApiV1LocksLockidDeleteRequest {
	return ApiDeleteLockApiV1LocksLockidDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		lockid:     lockid,
	}
}

// Execute executes the request
//
//	@return Locks
func (a *FreqtradeAPIService) DeleteLockApiV1LocksLockidDeleteExecute(r ApiDeleteLockApiV1LocksLockidDeleteRequest) (*Locks, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Locks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.DeleteLockApiV1LocksLockidDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/locks/{lockid}"
	localVarPath = strings.Replace(localVarPath, "{"+"lockid"+"}", url.PathEscape(parameterValueToString(r.lockid, "lockid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLockPairApiV1LocksDeletePostRequest struct {
	ctx               context.Context
	ApiService        *FreqtradeAPIService
	deleteLockRequest *DeleteLockRequest
}

func (r ApiDeleteLockPairApiV1LocksDeletePostRequest) DeleteLockRequest(deleteLockRequest DeleteLockRequest) ApiDeleteLockPairApiV1LocksDeletePostRequest {
	r.deleteLockRequest = &deleteLockRequest
	return r
}

func (r ApiDeleteLockPairApiV1LocksDeletePostRequest) Execute() (*Locks, *http.Response, error) {
	return r.ApiService.DeleteLockPairApiV1LocksDeletePostExecute(r)
}

/*
DeleteLockPairApiV1LocksDeletePost Delete Lock Pair

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteLockPairApiV1LocksDeletePostRequest
*/
func (a *FreqtradeAPIService) DeleteLockPairApiV1LocksDeletePost(ctx context.Context) ApiDeleteLockPairApiV1LocksDeletePostRequest {
	return ApiDeleteLockPairApiV1LocksDeletePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Locks
func (a *FreqtradeAPIService) DeleteLockPairApiV1LocksDeletePostExecute(r ApiDeleteLockPairApiV1LocksDeletePostRequest) (*Locks, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Locks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.DeleteLockPairApiV1LocksDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/locks/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteLockRequest == nil {
		return localVarReturnValue, nil, reportError("deleteLockRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteLockRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntriesApiV1EntriesGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	pair       *string
}

func (r ApiEntriesApiV1EntriesGetRequest) Pair(pair string) ApiEntriesApiV1EntriesGetRequest {
	r.pair = &pair
	return r
}

func (r ApiEntriesApiV1EntriesGetRequest) Execute() ([]Entry, *http.Response, error) {
	return r.ApiService.EntriesApiV1EntriesGetExecute(r)
}

/*
EntriesApiV1EntriesGet Entries

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEntriesApiV1EntriesGetRequest
*/
func (a *FreqtradeAPIService) EntriesApiV1EntriesGet(ctx context.Context) ApiEntriesApiV1EntriesGetRequest {
	return ApiEntriesApiV1EntriesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Entry
func (a *FreqtradeAPIService) EntriesApiV1EntriesGetExecute(r ApiEntriesApiV1EntriesGetRequest) ([]Entry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Entry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.EntriesApiV1EntriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/entries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExitsApiV1ExitsGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	pair       *string
}

func (r ApiExitsApiV1ExitsGetRequest) Pair(pair string) ApiExitsApiV1ExitsGetRequest {
	r.pair = &pair
	return r
}

func (r ApiExitsApiV1ExitsGetRequest) Execute() ([]Exit, *http.Response, error) {
	return r.ApiService.ExitsApiV1ExitsGetExecute(r)
}

/*
ExitsApiV1ExitsGet Exits

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiExitsApiV1ExitsGetRequest
*/
func (a *FreqtradeAPIService) ExitsApiV1ExitsGet(ctx context.Context) ApiExitsApiV1ExitsGetRequest {
	return ApiExitsApiV1ExitsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Exit
func (a *FreqtradeAPIService) ExitsApiV1ExitsGetExecute(r ApiExitsApiV1ExitsGetRequest) ([]Exit, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Exit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ExitsApiV1ExitsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/exits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceEntryApiV1ForcebuyPostRequest struct {
	ctx               context.Context
	ApiService        *FreqtradeAPIService
	forceEnterPayload *ForceEnterPayload
}

func (r ApiForceEntryApiV1ForcebuyPostRequest) ForceEnterPayload(forceEnterPayload ForceEnterPayload) ApiForceEntryApiV1ForcebuyPostRequest {
	r.forceEnterPayload = &forceEnterPayload
	return r
}

func (r ApiForceEntryApiV1ForcebuyPostRequest) Execute() (*RootModelUnionTradeSchemaStatusMsg, *http.Response, error) {
	return r.ApiService.ForceEntryApiV1ForcebuyPostExecute(r)
}

/*
ForceEntryApiV1ForcebuyPost Force Entry

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiForceEntryApiV1ForcebuyPostRequest
*/
func (a *FreqtradeAPIService) ForceEntryApiV1ForcebuyPost(ctx context.Context) ApiForceEntryApiV1ForcebuyPostRequest {
	return ApiForceEntryApiV1ForcebuyPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RootModelUnionTradeSchemaStatusMsg
func (a *FreqtradeAPIService) ForceEntryApiV1ForcebuyPostExecute(r ApiForceEntryApiV1ForcebuyPostRequest) (*RootModelUnionTradeSchemaStatusMsg, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RootModelUnionTradeSchemaStatusMsg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ForceEntryApiV1ForcebuyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/forcebuy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forceEnterPayload == nil {
		return localVarReturnValue, nil, reportError("forceEnterPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forceEnterPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceEntryApiV1ForceenterPostRequest struct {
	ctx               context.Context
	ApiService        *FreqtradeAPIService
	forceEnterPayload *ForceEnterPayload
}

func (r ApiForceEntryApiV1ForceenterPostRequest) ForceEnterPayload(forceEnterPayload ForceEnterPayload) ApiForceEntryApiV1ForceenterPostRequest {
	r.forceEnterPayload = &forceEnterPayload
	return r
}

func (r ApiForceEntryApiV1ForceenterPostRequest) Execute() (*RootModelUnionTradeSchemaStatusMsg, *http.Response, error) {
	return r.ApiService.ForceEntryApiV1ForceenterPostExecute(r)
}

/*
ForceEntryApiV1ForceenterPost Force Entry

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiForceEntryApiV1ForceenterPostRequest
*/
func (a *FreqtradeAPIService) ForceEntryApiV1ForceenterPost(ctx context.Context) ApiForceEntryApiV1ForceenterPostRequest {
	return ApiForceEntryApiV1ForceenterPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RootModelUnionTradeSchemaStatusMsg
func (a *FreqtradeAPIService) ForceEntryApiV1ForceenterPostExecute(r ApiForceEntryApiV1ForceenterPostRequest) (*RootModelUnionTradeSchemaStatusMsg, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RootModelUnionTradeSchemaStatusMsg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ForceEntryApiV1ForceenterPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/forceenter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forceEnterPayload == nil {
		return localVarReturnValue, nil, reportError("forceEnterPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forceEnterPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceexitApiV1ForceexitPostRequest struct {
	ctx              context.Context
	ApiService       *FreqtradeAPIService
	forceExitPayload *ForceExitPayload
}

func (r ApiForceexitApiV1ForceexitPostRequest) ForceExitPayload(forceExitPayload ForceExitPayload) ApiForceexitApiV1ForceexitPostRequest {
	r.forceExitPayload = &forceExitPayload
	return r
}

func (r ApiForceexitApiV1ForceexitPostRequest) Execute() (*ResultMsg, *http.Response, error) {
	return r.ApiService.ForceexitApiV1ForceexitPostExecute(r)
}

/*
ForceexitApiV1ForceexitPost Forceexit

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiForceexitApiV1ForceexitPostRequest
*/
func (a *FreqtradeAPIService) ForceexitApiV1ForceexitPost(ctx context.Context) ApiForceexitApiV1ForceexitPostRequest {
	return ApiForceexitApiV1ForceexitPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ResultMsg
func (a *FreqtradeAPIService) ForceexitApiV1ForceexitPostExecute(r ApiForceexitApiV1ForceexitPostRequest) (*ResultMsg, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResultMsg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ForceexitApiV1ForceexitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/forceexit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forceExitPayload == nil {
		return localVarReturnValue, nil, reportError("forceExitPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forceExitPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceexitApiV1ForcesellPostRequest struct {
	ctx              context.Context
	ApiService       *FreqtradeAPIService
	forceExitPayload *ForceExitPayload
}

func (r ApiForceexitApiV1ForcesellPostRequest) ForceExitPayload(forceExitPayload ForceExitPayload) ApiForceexitApiV1ForcesellPostRequest {
	r.forceExitPayload = &forceExitPayload
	return r
}

func (r ApiForceexitApiV1ForcesellPostRequest) Execute() (*ResultMsg, *http.Response, error) {
	return r.ApiService.ForceexitApiV1ForcesellPostExecute(r)
}

/*
ForceexitApiV1ForcesellPost Forceexit

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiForceexitApiV1ForcesellPostRequest
*/
func (a *FreqtradeAPIService) ForceexitApiV1ForcesellPost(ctx context.Context) ApiForceexitApiV1ForcesellPostRequest {
	return ApiForceexitApiV1ForcesellPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ResultMsg
func (a *FreqtradeAPIService) ForceexitApiV1ForcesellPostExecute(r ApiForceexitApiV1ForcesellPostRequest) (*ResultMsg, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResultMsg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ForceexitApiV1ForcesellPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/forcesell"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forceExitPayload == nil {
		return localVarReturnValue, nil, reportError("forceExitPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forceExitPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStrategyApiV1StrategyStrategyGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	strategy   string
}

func (r ApiGetStrategyApiV1StrategyStrategyGetRequest) Execute() (*StrategyResponse, *http.Response, error) {
	return r.ApiService.GetStrategyApiV1StrategyStrategyGetExecute(r)
}

/*
GetStrategyApiV1StrategyStrategyGet Get Strategy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param strategy
	@return ApiGetStrategyApiV1StrategyStrategyGetRequest
*/
func (a *FreqtradeAPIService) GetStrategyApiV1StrategyStrategyGet(ctx context.Context, strategy string) ApiGetStrategyApiV1StrategyStrategyGetRequest {
	return ApiGetStrategyApiV1StrategyStrategyGetRequest{
		ApiService: a,
		ctx:        ctx,
		strategy:   strategy,
	}
}

// Execute executes the request
//
//	@return StrategyResponse
func (a *FreqtradeAPIService) GetStrategyApiV1StrategyStrategyGetExecute(r ApiGetStrategyApiV1StrategyStrategyGetRequest) (*StrategyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StrategyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.GetStrategyApiV1StrategyStrategyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/strategy/{strategy}"
	localVarPath = strings.Replace(localVarPath, "{"+"strategy"+"}", url.PathEscape(parameterValueToString(r.strategy, "strategy")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHealthApiV1HealthGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiHealthApiV1HealthGetRequest) Execute() (*Health, *http.Response, error) {
	return r.ApiService.HealthApiV1HealthGetExecute(r)
}

/*
HealthApiV1HealthGet Health

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHealthApiV1HealthGetRequest
*/
func (a *FreqtradeAPIService) HealthApiV1HealthGet(ctx context.Context) ApiHealthApiV1HealthGetRequest {
	return ApiHealthApiV1HealthGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Health
func (a *FreqtradeAPIService) HealthApiV1HealthGetExecute(r ApiHealthApiV1HealthGetRequest) (*Health, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Health
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.HealthApiV1HealthGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailablePairsApiV1AvailablePairsGetRequest struct {
	ctx           context.Context
	ApiService    *FreqtradeAPIService
	timeframe     *string
	stakeCurrency *string
	candletype    *CandleType
}

func (r ApiListAvailablePairsApiV1AvailablePairsGetRequest) Timeframe(timeframe string) ApiListAvailablePairsApiV1AvailablePairsGetRequest {
	r.timeframe = &timeframe
	return r
}

func (r ApiListAvailablePairsApiV1AvailablePairsGetRequest) StakeCurrency(stakeCurrency string) ApiListAvailablePairsApiV1AvailablePairsGetRequest {
	r.stakeCurrency = &stakeCurrency
	return r
}

func (r ApiListAvailablePairsApiV1AvailablePairsGetRequest) Candletype(candletype CandleType) ApiListAvailablePairsApiV1AvailablePairsGetRequest {
	r.candletype = &candletype
	return r
}

func (r ApiListAvailablePairsApiV1AvailablePairsGetRequest) Execute() (*AvailablePairs, *http.Response, error) {
	return r.ApiService.ListAvailablePairsApiV1AvailablePairsGetExecute(r)
}

/*
ListAvailablePairsApiV1AvailablePairsGet List Available Pairs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAvailablePairsApiV1AvailablePairsGetRequest
*/
func (a *FreqtradeAPIService) ListAvailablePairsApiV1AvailablePairsGet(ctx context.Context) ApiListAvailablePairsApiV1AvailablePairsGetRequest {
	return ApiListAvailablePairsApiV1AvailablePairsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AvailablePairs
func (a *FreqtradeAPIService) ListAvailablePairsApiV1AvailablePairsGetExecute(r ApiListAvailablePairsApiV1AvailablePairsGetRequest) (*AvailablePairs, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AvailablePairs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ListAvailablePairsApiV1AvailablePairsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/available_pairs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeframe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeframe", r.timeframe, "form", "")
	}
	if r.stakeCurrency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stake_currency", r.stakeCurrency, "form", "")
	}
	if r.candletype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candletype", r.candletype, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCustomDataApiV1TradesTradeIdCustomDataGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	tradeId    int64
	key        *string
}

func (r ApiListCustomDataApiV1TradesTradeIdCustomDataGetRequest) Key(key string) ApiListCustomDataApiV1TradesTradeIdCustomDataGetRequest {
	r.key = &key
	return r
}

func (r ApiListCustomDataApiV1TradesTradeIdCustomDataGetRequest) Execute() ([]ListCustomData, *http.Response, error) {
	return r.ApiService.ListCustomDataApiV1TradesTradeIdCustomDataGetExecute(r)
}

/*
ListCustomDataApiV1TradesTradeIdCustomDataGet List Custom Data

Fetch custom data for a specific trade.
If a key is provided, it will be used to filter data accordingly.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tradeId
	@return ApiListCustomDataApiV1TradesTradeIdCustomDataGetRequest
*/
func (a *FreqtradeAPIService) ListCustomDataApiV1TradesTradeIdCustomDataGet(ctx context.Context, tradeId int64) ApiListCustomDataApiV1TradesTradeIdCustomDataGetRequest {
	return ApiListCustomDataApiV1TradesTradeIdCustomDataGetRequest{
		ApiService: a,
		ctx:        ctx,
		tradeId:    tradeId,
	}
}

// Execute executes the request
//
//	@return []ListCustomData
func (a *FreqtradeAPIService) ListCustomDataApiV1TradesTradeIdCustomDataGetExecute(r ApiListCustomDataApiV1TradesTradeIdCustomDataGetRequest) ([]ListCustomData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ListCustomData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ListCustomDataApiV1TradesTradeIdCustomDataGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/trades/{trade_id}/custom-data"
	localVarPath = strings.Replace(localVarPath, "{"+"trade_id"+"}", url.PathEscape(parameterValueToString(r.tradeId, "tradeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExchangesApiV1ExchangesGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiListExchangesApiV1ExchangesGetRequest) Execute() (*ExchangeListResponse, *http.Response, error) {
	return r.ApiService.ListExchangesApiV1ExchangesGetExecute(r)
}

/*
ListExchangesApiV1ExchangesGet List Exchanges

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListExchangesApiV1ExchangesGetRequest
*/
func (a *FreqtradeAPIService) ListExchangesApiV1ExchangesGet(ctx context.Context) ApiListExchangesApiV1ExchangesGetRequest {
	return ApiListExchangesApiV1ExchangesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ExchangeListResponse
func (a *FreqtradeAPIService) ListExchangesApiV1ExchangesGetExecute(r ApiListExchangesApiV1ExchangesGetRequest) (*ExchangeListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExchangeListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ListExchangesApiV1ExchangesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/exchanges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFreqaimodelsApiV1FreqaimodelsGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiListFreqaimodelsApiV1FreqaimodelsGetRequest) Execute() (*FreqAIModelListResponse, *http.Response, error) {
	return r.ApiService.ListFreqaimodelsApiV1FreqaimodelsGetExecute(r)
}

/*
ListFreqaimodelsApiV1FreqaimodelsGet List Freqaimodels

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListFreqaimodelsApiV1FreqaimodelsGetRequest
*/
func (a *FreqtradeAPIService) ListFreqaimodelsApiV1FreqaimodelsGet(ctx context.Context) ApiListFreqaimodelsApiV1FreqaimodelsGetRequest {
	return ApiListFreqaimodelsApiV1FreqaimodelsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FreqAIModelListResponse
func (a *FreqtradeAPIService) ListFreqaimodelsApiV1FreqaimodelsGetExecute(r ApiListFreqaimodelsApiV1FreqaimodelsGetRequest) (*FreqAIModelListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FreqAIModelListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ListFreqaimodelsApiV1FreqaimodelsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/freqaimodels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListHyperoptlossApiV1HyperoptlossGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiListHyperoptlossApiV1HyperoptlossGetRequest) Execute() (*HyperoptLossListResponse, *http.Response, error) {
	return r.ApiService.ListHyperoptlossApiV1HyperoptlossGetExecute(r)
}

/*
ListHyperoptlossApiV1HyperoptlossGet List Hyperoptloss

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListHyperoptlossApiV1HyperoptlossGetRequest
*/
func (a *FreqtradeAPIService) ListHyperoptlossApiV1HyperoptlossGet(ctx context.Context) ApiListHyperoptlossApiV1HyperoptlossGetRequest {
	return ApiListHyperoptlossApiV1HyperoptlossGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return HyperoptLossListResponse
func (a *FreqtradeAPIService) ListHyperoptlossApiV1HyperoptlossGetExecute(r ApiListHyperoptlossApiV1HyperoptlossGetRequest) (*HyperoptLossListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HyperoptLossListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ListHyperoptlossApiV1HyperoptlossGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/hyperoptloss"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	key        *string
	limit      *int64
	offset     *int64
}

// Optional key to filter data
func (r ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest) Key(key string) ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest {
	r.key = &key
	return r
}

// Maximum number of different trades to return data
func (r ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest) Limit(limit int64) ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest {
	r.limit = &limit
	return r
}

// Number of trades to skip for pagination
func (r ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest) Offset(offset int64) ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest {
	r.offset = &offset
	return r
}

func (r ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest) Execute() ([]ListCustomData, *http.Response, error) {
	return r.ApiService.ListOpenTradesCustomDataApiV1TradesOpenCustomDataGetExecute(r)
}

/*
ListOpenTradesCustomDataApiV1TradesOpenCustomDataGet List Open Trades Custom Data

Fetch custom data for all open trades.
If a key is provided, it will be used to filter data accordingly.
Pagination is implemented via the `limit` and `offset` parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest
*/
func (a *FreqtradeAPIService) ListOpenTradesCustomDataApiV1TradesOpenCustomDataGet(ctx context.Context) ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest {
	return ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ListCustomData
func (a *FreqtradeAPIService) ListOpenTradesCustomDataApiV1TradesOpenCustomDataGetExecute(r ApiListOpenTradesCustomDataApiV1TradesOpenCustomDataGetRequest) ([]ListCustomData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ListCustomData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ListOpenTradesCustomDataApiV1TradesOpenCustomDataGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/trades/open/custom-data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 100
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", defaultValue, "form", "")
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPairlistsApiV1PairlistsAvailableGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiListPairlistsApiV1PairlistsAvailableGetRequest) Execute() (*PairListsResponse, *http.Response, error) {
	return r.ApiService.ListPairlistsApiV1PairlistsAvailableGetExecute(r)
}

/*
ListPairlistsApiV1PairlistsAvailableGet List Pairlists

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListPairlistsApiV1PairlistsAvailableGetRequest
*/
func (a *FreqtradeAPIService) ListPairlistsApiV1PairlistsAvailableGet(ctx context.Context) ApiListPairlistsApiV1PairlistsAvailableGetRequest {
	return ApiListPairlistsApiV1PairlistsAvailableGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PairListsResponse
func (a *FreqtradeAPIService) ListPairlistsApiV1PairlistsAvailableGetExecute(r ApiListPairlistsApiV1PairlistsAvailableGetRequest) (*PairListsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PairListsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ListPairlistsApiV1PairlistsAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/pairlists/available"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStrategiesApiV1StrategiesGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiListStrategiesApiV1StrategiesGetRequest) Execute() (*StrategyListResponse, *http.Response, error) {
	return r.ApiService.ListStrategiesApiV1StrategiesGetExecute(r)
}

/*
ListStrategiesApiV1StrategiesGet List Strategies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListStrategiesApiV1StrategiesGetRequest
*/
func (a *FreqtradeAPIService) ListStrategiesApiV1StrategiesGet(ctx context.Context) ApiListStrategiesApiV1StrategiesGetRequest {
	return ApiListStrategiesApiV1StrategiesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StrategyListResponse
func (a *FreqtradeAPIService) ListStrategiesApiV1StrategiesGetExecute(r ApiListStrategiesApiV1StrategiesGetRequest) (*StrategyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StrategyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ListStrategiesApiV1StrategiesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/strategies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLocksApiV1LocksGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiLocksApiV1LocksGetRequest) Execute() (*Locks, *http.Response, error) {
	return r.ApiService.LocksApiV1LocksGetExecute(r)
}

/*
LocksApiV1LocksGet Locks

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocksApiV1LocksGetRequest
*/
func (a *FreqtradeAPIService) LocksApiV1LocksGet(ctx context.Context) ApiLocksApiV1LocksGetRequest {
	return ApiLocksApiV1LocksGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Locks
func (a *FreqtradeAPIService) LocksApiV1LocksGetExecute(r ApiLocksApiV1LocksGetRequest) (*Locks, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Locks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.LocksApiV1LocksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/locks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLogsApiV1LogsGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	limit      *int64
}

func (r ApiLogsApiV1LogsGetRequest) Limit(limit int64) ApiLogsApiV1LogsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiLogsApiV1LogsGetRequest) Execute() (*Logs, *http.Response, error) {
	return r.ApiService.LogsApiV1LogsGetExecute(r)
}

/*
LogsApiV1LogsGet Logs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLogsApiV1LogsGetRequest
*/
func (a *FreqtradeAPIService) LogsApiV1LogsGet(ctx context.Context) ApiLogsApiV1LogsGetRequest {
	return ApiLogsApiV1LogsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Logs
func (a *FreqtradeAPIService) LogsApiV1LogsGetExecute(r ApiLogsApiV1LogsGetRequest) (*Logs, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Logs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.LogsApiV1LogsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarketsApiV1MarketsGetRequest struct {
	ctx         context.Context
	ApiService  *FreqtradeAPIService
	tradingMode *TradingMode
	marginMode  *MarginMode
	exchange    *string
	base        *string
	quote       *string
}

func (r ApiMarketsApiV1MarketsGetRequest) TradingMode(tradingMode TradingMode) ApiMarketsApiV1MarketsGetRequest {
	r.tradingMode = &tradingMode
	return r
}

func (r ApiMarketsApiV1MarketsGetRequest) MarginMode(marginMode MarginMode) ApiMarketsApiV1MarketsGetRequest {
	r.marginMode = &marginMode
	return r
}

func (r ApiMarketsApiV1MarketsGetRequest) Exchange(exchange string) ApiMarketsApiV1MarketsGetRequest {
	r.exchange = &exchange
	return r
}

func (r ApiMarketsApiV1MarketsGetRequest) Base(base string) ApiMarketsApiV1MarketsGetRequest {
	r.base = &base
	return r
}

func (r ApiMarketsApiV1MarketsGetRequest) Quote(quote string) ApiMarketsApiV1MarketsGetRequest {
	r.quote = &quote
	return r
}

func (r ApiMarketsApiV1MarketsGetRequest) Execute() (*MarketResponse, *http.Response, error) {
	return r.ApiService.MarketsApiV1MarketsGetExecute(r)
}

/*
MarketsApiV1MarketsGet Markets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMarketsApiV1MarketsGetRequest
*/
func (a *FreqtradeAPIService) MarketsApiV1MarketsGet(ctx context.Context) ApiMarketsApiV1MarketsGetRequest {
	return ApiMarketsApiV1MarketsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MarketResponse
func (a *FreqtradeAPIService) MarketsApiV1MarketsGetExecute(r ApiMarketsApiV1MarketsGetRequest) (*MarketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MarketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.MarketsApiV1MarketsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/markets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tradingMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trading_mode", r.tradingMode, "form", "")
	}
	if r.marginMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "margin_mode", r.marginMode, "form", "")
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.base != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base", r.base, "form", "")
	}
	if r.quote != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quote", r.quote, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMixTagsApiV1MixTagsGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	pair       *string
}

func (r ApiMixTagsApiV1MixTagsGetRequest) Pair(pair string) ApiMixTagsApiV1MixTagsGetRequest {
	r.pair = &pair
	return r
}

func (r ApiMixTagsApiV1MixTagsGetRequest) Execute() ([]MixTag, *http.Response, error) {
	return r.ApiService.MixTagsApiV1MixTagsGetExecute(r)
}

/*
MixTagsApiV1MixTagsGet Mix Tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMixTagsApiV1MixTagsGetRequest
*/
func (a *FreqtradeAPIService) MixTagsApiV1MixTagsGet(ctx context.Context) ApiMixTagsApiV1MixTagsGetRequest {
	return ApiMixTagsApiV1MixTagsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []MixTag
func (a *FreqtradeAPIService) MixTagsApiV1MixTagsGetExecute(r ApiMixTagsApiV1MixTagsGetRequest) ([]MixTag, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []MixTag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.MixTagsApiV1MixTagsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/mix_tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonthlyApiV1MonthlyGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	timescale  *int64
}

// Number of months to fetch data for
func (r ApiMonthlyApiV1MonthlyGetRequest) Timescale(timescale int64) ApiMonthlyApiV1MonthlyGetRequest {
	r.timescale = &timescale
	return r
}

func (r ApiMonthlyApiV1MonthlyGetRequest) Execute() (*DailyWeeklyMonthly, *http.Response, error) {
	return r.ApiService.MonthlyApiV1MonthlyGetExecute(r)
}

/*
MonthlyApiV1MonthlyGet Monthly

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMonthlyApiV1MonthlyGetRequest
*/
func (a *FreqtradeAPIService) MonthlyApiV1MonthlyGet(ctx context.Context) ApiMonthlyApiV1MonthlyGetRequest {
	return ApiMonthlyApiV1MonthlyGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DailyWeeklyMonthly
func (a *FreqtradeAPIService) MonthlyApiV1MonthlyGetExecute(r ApiMonthlyApiV1MonthlyGetRequest) (*DailyWeeklyMonthly, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DailyWeeklyMonthly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.MonthlyApiV1MonthlyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/monthly"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timescale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timescale", r.timescale, "form", "")
	} else {
		var defaultValue int64 = 3
		parameterAddToHeaderOrQuery(localVarQueryParams, "timescale", defaultValue, "form", "")
		r.timescale = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPairCandlesApiV1PairCandlesGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	pair       *string
	timeframe  *string
	limit      *int64
}

func (r ApiPairCandlesApiV1PairCandlesGetRequest) Pair(pair string) ApiPairCandlesApiV1PairCandlesGetRequest {
	r.pair = &pair
	return r
}

func (r ApiPairCandlesApiV1PairCandlesGetRequest) Timeframe(timeframe string) ApiPairCandlesApiV1PairCandlesGetRequest {
	r.timeframe = &timeframe
	return r
}

func (r ApiPairCandlesApiV1PairCandlesGetRequest) Limit(limit int64) ApiPairCandlesApiV1PairCandlesGetRequest {
	r.limit = &limit
	return r
}

func (r ApiPairCandlesApiV1PairCandlesGetRequest) Execute() (*PairHistory, *http.Response, error) {
	return r.ApiService.PairCandlesApiV1PairCandlesGetExecute(r)
}

/*
PairCandlesApiV1PairCandlesGet Pair Candles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPairCandlesApiV1PairCandlesGetRequest
*/
func (a *FreqtradeAPIService) PairCandlesApiV1PairCandlesGet(ctx context.Context) ApiPairCandlesApiV1PairCandlesGetRequest {
	return ApiPairCandlesApiV1PairCandlesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PairHistory
func (a *FreqtradeAPIService) PairCandlesApiV1PairCandlesGetExecute(r ApiPairCandlesApiV1PairCandlesGetRequest) (*PairHistory, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PairHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PairCandlesApiV1PairCandlesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/pair_candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pair == nil {
		return localVarReturnValue, nil, reportError("pair is required and must be specified")
	}
	if r.timeframe == nil {
		return localVarReturnValue, nil, reportError("timeframe is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "timeframe", r.timeframe, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPairCandlesFilteredApiV1PairCandlesPostRequest struct {
	ctx                context.Context
	ApiService         *FreqtradeAPIService
	pairCandlesRequest *PairCandlesRequest
}

func (r ApiPairCandlesFilteredApiV1PairCandlesPostRequest) PairCandlesRequest(pairCandlesRequest PairCandlesRequest) ApiPairCandlesFilteredApiV1PairCandlesPostRequest {
	r.pairCandlesRequest = &pairCandlesRequest
	return r
}

func (r ApiPairCandlesFilteredApiV1PairCandlesPostRequest) Execute() (*PairHistory, *http.Response, error) {
	return r.ApiService.PairCandlesFilteredApiV1PairCandlesPostExecute(r)
}

/*
PairCandlesFilteredApiV1PairCandlesPost Pair Candles Filtered

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPairCandlesFilteredApiV1PairCandlesPostRequest
*/
func (a *FreqtradeAPIService) PairCandlesFilteredApiV1PairCandlesPost(ctx context.Context) ApiPairCandlesFilteredApiV1PairCandlesPostRequest {
	return ApiPairCandlesFilteredApiV1PairCandlesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PairHistory
func (a *FreqtradeAPIService) PairCandlesFilteredApiV1PairCandlesPostExecute(r ApiPairCandlesFilteredApiV1PairCandlesPostRequest) (*PairHistory, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PairHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PairCandlesFilteredApiV1PairCandlesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/pair_candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pairCandlesRequest == nil {
		return localVarReturnValue, nil, reportError("pairCandlesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pairCandlesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPairHistoryApiV1PairHistoryGetRequest struct {
	ctx         context.Context
	ApiService  *FreqtradeAPIService
	pair        *string
	timeframe   *string
	timerange   *string
	strategy    *string
	freqaimodel *string
}

func (r ApiPairHistoryApiV1PairHistoryGetRequest) Pair(pair string) ApiPairHistoryApiV1PairHistoryGetRequest {
	r.pair = &pair
	return r
}

func (r ApiPairHistoryApiV1PairHistoryGetRequest) Timeframe(timeframe string) ApiPairHistoryApiV1PairHistoryGetRequest {
	r.timeframe = &timeframe
	return r
}

func (r ApiPairHistoryApiV1PairHistoryGetRequest) Timerange(timerange string) ApiPairHistoryApiV1PairHistoryGetRequest {
	r.timerange = &timerange
	return r
}

func (r ApiPairHistoryApiV1PairHistoryGetRequest) Strategy(strategy string) ApiPairHistoryApiV1PairHistoryGetRequest {
	r.strategy = &strategy
	return r
}

func (r ApiPairHistoryApiV1PairHistoryGetRequest) Freqaimodel(freqaimodel string) ApiPairHistoryApiV1PairHistoryGetRequest {
	r.freqaimodel = &freqaimodel
	return r
}

func (r ApiPairHistoryApiV1PairHistoryGetRequest) Execute() (*PairHistory, *http.Response, error) {
	return r.ApiService.PairHistoryApiV1PairHistoryGetExecute(r)
}

/*
PairHistoryApiV1PairHistoryGet Pair History

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPairHistoryApiV1PairHistoryGetRequest
*/
func (a *FreqtradeAPIService) PairHistoryApiV1PairHistoryGet(ctx context.Context) ApiPairHistoryApiV1PairHistoryGetRequest {
	return ApiPairHistoryApiV1PairHistoryGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PairHistory
func (a *FreqtradeAPIService) PairHistoryApiV1PairHistoryGetExecute(r ApiPairHistoryApiV1PairHistoryGetRequest) (*PairHistory, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PairHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PairHistoryApiV1PairHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/pair_history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pair == nil {
		return localVarReturnValue, nil, reportError("pair is required and must be specified")
	}
	if r.timeframe == nil {
		return localVarReturnValue, nil, reportError("timeframe is required and must be specified")
	}
	if r.timerange == nil {
		return localVarReturnValue, nil, reportError("timerange is required and must be specified")
	}
	if r.strategy == nil {
		return localVarReturnValue, nil, reportError("strategy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "timeframe", r.timeframe, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "timerange", r.timerange, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "strategy", r.strategy, "form", "")
	if r.freqaimodel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "freqaimodel", r.freqaimodel, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPairHistoryFilteredApiV1PairHistoryPostRequest struct {
	ctx                context.Context
	ApiService         *FreqtradeAPIService
	pairHistoryRequest *PairHistoryRequest
}

func (r ApiPairHistoryFilteredApiV1PairHistoryPostRequest) PairHistoryRequest(pairHistoryRequest PairHistoryRequest) ApiPairHistoryFilteredApiV1PairHistoryPostRequest {
	r.pairHistoryRequest = &pairHistoryRequest
	return r
}

func (r ApiPairHistoryFilteredApiV1PairHistoryPostRequest) Execute() (*PairHistory, *http.Response, error) {
	return r.ApiService.PairHistoryFilteredApiV1PairHistoryPostExecute(r)
}

/*
PairHistoryFilteredApiV1PairHistoryPost Pair History Filtered

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPairHistoryFilteredApiV1PairHistoryPostRequest
*/
func (a *FreqtradeAPIService) PairHistoryFilteredApiV1PairHistoryPost(ctx context.Context) ApiPairHistoryFilteredApiV1PairHistoryPostRequest {
	return ApiPairHistoryFilteredApiV1PairHistoryPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PairHistory
func (a *FreqtradeAPIService) PairHistoryFilteredApiV1PairHistoryPostExecute(r ApiPairHistoryFilteredApiV1PairHistoryPostRequest) (*PairHistory, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PairHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PairHistoryFilteredApiV1PairHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/pair_history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pairHistoryRequest == nil {
		return localVarReturnValue, nil, reportError("pairHistoryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pairHistoryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPairlistsEvaluateApiV1DownloadDataPostRequest struct {
	ctx                 context.Context
	ApiService          *FreqtradeAPIService
	downloadDataPayload *DownloadDataPayload
}

func (r ApiPairlistsEvaluateApiV1DownloadDataPostRequest) DownloadDataPayload(downloadDataPayload DownloadDataPayload) ApiPairlistsEvaluateApiV1DownloadDataPostRequest {
	r.downloadDataPayload = &downloadDataPayload
	return r
}

func (r ApiPairlistsEvaluateApiV1DownloadDataPostRequest) Execute() (*BgJobStarted, *http.Response, error) {
	return r.ApiService.PairlistsEvaluateApiV1DownloadDataPostExecute(r)
}

/*
PairlistsEvaluateApiV1DownloadDataPost Pairlists Evaluate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPairlistsEvaluateApiV1DownloadDataPostRequest
*/
func (a *FreqtradeAPIService) PairlistsEvaluateApiV1DownloadDataPost(ctx context.Context) ApiPairlistsEvaluateApiV1DownloadDataPostRequest {
	return ApiPairlistsEvaluateApiV1DownloadDataPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BgJobStarted
func (a *FreqtradeAPIService) PairlistsEvaluateApiV1DownloadDataPostExecute(r ApiPairlistsEvaluateApiV1DownloadDataPostRequest) (*BgJobStarted, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BgJobStarted
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PairlistsEvaluateApiV1DownloadDataPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/download_data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadDataPayload == nil {
		return localVarReturnValue, nil, reportError("downloadDataPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.downloadDataPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPairlistsEvaluateApiV1PairlistsEvaluatePostRequest struct {
	ctx              context.Context
	ApiService       *FreqtradeAPIService
	pairListsPayload *PairListsPayload
}

func (r ApiPairlistsEvaluateApiV1PairlistsEvaluatePostRequest) PairListsPayload(pairListsPayload PairListsPayload) ApiPairlistsEvaluateApiV1PairlistsEvaluatePostRequest {
	r.pairListsPayload = &pairListsPayload
	return r
}

func (r ApiPairlistsEvaluateApiV1PairlistsEvaluatePostRequest) Execute() (*BgJobStarted, *http.Response, error) {
	return r.ApiService.PairlistsEvaluateApiV1PairlistsEvaluatePostExecute(r)
}

/*
PairlistsEvaluateApiV1PairlistsEvaluatePost Pairlists Evaluate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPairlistsEvaluateApiV1PairlistsEvaluatePostRequest
*/
func (a *FreqtradeAPIService) PairlistsEvaluateApiV1PairlistsEvaluatePost(ctx context.Context) ApiPairlistsEvaluateApiV1PairlistsEvaluatePostRequest {
	return ApiPairlistsEvaluateApiV1PairlistsEvaluatePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BgJobStarted
func (a *FreqtradeAPIService) PairlistsEvaluateApiV1PairlistsEvaluatePostExecute(r ApiPairlistsEvaluateApiV1PairlistsEvaluatePostRequest) (*BgJobStarted, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BgJobStarted
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PairlistsEvaluateApiV1PairlistsEvaluatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/pairlists/evaluate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pairListsPayload == nil {
		return localVarReturnValue, nil, reportError("pairListsPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pairListsPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPairlistsEvaluateGetApiV1PairlistsEvaluateJobidGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	jobid      string
}

func (r ApiPairlistsEvaluateGetApiV1PairlistsEvaluateJobidGetRequest) Execute() (*WhitelistEvaluateResponse, *http.Response, error) {
	return r.ApiService.PairlistsEvaluateGetApiV1PairlistsEvaluateJobidGetExecute(r)
}

/*
PairlistsEvaluateGetApiV1PairlistsEvaluateJobidGet Pairlists Evaluate Get

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobid
	@return ApiPairlistsEvaluateGetApiV1PairlistsEvaluateJobidGetRequest
*/
func (a *FreqtradeAPIService) PairlistsEvaluateGetApiV1PairlistsEvaluateJobidGet(ctx context.Context, jobid string) ApiPairlistsEvaluateGetApiV1PairlistsEvaluateJobidGetRequest {
	return ApiPairlistsEvaluateGetApiV1PairlistsEvaluateJobidGetRequest{
		ApiService: a,
		ctx:        ctx,
		jobid:      jobid,
	}
}

// Execute executes the request
//
//	@return WhitelistEvaluateResponse
func (a *FreqtradeAPIService) PairlistsEvaluateGetApiV1PairlistsEvaluateJobidGetExecute(r ApiPairlistsEvaluateGetApiV1PairlistsEvaluateJobidGetRequest) (*WhitelistEvaluateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WhitelistEvaluateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PairlistsEvaluateGetApiV1PairlistsEvaluateJobidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/pairlists/evaluate/{jobid}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobid"+"}", url.PathEscape(parameterValueToString(r.jobid, "jobid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseApiV1PausePostRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiPauseApiV1PausePostRequest) Execute() (*StatusMsg, *http.Response, error) {
	return r.ApiService.PauseApiV1PausePostExecute(r)
}

/*
PauseApiV1PausePost Pause

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPauseApiV1PausePostRequest
*/
func (a *FreqtradeAPIService) PauseApiV1PausePost(ctx context.Context) ApiPauseApiV1PausePostRequest {
	return ApiPauseApiV1PausePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusMsg
func (a *FreqtradeAPIService) PauseApiV1PausePostExecute(r ApiPauseApiV1PausePostRequest) (*StatusMsg, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusMsg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PauseApiV1PausePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/pause"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseApiV1StopbuyPostRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiPauseApiV1StopbuyPostRequest) Execute() (*StatusMsg, *http.Response, error) {
	return r.ApiService.PauseApiV1StopbuyPostExecute(r)
}

/*
PauseApiV1StopbuyPost Pause

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPauseApiV1StopbuyPostRequest
*/
func (a *FreqtradeAPIService) PauseApiV1StopbuyPost(ctx context.Context) ApiPauseApiV1StopbuyPostRequest {
	return ApiPauseApiV1StopbuyPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusMsg
func (a *FreqtradeAPIService) PauseApiV1StopbuyPostExecute(r ApiPauseApiV1StopbuyPostRequest) (*StatusMsg, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusMsg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PauseApiV1StopbuyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/stopbuy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseApiV1StopentryPostRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiPauseApiV1StopentryPostRequest) Execute() (*StatusMsg, *http.Response, error) {
	return r.ApiService.PauseApiV1StopentryPostExecute(r)
}

/*
PauseApiV1StopentryPost Pause

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPauseApiV1StopentryPostRequest
*/
func (a *FreqtradeAPIService) PauseApiV1StopentryPost(ctx context.Context) ApiPauseApiV1StopentryPostRequest {
	return ApiPauseApiV1StopentryPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusMsg
func (a *FreqtradeAPIService) PauseApiV1StopentryPostExecute(r ApiPauseApiV1StopentryPostRequest) (*StatusMsg, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusMsg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PauseApiV1StopentryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/stopentry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPerformanceApiV1PerformanceGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiPerformanceApiV1PerformanceGetRequest) Execute() ([]PerformanceEntry, *http.Response, error) {
	return r.ApiService.PerformanceApiV1PerformanceGetExecute(r)
}

/*
PerformanceApiV1PerformanceGet Performance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPerformanceApiV1PerformanceGetRequest
*/
func (a *FreqtradeAPIService) PerformanceApiV1PerformanceGet(ctx context.Context) ApiPerformanceApiV1PerformanceGetRequest {
	return ApiPerformanceApiV1PerformanceGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []PerformanceEntry
func (a *FreqtradeAPIService) PerformanceApiV1PerformanceGetExecute(r ApiPerformanceApiV1PerformanceGetRequest) ([]PerformanceEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []PerformanceEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PerformanceApiV1PerformanceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/performance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPingApiV1PingGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiPingApiV1PingGetRequest) Execute() (*Ping, *http.Response, error) {
	return r.ApiService.PingApiV1PingGetExecute(r)
}

/*
PingApiV1PingGet Ping

simple ping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPingApiV1PingGetRequest
*/
func (a *FreqtradeAPIService) PingApiV1PingGet(ctx context.Context) ApiPingApiV1PingGetRequest {
	return ApiPingApiV1PingGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Ping
func (a *FreqtradeAPIService) PingApiV1PingGetExecute(r ApiPingApiV1PingGetRequest) (*Ping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Ping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PingApiV1PingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlotConfigApiV1PlotConfigGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	strategy   *string
}

func (r ApiPlotConfigApiV1PlotConfigGetRequest) Strategy(strategy string) ApiPlotConfigApiV1PlotConfigGetRequest {
	r.strategy = &strategy
	return r
}

func (r ApiPlotConfigApiV1PlotConfigGetRequest) Execute() (*RootModelUnionPlotConfigDict, *http.Response, error) {
	return r.ApiService.PlotConfigApiV1PlotConfigGetExecute(r)
}

/*
PlotConfigApiV1PlotConfigGet Plot Config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPlotConfigApiV1PlotConfigGetRequest
*/
func (a *FreqtradeAPIService) PlotConfigApiV1PlotConfigGet(ctx context.Context) ApiPlotConfigApiV1PlotConfigGetRequest {
	return ApiPlotConfigApiV1PlotConfigGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RootModelUnionPlotConfigDict
func (a *FreqtradeAPIService) PlotConfigApiV1PlotConfigGetExecute(r ApiPlotConfigApiV1PlotConfigGetRequest) (*RootModelUnionPlotConfigDict, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RootModelUnionPlotConfigDict
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.PlotConfigApiV1PlotConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/plot_config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.strategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategy", r.strategy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProfitAllApiV1ProfitAllGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiProfitAllApiV1ProfitAllGetRequest) Execute() (*ProfitAll, *http.Response, error) {
	return r.ApiService.ProfitAllApiV1ProfitAllGetExecute(r)
}

/*
ProfitAllApiV1ProfitAllGet Profit All

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiProfitAllApiV1ProfitAllGetRequest
*/
func (a *FreqtradeAPIService) ProfitAllApiV1ProfitAllGet(ctx context.Context) ApiProfitAllApiV1ProfitAllGetRequest {
	return ApiProfitAllApiV1ProfitAllGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ProfitAll
func (a *FreqtradeAPIService) ProfitAllApiV1ProfitAllGetExecute(r ApiProfitAllApiV1ProfitAllGetRequest) (*ProfitAll, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProfitAll
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ProfitAllApiV1ProfitAllGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/profit_all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProfitApiV1ProfitGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiProfitApiV1ProfitGetRequest) Execute() (*Profit, *http.Response, error) {
	return r.ApiService.ProfitApiV1ProfitGetExecute(r)
}

/*
ProfitApiV1ProfitGet Profit

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiProfitApiV1ProfitGetRequest
*/
func (a *FreqtradeAPIService) ProfitApiV1ProfitGet(ctx context.Context) ApiProfitApiV1ProfitGetRequest {
	return ApiProfitApiV1ProfitGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Profit
func (a *FreqtradeAPIService) ProfitApiV1ProfitGetExecute(r ApiProfitApiV1ProfitGetRequest) (*Profit, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Profit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ProfitApiV1ProfitGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/profit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReloadConfigApiV1ReloadConfigPostRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiReloadConfigApiV1ReloadConfigPostRequest) Execute() (*StatusMsg, *http.Response, error) {
	return r.ApiService.ReloadConfigApiV1ReloadConfigPostExecute(r)
}

/*
ReloadConfigApiV1ReloadConfigPost Reload Config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReloadConfigApiV1ReloadConfigPostRequest
*/
func (a *FreqtradeAPIService) ReloadConfigApiV1ReloadConfigPost(ctx context.Context) ApiReloadConfigApiV1ReloadConfigPostRequest {
	return ApiReloadConfigApiV1ReloadConfigPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusMsg
func (a *FreqtradeAPIService) ReloadConfigApiV1ReloadConfigPostExecute(r ApiReloadConfigApiV1ReloadConfigPostRequest) (*StatusMsg, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusMsg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ReloadConfigApiV1ReloadConfigPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/reload_config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShowConfigApiV1ShowConfigGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiShowConfigApiV1ShowConfigGetRequest) Execute() (*ShowConfig, *http.Response, error) {
	return r.ApiService.ShowConfigApiV1ShowConfigGetExecute(r)
}

/*
ShowConfigApiV1ShowConfigGet Show Config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiShowConfigApiV1ShowConfigGetRequest
*/
func (a *FreqtradeAPIService) ShowConfigApiV1ShowConfigGet(ctx context.Context) ApiShowConfigApiV1ShowConfigGetRequest {
	return ApiShowConfigApiV1ShowConfigGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ShowConfig
func (a *FreqtradeAPIService) ShowConfigApiV1ShowConfigGetExecute(r ApiShowConfigApiV1ShowConfigGetRequest) (*ShowConfig, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShowConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.ShowConfigApiV1ShowConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/show_config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartApiV1StartPostRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiStartApiV1StartPostRequest) Execute() (*StatusMsg, *http.Response, error) {
	return r.ApiService.StartApiV1StartPostExecute(r)
}

/*
StartApiV1StartPost Start

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStartApiV1StartPostRequest
*/
func (a *FreqtradeAPIService) StartApiV1StartPost(ctx context.Context) ApiStartApiV1StartPostRequest {
	return ApiStartApiV1StartPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusMsg
func (a *FreqtradeAPIService) StartApiV1StartPostExecute(r ApiStartApiV1StartPostRequest) (*StatusMsg, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusMsg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.StartApiV1StartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStatsApiV1StatsGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiStatsApiV1StatsGetRequest) Execute() (*Stats, *http.Response, error) {
	return r.ApiService.StatsApiV1StatsGetExecute(r)
}

/*
StatsApiV1StatsGet Stats

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStatsApiV1StatsGetRequest
*/
func (a *FreqtradeAPIService) StatsApiV1StatsGet(ctx context.Context) ApiStatsApiV1StatsGetRequest {
	return ApiStatsApiV1StatsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Stats
func (a *FreqtradeAPIService) StatsApiV1StatsGetExecute(r ApiStatsApiV1StatsGetRequest) (*Stats, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Stats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.StatsApiV1StatsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStatusApiV1StatusGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiStatusApiV1StatusGetRequest) Execute() ([]OpenTradeSchema, *http.Response, error) {
	return r.ApiService.StatusApiV1StatusGetExecute(r)
}

/*
StatusApiV1StatusGet Status

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStatusApiV1StatusGetRequest
*/
func (a *FreqtradeAPIService) StatusApiV1StatusGet(ctx context.Context) ApiStatusApiV1StatusGetRequest {
	return ApiStatusApiV1StatusGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []OpenTradeSchema
func (a *FreqtradeAPIService) StatusApiV1StatusGetExecute(r ApiStatusApiV1StatusGetRequest) ([]OpenTradeSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OpenTradeSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.StatusApiV1StatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopApiV1StopPostRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiStopApiV1StopPostRequest) Execute() (*StatusMsg, *http.Response, error) {
	return r.ApiService.StopApiV1StopPostExecute(r)
}

/*
StopApiV1StopPost Stop

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStopApiV1StopPostRequest
*/
func (a *FreqtradeAPIService) StopApiV1StopPost(ctx context.Context) ApiStopApiV1StopPostRequest {
	return ApiStopApiV1StopPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusMsg
func (a *FreqtradeAPIService) StopApiV1StopPostExecute(r ApiStopApiV1StopPostRequest) (*StatusMsg, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusMsg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.StopApiV1StopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/stop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSysinfoApiV1SysinfoGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiSysinfoApiV1SysinfoGetRequest) Execute() (*SysInfo, *http.Response, error) {
	return r.ApiService.SysinfoApiV1SysinfoGetExecute(r)
}

/*
SysinfoApiV1SysinfoGet Sysinfo

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSysinfoApiV1SysinfoGetRequest
*/
func (a *FreqtradeAPIService) SysinfoApiV1SysinfoGet(ctx context.Context) ApiSysinfoApiV1SysinfoGetRequest {
	return ApiSysinfoApiV1SysinfoGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SysInfo
func (a *FreqtradeAPIService) SysinfoApiV1SysinfoGetExecute(r ApiSysinfoApiV1SysinfoGetRequest) (*SysInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SysInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.SysinfoApiV1SysinfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sysinfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTokenLoginApiV1TokenLoginPostRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiTokenLoginApiV1TokenLoginPostRequest) Execute() (*AccessAndRefreshToken, *http.Response, error) {
	return r.ApiService.TokenLoginApiV1TokenLoginPostExecute(r)
}

/*
TokenLoginApiV1TokenLoginPost Token Login

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTokenLoginApiV1TokenLoginPostRequest
*/
func (a *FreqtradeAPIService) TokenLoginApiV1TokenLoginPost(ctx context.Context) ApiTokenLoginApiV1TokenLoginPostRequest {
	return ApiTokenLoginApiV1TokenLoginPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AccessAndRefreshToken
func (a *FreqtradeAPIService) TokenLoginApiV1TokenLoginPostExecute(r ApiTokenLoginApiV1TokenLoginPostRequest) (*AccessAndRefreshToken, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccessAndRefreshToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.TokenLoginApiV1TokenLoginPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/token/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTokenRefreshApiV1TokenRefreshPostRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiTokenRefreshApiV1TokenRefreshPostRequest) Execute() (*AccessToken, *http.Response, error) {
	return r.ApiService.TokenRefreshApiV1TokenRefreshPostExecute(r)
}

/*
TokenRefreshApiV1TokenRefreshPost Token Refresh

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTokenRefreshApiV1TokenRefreshPostRequest
*/
func (a *FreqtradeAPIService) TokenRefreshApiV1TokenRefreshPost(ctx context.Context) ApiTokenRefreshApiV1TokenRefreshPostRequest {
	return ApiTokenRefreshApiV1TokenRefreshPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AccessToken
func (a *FreqtradeAPIService) TokenRefreshApiV1TokenRefreshPostExecute(r ApiTokenRefreshApiV1TokenRefreshPostRequest) (*AccessToken, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccessToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.TokenRefreshApiV1TokenRefreshPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/token/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTradeApiV1TradeTradeidGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	tradeid    int64
}

func (r ApiTradeApiV1TradeTradeidGetRequest) Execute() (*OpenTradeSchema, *http.Response, error) {
	return r.ApiService.TradeApiV1TradeTradeidGetExecute(r)
}

/*
TradeApiV1TradeTradeidGet Trade

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tradeid
	@return ApiTradeApiV1TradeTradeidGetRequest
*/
func (a *FreqtradeAPIService) TradeApiV1TradeTradeidGet(ctx context.Context, tradeid int64) ApiTradeApiV1TradeTradeidGetRequest {
	return ApiTradeApiV1TradeTradeidGetRequest{
		ApiService: a,
		ctx:        ctx,
		tradeid:    tradeid,
	}
}

// Execute executes the request
//
//	@return OpenTradeSchema
func (a *FreqtradeAPIService) TradeApiV1TradeTradeidGetExecute(r ApiTradeApiV1TradeTradeidGetRequest) (*OpenTradeSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OpenTradeSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.TradeApiV1TradeTradeidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/trade/{tradeid}"
	localVarPath = strings.Replace(localVarPath, "{"+"tradeid"+"}", url.PathEscape(parameterValueToString(r.tradeid, "tradeid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTradeCancelOpenOrderApiV1TradesTradeidOpenOrderDeleteRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	tradeid    int64
}

func (r ApiTradeCancelOpenOrderApiV1TradesTradeidOpenOrderDeleteRequest) Execute() (*OpenTradeSchema, *http.Response, error) {
	return r.ApiService.TradeCancelOpenOrderApiV1TradesTradeidOpenOrderDeleteExecute(r)
}

/*
TradeCancelOpenOrderApiV1TradesTradeidOpenOrderDelete Trade Cancel Open Order

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tradeid
	@return ApiTradeCancelOpenOrderApiV1TradesTradeidOpenOrderDeleteRequest
*/
func (a *FreqtradeAPIService) TradeCancelOpenOrderApiV1TradesTradeidOpenOrderDelete(ctx context.Context, tradeid int64) ApiTradeCancelOpenOrderApiV1TradesTradeidOpenOrderDeleteRequest {
	return ApiTradeCancelOpenOrderApiV1TradesTradeidOpenOrderDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		tradeid:    tradeid,
	}
}

// Execute executes the request
//
//	@return OpenTradeSchema
func (a *FreqtradeAPIService) TradeCancelOpenOrderApiV1TradesTradeidOpenOrderDeleteExecute(r ApiTradeCancelOpenOrderApiV1TradesTradeidOpenOrderDeleteRequest) (*OpenTradeSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OpenTradeSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.TradeCancelOpenOrderApiV1TradesTradeidOpenOrderDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/trades/{tradeid}/open-order"
	localVarPath = strings.Replace(localVarPath, "{"+"tradeid"+"}", url.PathEscape(parameterValueToString(r.tradeid, "tradeid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTradeReloadApiV1TradesTradeidReloadPostRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	tradeid    int64
}

func (r ApiTradeReloadApiV1TradesTradeidReloadPostRequest) Execute() (*OpenTradeSchema, *http.Response, error) {
	return r.ApiService.TradeReloadApiV1TradesTradeidReloadPostExecute(r)
}

/*
TradeReloadApiV1TradesTradeidReloadPost Trade Reload

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tradeid
	@return ApiTradeReloadApiV1TradesTradeidReloadPostRequest
*/
func (a *FreqtradeAPIService) TradeReloadApiV1TradesTradeidReloadPost(ctx context.Context, tradeid int64) ApiTradeReloadApiV1TradesTradeidReloadPostRequest {
	return ApiTradeReloadApiV1TradesTradeidReloadPostRequest{
		ApiService: a,
		ctx:        ctx,
		tradeid:    tradeid,
	}
}

// Execute executes the request
//
//	@return OpenTradeSchema
func (a *FreqtradeAPIService) TradeReloadApiV1TradesTradeidReloadPostExecute(r ApiTradeReloadApiV1TradesTradeidReloadPostRequest) (*OpenTradeSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OpenTradeSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.TradeReloadApiV1TradesTradeidReloadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/trades/{tradeid}/reload"
	localVarPath = strings.Replace(localVarPath, "{"+"tradeid"+"}", url.PathEscape(parameterValueToString(r.tradeid, "tradeid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTradesApiV1TradesGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	limit      *int64
	offset     *int64
	orderById  *bool
}

// Maximum number of different trades to return data
func (r ApiTradesApiV1TradesGetRequest) Limit(limit int64) ApiTradesApiV1TradesGetRequest {
	r.limit = &limit
	return r
}

// Number of trades to skip for pagination
func (r ApiTradesApiV1TradesGetRequest) Offset(offset int64) ApiTradesApiV1TradesGetRequest {
	r.offset = &offset
	return r
}

// Sort trades by id (default: True). If False, sorts by latest timestamp
func (r ApiTradesApiV1TradesGetRequest) OrderById(orderById bool) ApiTradesApiV1TradesGetRequest {
	r.orderById = &orderById
	return r
}

func (r ApiTradesApiV1TradesGetRequest) Execute() (*TradeResponse, *http.Response, error) {
	return r.ApiService.TradesApiV1TradesGetExecute(r)
}

/*
TradesApiV1TradesGet Trades

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTradesApiV1TradesGetRequest
*/
func (a *FreqtradeAPIService) TradesApiV1TradesGet(ctx context.Context) ApiTradesApiV1TradesGetRequest {
	return ApiTradesApiV1TradesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TradeResponse
func (a *FreqtradeAPIService) TradesApiV1TradesGetExecute(r ApiTradesApiV1TradesGetRequest) (*TradeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TradeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.TradesApiV1TradesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 500
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", defaultValue, "form", "")
		r.offset = &defaultValue
	}
	if r.orderById != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by_id", r.orderById, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by_id", defaultValue, "form", "")
		r.orderById = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTradesDeleteApiV1TradesTradeidDeleteRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	tradeid    int64
}

func (r ApiTradesDeleteApiV1TradesTradeidDeleteRequest) Execute() (*DeleteTrade, *http.Response, error) {
	return r.ApiService.TradesDeleteApiV1TradesTradeidDeleteExecute(r)
}

/*
TradesDeleteApiV1TradesTradeidDelete Trades Delete

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tradeid
	@return ApiTradesDeleteApiV1TradesTradeidDeleteRequest
*/
func (a *FreqtradeAPIService) TradesDeleteApiV1TradesTradeidDelete(ctx context.Context, tradeid int64) ApiTradesDeleteApiV1TradesTradeidDeleteRequest {
	return ApiTradesDeleteApiV1TradesTradeidDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		tradeid:    tradeid,
	}
}

// Execute executes the request
//
//	@return DeleteTrade
func (a *FreqtradeAPIService) TradesDeleteApiV1TradesTradeidDeleteExecute(r ApiTradesDeleteApiV1TradesTradeidDeleteRequest) (*DeleteTrade, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteTrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.TradesDeleteApiV1TradesTradeidDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/trades/{tradeid}"
	localVarPath = strings.Replace(localVarPath, "{"+"tradeid"+"}", url.PathEscape(parameterValueToString(r.tradeid, "tradeid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVersionApiV1VersionGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiVersionApiV1VersionGetRequest) Execute() (*Version, *http.Response, error) {
	return r.ApiService.VersionApiV1VersionGetExecute(r)
}

/*
VersionApiV1VersionGet Version

Bot Version info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVersionApiV1VersionGetRequest
*/
func (a *FreqtradeAPIService) VersionApiV1VersionGet(ctx context.Context) ApiVersionApiV1VersionGetRequest {
	return ApiVersionApiV1VersionGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Version
func (a *FreqtradeAPIService) VersionApiV1VersionGetExecute(r ApiVersionApiV1VersionGetRequest) (*Version, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Version
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.VersionApiV1VersionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWeeklyApiV1WeeklyGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
	timescale  *int64
}

// Number of weeks to fetch data for
func (r ApiWeeklyApiV1WeeklyGetRequest) Timescale(timescale int64) ApiWeeklyApiV1WeeklyGetRequest {
	r.timescale = &timescale
	return r
}

func (r ApiWeeklyApiV1WeeklyGetRequest) Execute() (*DailyWeeklyMonthly, *http.Response, error) {
	return r.ApiService.WeeklyApiV1WeeklyGetExecute(r)
}

/*
WeeklyApiV1WeeklyGet Weekly

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWeeklyApiV1WeeklyGetRequest
*/
func (a *FreqtradeAPIService) WeeklyApiV1WeeklyGet(ctx context.Context) ApiWeeklyApiV1WeeklyGetRequest {
	return ApiWeeklyApiV1WeeklyGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DailyWeeklyMonthly
func (a *FreqtradeAPIService) WeeklyApiV1WeeklyGetExecute(r ApiWeeklyApiV1WeeklyGetRequest) (*DailyWeeklyMonthly, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DailyWeeklyMonthly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.WeeklyApiV1WeeklyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/weekly"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timescale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timescale", r.timescale, "form", "")
	} else {
		var defaultValue int64 = 4
		parameterAddToHeaderOrQuery(localVarQueryParams, "timescale", defaultValue, "form", "")
		r.timescale = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistApiV1WhitelistGetRequest struct {
	ctx        context.Context
	ApiService *FreqtradeAPIService
}

func (r ApiWhitelistApiV1WhitelistGetRequest) Execute() (*WhitelistResponse, *http.Response, error) {
	return r.ApiService.WhitelistApiV1WhitelistGetExecute(r)
}

/*
WhitelistApiV1WhitelistGet Whitelist

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWhitelistApiV1WhitelistGetRequest
*/
func (a *FreqtradeAPIService) WhitelistApiV1WhitelistGet(ctx context.Context) ApiWhitelistApiV1WhitelistGetRequest {
	return ApiWhitelistApiV1WhitelistGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WhitelistResponse
func (a *FreqtradeAPIService) WhitelistApiV1WhitelistGetExecute(r ApiWhitelistApiV1WhitelistGetRequest) (*WhitelistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WhitelistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreqtradeAPIService.WhitelistApiV1WhitelistGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/whitelist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
